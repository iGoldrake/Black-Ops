<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer v3.0 - Circular Sequential Timeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* Circular Timeline Styles */
        .circular-timeline {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            aspect-ratio: 1;
        }

        .clock-face {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at center, 
                rgba(255, 255, 255, 0.95) 0%, 
                rgba(248, 250, 252, 0.95) 100%);
            box-shadow: 
                inset 0 0 40px rgba(0, 0, 0, 0.05),
                0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .clock-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .hour-mark {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 2px;
            height: 20px;
            background: #94a3b8;
            transform-origin: center 340px;
        }

        .hour-mark.major {
            width: 4px;
            height: 30px;
            background: #475569;
        }

        .hour-number {
            position: absolute;
            font-weight: 700;
            font-size: 16px;
            color: #334155;
            transform: translate(-50%, -50%);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .program-arc {
            fill: none;
            stroke-width: 50;
            stroke-linecap: butt;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        .program-arc:hover {
            stroke-width: 60;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }

        .time-hand {
            position: absolute;
            background: linear-gradient(to top, #ef4444 0%, #dc2626 100%);
            transform-origin: bottom center;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .hour-hand {
            width: 8px;
            height: 120px;
            bottom: 50%;
            left: calc(50% - 4px);
        }

        .minute-hand {
            width: 6px;
            height: 160px;
            bottom: 50%;
            left: calc(50% - 3px);
        }

        /* Program preview tooltip */
        .program-preview {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            backdrop-filter: blur(20px);
            color: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            max-width: 350px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .program-preview.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .preview-icon {
            width: 80px;
            height: 45px;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Statistics Cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
        }

        /* Coverage Ring */
        .coverage-ring {
            transform: rotate(-90deg);
            transition: stroke-dasharray 0.5s ease;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes rotateIn {
            from {
                opacity: 0;
                transform: rotate(-180deg) scale(0.5);
            }
            to {
                opacity: 1;
                transform: rotate(0) scale(1);
            }
        }

        .program-arc.new {
            animation: rotateIn 0.6s ease-out;
        }

        /* Dark mode support */
        .dark .clock-face {
            background: radial-gradient(circle at center, 
                rgba(30, 41, 59, 0.95) 0%, 
                rgba(15, 23, 42, 0.95) 100%);
            box-shadow: 
                inset 0 0 40px rgba(0, 0, 0, 0.3),
                0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .dark .hour-number {
            color: #e2e8f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .dark .hour-mark {
            background: #64748b;
        }

        .dark .hour-mark.major {
            background: #94a3b8;
        }

        .dark .stat-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Toast improvements */
        .toast {
            animation: slideInRight 0.3s ease-out;
            backdrop-filter: blur(10px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #1e293b;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        .toast.success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.95) 100%);
            color: white;
        }

        .toast.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%);
            color: white;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        /* Gradient text */
        .gradient-text {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Format legend */
        .format-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
        }

        .format-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            background: white;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.2s;
        }

        .format-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .format-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Gap indicator on timeline */
        .gap-arc {
            fill: none;
            stroke: #ef4444;
            stroke-width: 50;
            stroke-dasharray: 5, 5;
            opacity: 0.5;
            pointer-events: none;
        }

        /* Loading state */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-4xl font-bold gradient-text flex items-center gap-3">
                        <i data-lucide="tv" class="w-10 h-10 text-blue-600"></i>
                        XMLTV Viewer v3.0
                    </h1>
                    <p class="text-gray-600 mt-2">Timeline Circolare Sequenziale - Modalit√† UTC</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Dark Mode">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Informazioni">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-8 mb-6 border border-white/50">
            <div class="border-3 border-dashed border-gray-300 rounded-xl p-12 text-center hover:border-blue-500 transition-all duration-300 hover:bg-blue-50/50" id="dropZone">
                <i data-lucide="upload-cloud" class="w-16 h-16 mx-auto text-gray-400 mb-4"></i>
                <p class="text-xl mb-2 font-semibold text-gray-700">Trascina qui il file XMLTV</p>
                <p class="text-gray-500 mb-4">oppure</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-8 py-3 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Stats -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="tv-2" class="w-4 h-4"></i>
                            Canale
                        </h3>
                        <p class="text-2xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="calendar" class="w-4 h-4"></i>
                            Data Palinsesto
                        </h3>
                        <p class="text-2xl font-bold" id="scheduleDate">-</p>
                        <p class="text-sm text-gray-600">
                            <span id="programCount">-</span> programmi
                        </p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="pie-chart" class="w-4 h-4"></i>
                            Copertura
                        </h3>
                        <div class="flex items-center gap-3">
                            <svg width="50" height="50" viewBox="0 0 50 50">
                                <circle cx="25" cy="25" r="20" fill="none" stroke="#e5e7eb" stroke-width="8"/>
                                <circle cx="25" cy="25" r="20" fill="none" stroke="url(#coverageGradient)" stroke-width="8" 
                                    stroke-dasharray="126" stroke-dashoffset="126" class="coverage-ring" id="coverageRing"/>
                                <defs>
                                    <linearGradient id="coverageGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#3b82f6"/>
                                        <stop offset="100%" style="stop-color:#8b5cf6"/>
                                    </linearGradient>
                                </defs>
                            </svg>
                            <div>
                                <p class="text-2xl font-bold" id="coveragePercent">0%</p>
                                <p class="text-sm text-gray-600" id="coverageTime">0h 0m</p>
                            </div>
                        </div>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="activity" class="w-4 h-4"></i>
                            Statistiche
                        </h3>
                        <div class="space-y-1">
                            <p class="text-sm"><span class="font-semibold" id="gapCount">0</span> gaps</p>
                            <p class="text-sm"><span class="font-semibold" id="formatCount">0</span> format unici</p>
                            <p class="text-sm"><span class="font-semibold" id="avgDuration">0m</span> durata media</p>
                        </div>
                    </div>
                </div>
                
                <!-- Actions -->
                <div class="flex justify-center gap-3 mt-6">
                    <button onclick="showActualizationDialog()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-6 py-2.5 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="calendar-days" class="w-4 h-4"></i>
                        Attualizza Date
                    </button>
                    <button onclick="exportXMLTV()" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        Esporta XMLTV
                    </button>
                </div>
            </div>

            <!-- Circular Timeline -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="clock" class="w-6 h-6 text-blue-600"></i>
                        Timeline Circolare Sequenziale
                    </span>
                    <span class="text-sm font-normal text-gray-600">
                        Visualizzazione basata su durata (86.400 secondi = 24h)
                    </span>
                </h3>
                
                <div class="circular-timeline" id="circularTimeline">
                    <svg width="100%" height="100%" viewBox="0 0 700 700">
                        <defs>
                            <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.15"/>
                            </filter>
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                <feMerge>
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        
                        <!-- Clock face background -->
                        <circle cx="350" cy="350" r="340" fill="url(#clockFaceGradient)" stroke="#e5e7eb" stroke-width="2" filter="url(#shadow)"/>
                        <defs>
                            <radialGradient id="clockFaceGradient">
                                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.95"/>
                                <stop offset="100%" style="stop-color:#f8fafc;stop-opacity:0.95"/>
                            </radialGradient>
                        </defs>
                        
                        <g id="clockMarks">
                            <!-- Hour marks will be added here -->
                        </g>
                        
                        <g id="programArcs">
                            <!-- Program arcs will be added here -->
                        </g>
                        
                        <g id="clockHands">
                            <!-- Clock hands will be added here -->
                        </g>
                        
                        <!-- Center cap -->
                        <circle cx="350" cy="350" r="12" fill="url(#centerGradient)" filter="url(#shadow)"/>
                        <defs>
                            <linearGradient id="centerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#1e293b"/>
                                <stop offset="100%" style="stop-color:#334155"/>
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                
                <!-- Format Legend -->
                <div class="mt-6">
                    <h4 class="font-semibold text-gray-700 mb-2">Legenda Format</h4>
                    <div class="format-legend" id="formatLegend">
                        <!-- Format items will be added here -->
                    </div>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50" id="programDetails" style="display:none;">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-6 h-6 text-blue-600"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Titolo/Format</p>
                        <p class="font-semibold text-lg" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Orario UTC</p>
                        <p class="font-semibold text-lg" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Durata</p>
                        <p class="font-semibold text-lg" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Categoria</p>
                        <p class="font-semibold text-lg" id="detailCategory">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600 mb-1">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600 mb-1">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="w-32 h-18 bg-gray-200 rounded-lg overflow-hidden" id="detailIcon" style="background-size: cover; background-position: center;"></div>
                            <p class="text-xs text-gray-500 break-all" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit-3" class="w-6 h-6 text-blue-600"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 py-2 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 text-sm flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="plus-circle" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto rounded-lg border border-gray-200">
                    <table class="w-full text-sm">
                        <thead class="bg-gradient-to-r from-gray-50 to-gray-100">
                            <tr>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Ora Inizio UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Ora Fine UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Durata</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Titolo/Format</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Categoria</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable" class="divide-y divide-gray-200">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Problems Report -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="alert-triangle" class="w-6 h-6 text-orange-600"></i>
                    Report Problemi
                </h3>
                <div id="problemsReport" class="space-y-2">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-2xl p-8 max-w-md w-full shadow-2xl transform transition-all">
                <h3 class="text-2xl font-bold mb-4 gradient-text">Attualizza Date Palinsesto</h3>
                <p class="text-gray-600 mb-6">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none transition-colors">
                <div class="flex justify-end gap-3 mt-6">
                    <button onclick="closeActualizationDialog()" class="px-6 py-2.5 border-2 border-gray-300 rounded-lg hover:bg-gray-50 transition-colors font-semibold">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-3"></div>

        <!-- Program Preview -->
        <div id="programPreview" class="program-preview">
            <div class="preview-icon" id="previewIcon"></div>
            <h4 class="font-bold text-xl mb-3" id="previewTitle"></h4>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                    <span class="text-gray-400">Orario UTC:</span>
                    <span class="font-semibold" id="previewTime"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Durata:</span>
                    <span class="font-semibold" id="previewDuration"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Categoria:</span>
                    <span class="font-semibold" id="previewCategory"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Posizione:</span>
                    <span class="font-semibold" id="previewPosition"></span>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-4 italic" id="previewDesc"></p>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        window.addEventListener('DOMContentLoaded', function() {
            lucide.createIcons();
        });

        // Version
        const APP_VERSION = '3.0';
        console.log(`XMLTV Viewer v${APP_VERSION} - Circular Sequential Timeline`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let scheduleDate = null;
        let formatColors = {};
        let colorIndex = 0;
        let currentPreviewTimeout = null;
        let totalDaySeconds = 86400; // 24 hours in seconds

        // Modern color palette
        const colorPalette = [
            '#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', 
            '#10b981', '#06b6d4', '#6366f1', '#f43f5e',
            '#84cc16', '#a855f7', '#0ea5e9', '#f97316',
            '#14b8a6', '#d946ef', '#0891b2', '#dc2626'
        ];

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('border-blue-500', 'bg-blue-50');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            }, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const files = e.dataTransfer.files;
            handleFiles(files);
        }

        fileInput.addEventListener('change', function(e) {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/xml' || file.type === 'application/xml' || file.name.endsWith('.xml')) {
                    loadFile(file);
                } else {
                    showToast('Seleziona un file XML valido', 'error');
                }
            }
        }

        function loadFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.getElementsByTagName('parsererror');
                    if (parserError.length > 0) {
                        throw new Error('Errore nel parsing XML');
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            currentPrograms = [];
            
            programmes.forEach((prog) => {
                const startStr = prog.getAttribute('start');
                const stopStr = prog.getAttribute('stop');
                
                if (!startStr || !stopStr) return;
                
                const startUTC = parseXMLTVDateUTC(startStr);
                const stopUTC = parseXMLTVDateUTC(stopStr);
                
                const title = prog.querySelector('title')?.textContent || '';
                const desc = prog.querySelector('desc')?.textContent || '';
                const category = prog.querySelector('category')?.textContent || '';
                const ratingValue = prog.querySelector('rating value');
                const rating = ratingValue ? ratingValue.textContent : '0';
                const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                
                const program = {
                    start: startUTC,
                    stop: stopUTC,
                    title,
                    desc,
                    category,
                    rating,
                    icon,
                    duration: (stopUTC - startUTC) / 1000, // seconds
                    element: prog
                };
                
                currentPrograms.push(program);
                
                // Assign color to format
                if (!formatColors[title]) {
                    formatColors[title] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
            });
            
            if (currentPrograms.length === 0) {
                showToast('Nessun programma trovato nel file', 'error');
                return;
            }
            
            // Sort programs by start time
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Auto-detect the main programming day
            detectMainProgrammingDay();
            
            // Load programs
            loadPrograms();
        }

        function detectMainProgrammingDay() {
            // Count programs per day
            const programsByDay = {};
            
            currentPrograms.forEach(program => {
                const dayKey = program.start.toISOString().split('T')[0];
                if (!programsByDay[dayKey]) {
                    programsByDay[dayKey] = [];
                }
                programsByDay[dayKey].push(program);
            });
            
            // Find the day with most programs
            let maxPrograms = 0;
            let bestDay = null;
            
            Object.entries(programsByDay).forEach(([day, programs]) => {
                if (programs.length > maxPrograms) {
                    maxPrograms = programs.length;
                    bestDay = day;
                }
            });
            
            // Set schedule date
            if (bestDay) {
                const [year, month, day] = bestDay.split('-').map(Number);
                scheduleDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
            } else {
                scheduleDate = new Date(currentPrograms[0].start);
                scheduleDate.setUTCHours(0, 0, 0, 0);
            }
            
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
        }

        function parseXMLTVDateUTC(dateStr) {
            // Check if it's ISO 8601 format (contains 'T')
            if (dateStr.includes('T')) {
                // ISO 8601 format: 2025-06-09T21:00:00+0000
                // Remove timezone info and parse as UTC
                const cleanDate = dateStr.replace(/[+-]\d{4}$/, '');
                const [datePart, timePart] = cleanDate.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, minute, second] = timePart.split(':').map(Number);
                
                return new Date(Date.UTC(year, month - 1, day, hour, minute, second || 0));
            } else {
                // Classic XMLTV format: YYYYMMDDHHmmss +0000
                const year = parseInt(dateStr.substr(0, 4));
                const month = parseInt(dateStr.substr(4, 2)) - 1;
                const day = parseInt(dateStr.substr(6, 2));
                const hour = parseInt(dateStr.substr(8, 2));
                const minute = parseInt(dateStr.substr(10, 2));
                const second = parseInt(dateStr.substr(12, 2));
                
                return new Date(Date.UTC(year, month, day, hour, minute, second));
            }
        }

        function formatXMLTVDate(date) {
            // Use ISO 8601 format for better compatibility
            const pad = (n) => String(n).padStart(2, '0');
            const year = date.getUTCFullYear();
            const month = pad(date.getUTCMonth() + 1);
            const day = pad(date.getUTCDate());
            const hours = pad(date.getUTCHours());
            const minutes = pad(date.getUTCMinutes());
            const seconds = pad(date.getUTCSeconds());
            
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+0000`;
        }

        function loadPrograms() {
            // Get programs for the schedule day (including evening programs from previous day)
            const dayStart = new Date(scheduleDate);
            dayStart.setUTCHours(21, 0, 0, 0); // Start from 21:00 previous day
            dayStart.setUTCDate(dayStart.getUTCDate() - 1);
            
            const dayEnd = new Date(scheduleDate);
            dayEnd.setUTCHours(21, 0, 0, 0); // End at 21:00 current day
            
            const dayPrograms = currentPrograms.filter(p => {
                return (p.start >= dayStart && p.start < dayEnd) || 
                       (p.start < dayStart && p.stop > dayStart);
            }).sort((a, b) => a.start - b.start);
            
            document.getElementById('programCount').textContent = dayPrograms.length;
            
            // Draw circular timeline
            drawCircularTimeline(dayPrograms);
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update statistics
            updateStatistics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
            
            // Update format legend
            updateFormatLegend(dayPrograms);
        }

        function drawCircularTimeline(programs) {
            const svg = document.querySelector('#circularTimeline svg');
            const clockMarks = svg.getElementById('clockMarks');
            const programArcs = svg.getElementById('programArcs');
            const clockHands = svg.getElementById('clockHands');
            
            // Clear existing content
            clockMarks.innerHTML = '';
            programArcs.innerHTML = '';
            clockHands.innerHTML = '';
            
            const centerX = 350;
            const centerY = 350;
            const radius = 340;
            const innerRadius = 200;
            
            // Draw hour marks and numbers
            for (let hour = 0; hour < 24; hour++) {
                const angle = (hour * 15) - 90; // 15 degrees per hour
                const radian = angle * Math.PI / 180;
                
                // Hour marks
                const markLength = hour % 6 === 0 ? 30 : hour % 3 === 0 ? 20 : 10;
                const markStart = radius - markLength;
                
                const x1 = centerX + markStart * Math.cos(radian);
                const y1 = centerY + markStart * Math.sin(radian);
                const x2 = centerX + radius * Math.cos(radian);
                const y2 = centerY + radius * Math.sin(radian);
                
                const mark = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                mark.setAttribute('x1', x1);
                mark.setAttribute('y1', y1);
                mark.setAttribute('x2', x2);
                mark.setAttribute('y2', y2);
                mark.setAttribute('stroke', hour % 6 === 0 ? '#475569' : '#94a3b8');
                mark.setAttribute('stroke-width', hour % 6 === 0 ? '4' : hour % 3 === 0 ? '2' : '1');
                mark.setAttribute('stroke-linecap', 'round');
                clockMarks.appendChild(mark);
                
                // Hour numbers (every 3 hours)
                if (hour % 3 === 0) {
                    const textRadius = radius - 45;
                    const textX = centerX + textRadius * Math.cos(radian);
                    const textY = centerY + textRadius * Math.sin(radian);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('font-size', '20');
                    text.setAttribute('font-weight', '700');
                    text.setAttribute('fill', '#334155');
                    text.setAttribute('class', 'hour-number');
                    text.textContent = hour.toString().padStart(2, '0');
                    clockMarks.appendChild(text);
                }
            }
            
            // Calculate sequential positions
            let currentSecond = 0;
            const programsWithPosition = [];
            
            programs.forEach((program, index) => {
                const startSecond = currentSecond;
                const endSecond = Math.min(currentSecond + program.duration, totalDaySeconds);
                
                programsWithPosition.push({
                    ...program,
                    sequentialStart: startSecond,
                    sequentialEnd: endSecond,
                    index
                });
                
                currentSecond = endSecond;
            });
            
            // Draw programs as arcs
            programsWithPosition.forEach((program) => {
                const startAngle = (program.sequentialStart / totalDaySeconds * 360) - 90;
                const endAngle = (program.sequentialEnd / totalDaySeconds * 360) - 90;
                
                // Create arc path
                const path = createArcPath(centerX, centerY, innerRadius, radius - 40, startAngle, endAngle);
                
                const programPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                programPath.setAttribute('d', path);
                programPath.setAttribute('fill', formatColors[program.title]);
                programPath.setAttribute('stroke', 'white');
                programPath.setAttribute('stroke-width', '3');
                programPath.setAttribute('class', 'program-arc');
                programPath.style.filter = 'url(#shadow)';
                
                // Event handlers
                programPath.onclick = () => showProgramDetails(program);
                programPath.onmouseenter = (e) => showProgramPreview(e, program);
                programPath.onmouseleave = hideProgramPreview;
                
                programArcs.appendChild(programPath);
                
                // Add label if space allows
                const arcLength = Math.abs(endAngle - startAngle);
                if (arcLength > 10) {
                    const midAngle = (startAngle + endAngle) / 2;
                    const labelRadius = (innerRadius + radius - 40) / 2;
                    const radian = midAngle * Math.PI / 180;
                    
                    const labelX = centerX + labelRadius * Math.cos(radian);
                    const labelY = centerY + labelRadius * Math.sin(radian);
                    
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', labelY);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('dominant-baseline', 'middle');
                    label.setAttribute('font-size', '14');
                    label.setAttribute('font-weight', '600');
                    label.setAttribute('fill', 'white');
                    label.setAttribute('pointer-events', 'none');
                    label.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';
                    
                    const title = program.title.length > 20 ? 
                        program.title.substring(0, 20) + '...' : program.title;
                    label.textContent = title;
                    
                    // Rotate text to follow arc
                    const rotation = midAngle > 90 && midAngle < 270 ? midAngle + 180 : midAngle;
                    label.setAttribute('transform', `rotate(${rotation} ${labelX} ${labelY})`);
                    
                    programArcs.appendChild(label);
                }
            });
            
            // Draw gaps
            if (currentSecond < totalDaySeconds) {
                const gapStartAngle = (currentSecond / totalDaySeconds * 360) - 90;
                const gapEndAngle = 270; // Full circle
                
                const gapPath = createArcPath(centerX, centerY, innerRadius, radius - 40, gapStartAngle, gapEndAngle);
                
                const gap = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                gap.setAttribute('d', gapPath);
                gap.setAttribute('class', 'gap-arc');
                programArcs.appendChild(gap);
            }
            
            // Add current time hands
            const now = new Date();
            const currentHour = now.getUTCHours() + now.getUTCMinutes() / 60;
            const hourAngle = (currentHour * 15) - 90;
            const minuteAngle = ((now.getUTCMinutes() / 60) * 360) - 90;
            
            // Hour hand
            const hourHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hourHand.setAttribute('x1', centerX);
            hourHand.setAttribute('y1', centerY);
            hourHand.setAttribute('x2', centerX + 120 * Math.cos(hourAngle * Math.PI / 180));
            hourHand.setAttribute('y2', centerY + 120 * Math.sin(hourAngle * Math.PI / 180));
            hourHand.setAttribute('stroke', 'url(#handGradient)');
            hourHand.setAttribute('stroke-width', '8');
            hourHand.setAttribute('stroke-linecap', 'round');
            hourHand.setAttribute('filter', 'url(#shadow)');
            clockHands.appendChild(hourHand);
            
            // Minute hand
            const minuteHand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            minuteHand.setAttribute('x1', centerX);
            minuteHand.setAttribute('y1', centerY);
            minuteHand.setAttribute('x2', centerX + 160 * Math.cos(minuteAngle * Math.PI / 180));
            minuteHand.setAttribute('y2', centerY + 160 * Math.sin(minuteAngle * Math.PI / 180));
            minuteHand.setAttribute('stroke', 'url(#handGradient)');
            minuteHand.setAttribute('stroke-width', '6');
            minuteHand.setAttribute('stroke-linecap', 'round');
            minuteHand.setAttribute('filter', 'url(#shadow)');
            clockHands.appendChild(minuteHand);
            
            // Add gradient for hands
            const defs = svg.querySelector('defs');
            const handGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            handGradient.setAttribute('id', 'handGradient');
            handGradient.innerHTML = `
                <stop offset="0%" style="stop-color:#ef4444"/>
                <stop offset="100%" style="stop-color:#dc2626"/>
            `;
            defs.appendChild(handGradient);
        }

        function createArcPath(cx, cy, innerRadius, outerRadius, startAngle, endAngle) {
            const startRad = startAngle * Math.PI / 180;
            const endRad = endAngle * Math.PI / 180;
            
            const x1 = cx + innerRadius * Math.cos(startRad);
            const y1 = cy + innerRadius * Math.sin(startRad);
            const x2 = cx + outerRadius * Math.cos(startRad);
            const y2 = cy + outerRadius * Math.sin(startRad);
            const x3 = cx + outerRadius * Math.cos(endRad);
            const y3 = cy + outerRadius * Math.sin(endRad);
            const x4 = cx + innerRadius * Math.cos(endRad);
            const y4 = cy + innerRadius * Math.sin(endRad);
            
            const largeArc = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;
            
            return `M ${x1} ${y1} L ${x2} ${y2} A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x3} ${y3} L ${x4} ${y4} A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x1} ${y1} Z`;
        }

        function updateStatistics(programs) {
            // Calculate total coverage
            const totalDuration = programs.reduce((sum, p) => sum + p.duration, 0);
            const coveragePercent = Math.min(100, (totalDuration / totalDaySeconds) * 100);
            const coverageHours = Math.floor(totalDuration / 3600);
            const coverageMinutes = Math.floor((totalDuration % 3600) / 60);
            
            document.getElementById('coveragePercent').textContent = `${coveragePercent.toFixed(1)}%`;
            document.getElementById('coverageTime').textContent = `${coverageHours}h ${coverageMinutes}m`;
            
            // Update coverage ring
            const ring = document.getElementById('coverageRing');
            const circumference = 2 * Math.PI * 20;
            const offset = circumference - (coveragePercent / 100) * circumference;
            ring.style.strokeDashoffset = offset;
            
            // Count gaps
            let gapCount = 0;
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                if (sortedPrograms[i + 1].start > sortedPrograms[i].stop) {
                    gapCount++;
                }
            }
            document.getElementById('gapCount').textContent = gapCount;
            
            // Count unique formats
            const uniqueFormats = [...new Set(programs.map(p => p.title))];
            document.getElementById('formatCount').textContent = uniqueFormats.length;
            
            // Calculate average duration
            const avgDuration = totalDuration / programs.length;
            const avgMinutes = Math.floor(avgDuration / 60);
            document.getElementById('avgDuration').textContent = `${avgMinutes}m`;
        }

        function updateFormatLegend(programs) {
            const legend = document.getElementById('formatLegend');
            legend.innerHTML = '';
            
            const formats = [...new Set(programs.map(p => p.title))];
            formats.forEach(format => {
                const item = document.createElement('div');
                item.className = 'format-item';
                item.innerHTML = `
                    <div class="format-color" style="background: ${formatColors[format]}"></div>
                    <span>${format}</span>
                `;
                legend.appendChild(item);
            });
        }

        function showProgramPreview(event, program) {
            if (currentPreviewTimeout) {
                clearTimeout(currentPreviewTimeout);
            }
            
            currentPreviewTimeout = setTimeout(() => {
                const preview = document.getElementById('programPreview');
                
                document.getElementById('previewTitle').textContent = program.title;
                document.getElementById('previewTime').textContent = `${formatTimeUTC(program.start)} - ${formatTimeUTC(program.stop)}`;
                document.getElementById('previewDuration').textContent = formatDuration(program.duration);
                document.getElementById('previewCategory').textContent = program.category || 'N/A';
                
                // Show sequential position
                const dayPrograms = getCurrentDayPrograms();
                const position = dayPrograms.findIndex(p => p === program) + 1;
                document.getElementById('previewPosition').textContent = `${position}¬∞ di ${dayPrograms.length}`;
                
                document.getElementById('previewDesc').textContent = program.desc ? 
                    (program.desc.length > 150 ? program.desc.substring(0, 150) + '...' : program.desc) : 
                    'Nessuna descrizione disponibile';
                
                const iconDiv = document.getElementById('previewIcon');
                if (program.icon) {
                    iconDiv.style.backgroundImage = `url(${program.icon})`;
                    iconDiv.style.display = 'block';
                } else {
                    iconDiv.style.display = 'none';
                }
                
                // Position preview
                const rect = event.target.getBoundingClientRect();
                let top = rect.bottom + 10;
                let left = rect.left + rect.width / 2 - 175;
                
                if (left < 10) left = 10;
                if (left + 350 > window.innerWidth) left = window.innerWidth - 360;
                if (top + 300 > window.innerHeight) {
                    top = rect.top - 300 - 10;
                }
                
                preview.style.left = left + 'px';
                preview.style.top = top + 'px';
                preview.classList.add('show');
            }, 300);
        }

        function hideProgramPreview() {
            if (currentPreviewTimeout) {
                clearTimeout(currentPreviewTimeout);
                currentPreviewTimeout = null;
            }
            document.getElementById('programPreview').classList.remove('show');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTimeUTC(program.start)} - ${formatTimeUTC(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                
                const startTimeStr = `${program.start.getUTCHours().toString().padStart(2, '0')}:${program.start.getUTCMinutes().toString().padStart(2, '0')}`;
                const stopTimeStr = `${program.stop.getUTCHours().toString().padStart(2, '0')}:${program.stop.getUTCMinutes().toString().padStart(2, '0')}`;
                
                row.innerHTML = `
                    <td class="px-4 py-3">
                        <input type="time" value="${startTimeStr}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none">
                    </td>
                    <td class="px-4 py-3">
                        <input type="time" value="${stopTimeStr}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none">
                    </td>
                    <td class="px-4 py-3">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-3 cursor-pointer hover:bg-blue-50 rounded transition-colors" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-3 cursor-pointer hover:bg-blue-50 rounded transition-colors" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-3">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700 transition-colors p-2 hover:bg-red-50 rounded-lg" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            lucide.createIcons();
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for overlaps
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    if (programs[i].stop > programs[j].start && programs[i].start < programs[j].stop) {
                        const overlapMinutes = Math.floor((Math.min(programs[i].stop, programs[j].stop) - Math.max(programs[i].start, programs[j].start)) / 60000);
                        problems.push({
                            type: 'overlap',
                            severity: 'error',
                            message: `Sovrapposizione di ${overlapMinutes} minuti tra "${programs[i].title}" e "${programs[j].title}"`
                        });
                    }
                }
            }
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                const gap = sortedPrograms[i + 1].start - sortedPrograms[i].stop;
                if (gap > 60000) { // More than 1 minute
                    const gapMinutes = Math.floor(gap / 60000);
                    problems.push({
                        type: 'gap',
                        severity: gapMinutes > 30 ? 'error' : 'warning',
                        message: `Buco di ${gapMinutes} minuti dopo "${sortedPrograms[i].title}"`
                    });
                }
            }
            
            // Check total coverage
            const totalDuration = programs.reduce((sum, p) => sum + p.duration, 0);
            if (totalDuration < totalDaySeconds) {
                const missingHours = ((totalDaySeconds - totalDuration) / 3600).toFixed(1);
                problems.push({
                    type: 'coverage',
                    severity: 'info',
                    message: `Mancano ${missingHours} ore per completare le 24h`
                });
            }
            
            // Display problems
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600 font-semibold">‚úÖ Nessun problema rilevato</p>';
            } else {
                problems.forEach(problem => {
                    const div = document.createElement('div');
                    div.className = `p-3 rounded-lg text-sm ${
                        problem.severity === 'error' ? 'bg-red-50 text-red-700 border border-red-200' :
                        problem.severity === 'warning' ? 'bg-yellow-50 text-yellow-700 border border-yellow-200' :
                        'bg-blue-50 text-blue-700 border border-blue-200'
                    }`;
                    div.textContent = problem.message;
                    report.appendChild(div);
                });
            }
        }

        function getCurrentDayPrograms() {
            const dayStart = new Date(scheduleDate);
            dayStart.setUTCHours(21, 0, 0, 0);
            dayStart.setUTCDate(dayStart.getUTCDate() - 1);
            
            const dayEnd = new Date(scheduleDate);
            dayEnd.setUTCHours(21, 0, 0, 0);
            
            return currentPrograms.filter(p => {
                return (p.start >= dayStart && p.start < dayEnd) || 
                       (p.start < dayStart && p.stop > dayStart);
            }).sort((a, b) => a.start - b.start);
        }

        // Edit functions
        function editCell(cell, programIndex, field) {
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                program[field] = newValue;
                
                // Update XML
                const elem = program.element.querySelector(field);
                if (elem) {
                    elem.textContent = newValue;
                } else if (field === 'category' && newValue) {
                    const catElem = xmlDoc.createElement('category');
                    catElem.setAttribute('lang', 'it');
                    catElem.textContent = newValue;
                    program.element.appendChild(catElem);
                }
                
                // Reload if title changed
                if (field === 'title') {
                    if (!formatColors[newValue]) {
                        formatColors[newValue] = colorPalette[colorIndex % colorPalette.length];
                        colorIndex++;
                    }
                    loadPrograms();
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setUTCHours(hours, minutes, 0, 0);
            
            // Ensure stop time is after start time
            if (timeType === 'stop' && newDate <= program.start) {
                newDate.setUTCDate(newDate.getUTCDate() + 1);
            }
            
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            loadPrograms();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from global array
            const globalIndex = currentPrograms.indexOf(program);
            if (globalIndex > -1) {
                currentPrograms.splice(globalIndex, 1);
            }
            
            loadPrograms();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            const dayPrograms = getCurrentDayPrograms();
            const lastProgram = dayPrograms[dayPrograms.length - 1];
            
            let newStart;
            if (lastProgram) {
                newStart = new Date(lastProgram.stop);
            } else {
                newStart = new Date(scheduleDate);
                newStart.setUTCHours(6, 0, 0, 0);
            }
            
            const newStop = new Date(newStart);
            newStop.setUTCMinutes(newStop.getUTCMinutes() + 30);
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Add to programs array
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                duration: 1800,
                element: programme
            };
            
            currentPrograms.push(newProgram);
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            
            loadPrograms();
            showToast('Nuovo programma aggiunto', 'success');
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = scheduleDate.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDateStr = document.getElementById('newStartDate').value;
            const [year, month, day] = newStartDateStr.split('-').map(Number);
            const newStartDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
            
            const dayDiff = Math.floor((newStartDate - scheduleDate) / (1000 * 60 * 60 * 24));
            
            if (dayDiff === 0) {
                showToast('La data selezionata √® la stessa', 'info');
                closeActualizationDialog();
                return;
            }
            
            // Update all program dates
            currentPrograms.forEach(program => {
                const newStart = new Date(program.start);
                newStart.setUTCDate(newStart.getUTCDate() + dayDiff);
                const newStop = new Date(program.stop);
                newStop.setUTCDate(newStop.getUTCDate() + dayDiff);
                
                program.start = newStart;
                program.stop = newStop;
                
                program.element.setAttribute('start', formatXMLTVDate(newStart));
                program.element.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            xmlDoc.querySelector('tv').setAttribute('date', newStartDate.toISOString().split('T')[0]);
            
            // Update schedule date
            scheduleDate = newStartDate;
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
            
            // Reload programs
            loadPrograms();
            
            closeActualizationDialog();
            showToast('Date attualizzate con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlDoc);
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `${currentChannelId}_sequential_${date}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Utility functions
        function formatDateUTC(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTimeUTC(date) {
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}min`;
            } else {
                return `${minutes}min`;
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${type} min-w-[250px]`;
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <i data-lucide="${type === 'success' ? 'check-circle' : type === 'error' ? 'x-circle' : 'info'}" class="w-5 h-5"></i>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            container.appendChild(toast);
            
            // Re-initialize icons
            lucide.createIcons();
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            alert(`XMLTV Viewer v${APP_VERSION}\n\nTimeline Circolare Sequenziale\n\nNuove Funzionalit√† v3.0:\n- Timeline SOLO circolare\n- Visualizzazione sequenziale basata su durata (non su orario)\n- Il cerchio rappresenta 86.400 secondi (24 ore)\n- Statistiche complete: copertura, gaps, format unici\n- Supporto palinsesti TV con programmazione 21:00-20:59\n- Auto-rilevamento giorno principale\n- Editor programmi migliorato\n- Gestione gaps visuale\n\nModalit√† UTC - Nessuna conversione timezone\n\nSviluppato per Class CNBC e Class TV Moda`);
        }

        // Auto-update clock hands every minute
        setInterval(() => {
            const hands = document.getElementById('clockHands');
            if (hands && hands.children.length > 0) {
                const now = new Date();
                const currentHour = now.getUTCHours() + now.getUTCMinutes() / 60;
                const hourAngle = (currentHour * 15) - 90;
                const minuteAngle = ((now.getUTCMinutes() / 60) * 360) - 90;
                
                if (hands.children[0]) {
                    hands.children[0].setAttribute('x2', 350 + 120 * Math.cos(hourAngle * Math.PI / 180));
                    hands.children[0].setAttribute('y2', 350 + 120 * Math.sin(hourAngle * Math.PI / 180));
                }
                
                if (hands.children[1]) {
                    hands.children[1].setAttribute('x2', 350 + 160 * Math.cos(minuteAngle * Math.PI / 180));
                    hands.children[1].setAttribute('y2', 350 + 160 * Math.sin(minuteAngle * Math.PI / 180));
                }
            }
        }, 60000);

        // Initialize
        console.log('XMLTV Viewer v3.0 - Circular Sequential Timeline ready!');
    </script>
</body>
</html>
            
            
