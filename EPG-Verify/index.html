<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer & Editor Professional v1.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .timeline-container { overflow-x: auto; overflow-y: hidden; }
        .program-block { cursor: pointer; transition: all 0.2s; }
        .program-block:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .gap-indicator { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 10px, #dc2626 10px, #dc2626 20px); }
        .icon-preview { background-size: cover; background-position: center; }
        .toast { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
        .dark { background: #0f172a; color: #e2e8f0; }
        .dark .bg-white { background: #1e293b; }
        .dark .bg-gray-50 { background: #334155; }
        .dark .text-gray-900 { color: #e2e8f0; }
        .dark .text-gray-700 { color: #cbd5e1; }
        .dark .border-gray-200 { border-color: #475569; }
        input[type="datetime-local"] { color-scheme: light dark; }
        
        /* Fixed tooltip styles */
        .program-tooltip { 
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            transition: opacity 0.2s ease;
            opacity: 0;
        }
        .program-tooltip.visible {
            opacity: 1;
        }
        
        /* Prevent tooltip interference with SVG elements */
        .timeline-svg {
            position: relative;
            z-index: 1;
        }
        
        .editable-cell { cursor: text; }
        .editable-cell:hover { background: rgba(59, 130, 246, 0.1); }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-blue-600 flex items-center gap-2">
                        <i data-lucide="tv" class="w-8 h-8"></i>
                        XMLTV Viewer & Editor Pro
                    </h1>
                    <p class="text-gray-600 mt-1">Visualizza e modifica palinsesti TV - v1.3</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors" id="dropZone">
                <i data-lucide="upload" class="w-12 h-12 mx-auto text-gray-400 mb-4"></i>
                <p class="text-lg mb-2">Trascina qui il file XMLTV o clicca per selezionarlo</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Canale</h3>
                        <p class="text-xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Seleziona Giorno</h3>
                        <div class="flex items-center gap-2">
                            <button onclick="prevDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-left" class="w-5 h-5"></i>
                            </button>
                            <select id="daySelector" onchange="loadDay()" class="flex-1 px-3 py-2 border rounded">
                                <!-- Options populated dynamically -->
                            </select>
                            <button onclick="nextDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-right" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-1" id="timezoneInfo">Fuso orario: Europa/Roma (UTC+1/+2)</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Azioni</h3>
                        <div class="flex gap-2">
                            <button onclick="showActualizationDialog()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center gap-1">
                                <i data-lucide="calendar" class="w-4 h-4"></i>
                                Attualizza
                            </button>
                            <button onclick="exportXMLTV()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-1">
                                <i data-lucide="download" class="w-4 h-4"></i>
                                Esporta
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="clock" class="w-5 h-5"></i>
                    Timeline Giornaliera
                </h3>
                <div class="mb-2 flex items-center gap-4">
                    <button onclick="zoomIn()" class="p-2 hover:bg-gray-100 rounded" title="Zoom In">
                        <i data-lucide="zoom-in" class="w-5 h-5"></i>
                    </button>
                    <button onclick="zoomOut()" class="p-2 hover:bg-gray-100 rounded" title="Zoom Out">
                        <i data-lucide="zoom-out" class="w-5 h-5"></i>
                    </button>
                    <button onclick="resetZoom()" class="p-2 hover:bg-gray-100 rounded" title="Reset Zoom">
                        <i data-lucide="maximize-2" class="w-5 h-5"></i>
                    </button>
                    <span class="text-sm text-gray-600">Usa la rotella del mouse per zoom</span>
                </div>
                <div class="timeline-container border rounded-lg p-4" id="timelineContainer">
                    <svg id="timeline" class="timeline-svg" width="100%" height="150"></svg>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" id="programDetails" style="display:none;">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-5 h-5"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <p class="text-sm text-gray-600">Titolo</p>
                        <p class="font-semibold" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Format</p>
                        <p class="font-semibold" id="detailFormat">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Orario</p>
                        <p class="font-semibold" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Durata</p>
                        <p class="font-semibold" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Categoria</p>
                        <p class="font-semibold" id="detailCategory">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Rating</p>
                        <p class="font-semibold" id="detailRating">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="icon-preview w-32 h-18 border rounded" id="detailIcon"></div>
                            <p class="text-xs text-gray-500" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit" class="w-5 h-5"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 text-sm flex items-center gap-1">
                        <i data-lucide="plus" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left">Ora Inizio</th>
                                <th class="px-4 py-2 text-left">Ora Fine</th>
                                <th class="px-4 py-2 text-left">Durata</th>
                                <th class="px-4 py-2 text-left">Titolo/Format</th>
                                <th class="px-4 py-2 text-left">Categoria</th>
                                <th class="px-4 py-2 text-left">Icona</th>
                                <th class="px-4 py-2 text-left">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Analytics -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="pie-chart" class="w-5 h-5"></i>
                        Distribuzione Format
                    </h3>
                    <canvas id="formatChart" width="400" height="300"></canvas>
                </div>
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        Report Problemi
                    </h3>
                    <div id="problemsReport" class="space-y-2">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full">
                <h3 class="text-lg font-semibold mb-4">Attualizza Date Palinsesto</h3>
                <p class="text-sm text-gray-600 mb-4">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-3 py-2 border rounded mb-4">
                <div class="flex justify-end gap-2">
                    <button onclick="closeActualizationDialog()" class="px-4 py-2 border rounded hover:bg-gray-50">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

        <!-- Fixed Tooltip -->
        <div id="tooltip" class="program-tooltip bg-gray-900 text-white p-3 rounded shadow-lg text-sm"></div>
    </div>

    <script>
        // Version
        const APP_VERSION = '1.3';
        console.log(`XMLTV Viewer & Editor Pro v${APP_VERSION} - Fixed tooltip, improved timezone handling & performance`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let selectedDay = null;
        let zoomLevel = 1;
        let formatColors = {};
        let colorIndex = 0;
        let tooltipTimeout = null;

        // Performance optimization: cache parsed programs
        let programCache = new Map();
        let dayProgramsCache = new Map();

        // Format dictionaries
        const formatIcons = {
            'ClassCNBC': {
                "Trading Room": "trading-room.jpg",
                "Business Class": "business-class.jpg",
                "Mercati in 10 minuti": "mercati-10.jpg",
                "Class Meteo": "meteo.jpg",
                "Borse Oggi": "borse-oggi.jpg",
                "Apertura Mercati": "apertura-mercati.jpg",
                "Market Driver": "market-driver.jpg",
                "Wall Street": "wall-street.jpg",
                "Chiusura Mercati": "chiusura-mercati.jpg",
                "Business Talk": "business-talk.jpg",
                "Class Life": "class-life.jpg",
                "Report": "report.jpg",
                "Documentario": "documentario.jpg",
                "Programmazione notturna": "default.jpg"
            },
            'ClassTVModa': {
                "CATWALKS": "catwalks.jpg",
                "FASHION NEWS": "fashion-news.jpg",
                "FRONT ROW": "front-row.jpg",
                "SPOTLIGHT": "spotlight.jpg",
                "(UN)ACCESSING BACKSTAGE": "backstage.jpg",
                "CLASS TV MODA STORIES": "tv-moda-stories.jpg",
                "DESIGN MAP": "design-map.jpg",
                "DISTRICTS": "districts.jpg",
                "FASHION&BEYOND": "fashion-beyond.jpg",
                "GREEN REVOLUTION FORWARD": "green-revolution.jpg",
                "SOUND OF FASHION": "sound-of-fashion.jpg",
                "VOICES": "voices.jpg",
                "WHAT WOMEN WEAR": "what-women-wear.jpg",
                "Programmazione": "default.jpg"
            }
        };

        const iconBaseUrls = {
            'ClassCNBC': 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassCNBC_IT_samsung/Images/',
            'ClassTVModa': 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassTVModa_IT_samsung/Images/'
        };

        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];

        // Initialize Lucide icons
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    // Fallback to emoji
                    document.querySelectorAll('[data-lucide]').forEach(el => {
                        const iconMap = {
                            'tv': '📺',
                            'moon': '🌙',
                            'info': 'ℹ️',
                            'upload': '📤',
                            'chevron-left': '◀',
                            'chevron-right': '▶',
                            'calendar': '📅',
                            'download': '💾',
                            'clock': '🕐',
                            'zoom-in': '🔍+',
                            'zoom-out': '🔍-',
                            'maximize-2': '⛶',
                            'tv-2': '📺',
                            'edit': '✏️',
                            'plus': '➕',
                            'pie-chart': '📊',
                            'alert-triangle': '⚠️',
                            'trash-2': '🗑️'
                        };
                        const iconName = el.getAttribute('data-lucide');
                        el.textContent = iconMap[iconName] || '•';
                        el.style.fontStyle = 'normal';
                    });
                }
            }, 100);

            // Update timezone info
            updateTimezoneInfo();
        });

        // Update timezone information
        function updateTimezoneInfo() {
            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const now = new Date();
            const utcOffset = -now.getTimezoneOffset() / 60;
            const offsetStr = utcOffset >= 0 ? `+${utcOffset}` : `${utcOffset}`;
            document.getElementById('timezoneInfo').textContent = `Fuso orario: ${userTimezone} (UTC${offsetStr})`;
        }

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-blue-400', 'bg-blue-50');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.xml')) {
                loadFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadFile(file);
            }
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.querySelector('parsererror');
                    if (parserError) {
                        throw new Error('Errore nel parsing XML: ' + parserError.textContent);
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Clear caches
                    programCache.clear();
                    dayProgramsCache.clear();
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                    console.error('Load error:', error);
                }
            };
            reader.readAsText(file);
        }

        function parsePrograms() {
            const startTime = performance.now();
            
            const programmes = xmlDoc.querySelectorAll('programme');
            currentPrograms = [];
            const daysMap = new Map();
            
            programmes.forEach((prog, index) => {
                try {
                    const startStr = prog.getAttribute('start');
                    const stopStr = prog.getAttribute('stop');
                    
                    if (!startStr || !stopStr) {
                        console.warn(`Programma ${index} senza orari validi`);
                        return;
                    }
                    
                    const startUTC = parseXMLTVDate(startStr);
                    const stopUTC = parseXMLTVDate(stopStr);
                    
                    // Validate dates
                    if (!startUTC || !stopUTC || isNaN(startUTC.getTime()) || isNaN(stopUTC.getTime())) {
                        console.warn(`Programma ${index} con date non valide`);
                        return;
                    }
                    
                    // Debug first few programs
                    if (currentPrograms.length < 3) {
                        console.log(`Program ${index}:`, prog.querySelector('title')?.textContent);
                        console.log('  Start:', startStr, '→', startUTC.toString());
                        console.log('  Stop:', stopStr, '→', stopUTC.toString());
                    }
                    
                    const title = prog.querySelector('title')?.textContent || '';
                    const desc = prog.querySelector('desc')?.textContent || '';
                    const category = prog.querySelector('category')?.textContent || '';
                    const rating = prog.querySelector('rating value')?.textContent || '0';
                    const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                    const episodeNum = prog.querySelector('episode-num')?.textContent || '';
                    
                    const program = {
                        start: startUTC,
                        stop: stopUTC,
                        title,
                        desc,
                        category,
                        rating,
                        icon,
                        episodeNum,
                        duration: (stopUTC - startUTC) / 1000, // seconds
                        element: prog,
                        index: index
                    };
                    
                    currentPrograms.push(program);
                    
                    // Track days based on LOCAL time
                    const localStartDate = new Date(startUTC);
                    localStartDate.setHours(0, 0, 0, 0);
                    const dateKey = formatDateKey(localStartDate);
                    
                    if (!daysMap.has(dateKey)) {
                        daysMap.set(dateKey, localStartDate);
                    }
                    
                    // If program spans midnight, add the end day too
                    const localEndDate = new Date(stopUTC);
                    localEndDate.setHours(0, 0, 0, 0);
                    const endDateKey = formatDateKey(localEndDate);
                    
                    if (endDateKey !== dateKey && !daysMap.has(endDateKey)) {
                        daysMap.set(endDateKey, localEndDate);
                    }
                    
                    // Assign color to format
                    if (!formatColors[title]) {
                        formatColors[title] = colors[colorIndex % colors.length];
                        colorIndex++;
                    }
                } catch (err) {
                    console.error(`Errore parsing programma ${index}:`, err);
                }
            });
            
            // Populate day selector
            const daySelector = document.getElementById('daySelector');
            daySelector.innerHTML = '';
            
            // Sort days
            const sortedDays = Array.from(daysMap.entries())
                .sort((a, b) => a[1] - b[1]);
            
            console.log(`Parsed ${currentPrograms.length} programs in ${(performance.now() - startTime).toFixed(2)}ms`);
            console.log('Found days:', sortedDays.map(d => d[0]));
            
            sortedDays.forEach(([dateKey, date]) => {
                const option = document.createElement('option');
                option.value = dateKey;
                option.textContent = formatDate(date);
                daySelector.appendChild(option);
            });
            
            if (sortedDays.length > 0) {
                selectedDay = sortedDays[0][1];
                loadDay();
            }
        }

        function formatDateKey(date) {
            return date.toISOString().split('T')[0];
        }

        function parseXMLTVDate(dateStr) {
            // XMLTV format: YYYYMMDDHHmmss +/-HHMM
            // Extract components
            const year = parseInt(dateStr.substr(0, 4));
            const month = parseInt(dateStr.substr(4, 2)) - 1; // 0-based
            const day = parseInt(dateStr.substr(6, 2));
            const hour = parseInt(dateStr.substr(8, 2));
            const minute = parseInt(dateStr.substr(10, 2));
            const second = parseInt(dateStr.substr(12, 2));
            
            // Parse timezone offset
            let tzOffset = 0;
            if (dateStr.length > 14) {
                const tzSign = dateStr.charAt(15);
                if (tzSign === '+' || tzSign === '-') {
                    const tzHours = parseInt(dateStr.substr(16, 2)) || 0;
                    const tzMinutes = parseInt(dateStr.substr(18, 2)) || 0;
                    tzOffset = (tzHours * 60 + tzMinutes) * (tzSign === '-' ? -1 : 1);
                }
            }
            
            // Create date in UTC
            const utcDate = new Date(Date.UTC(year, month, day, hour, minute, second));
            
            // Adjust for timezone offset to get actual UTC time
            utcDate.setMinutes(utcDate.getMinutes() - tzOffset);
            
            return utcDate;
        }

        function formatXMLTVDate(date) {
            // Convert JavaScript Date to XMLTV format with UTC timezone
            const pad = (n) => String(n).padStart(2, '0');
            
            // Get UTC components
            const year = date.getUTCFullYear();
            const month = pad(date.getUTCMonth() + 1);
            const day = pad(date.getUTCDate());
            const hours = pad(date.getUTCHours());
            const minutes = pad(date.getUTCMinutes());
            const seconds = pad(date.getUTCSeconds());
            
            // Return with +0000 timezone (UTC)
            return `${year}${month}${day}${hours}${minutes}${seconds} +0000`;
        }

        function loadDay() {
            const startTime = performance.now();
            
            const dayValue = document.getElementById('daySelector').value;
            selectedDay = new Date(dayValue + 'T00:00:00');
            
            // Check cache first
            const cacheKey = dayValue;
            if (dayProgramsCache.has(cacheKey)) {
                const cachedPrograms = dayProgramsCache.get(cacheKey);
                console.log(`Loaded ${cachedPrograms.length} programs from cache in ${(performance.now() - startTime).toFixed(2)}ms`);
                
                drawTimeline(cachedPrograms);
                updateProgramTable(cachedPrograms);
                updateAnalytics(cachedPrograms);
                checkProblems(cachedPrograms);
                return;
            }
            
            // Set boundaries for the selected day in local time
            const startOfDay = new Date(selectedDay);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            console.log('Loading day:', formatDate(selectedDay));
            console.log('Day boundaries:', startOfDay.toISOString(), 'to', endOfDay.toISOString());
            
            // Filter programs that appear in this local day
            const dayPrograms = currentPrograms.filter(p => {
                // Program overlaps with this day if:
                // 1. It starts during this day
                const startsInDay = p.start >= startOfDay && p.start <= endOfDay;
                // 2. It ends during this day
                const endsInDay = p.stop >= startOfDay && p.stop <= endOfDay;
                // 3. It spans the entire day
                const spansDay = p.start < startOfDay && p.stop > endOfDay;
                
                return startsInDay || endsInDay || spansDay;
            });
            
            console.log(`Found ${dayPrograms.length} programs for ${formatDate(selectedDay)} in ${(performance.now() - startTime).toFixed(2)}ms`);
            
            // Sort by start time
            dayPrograms.sort((a, b) => a.start - b.start);
            
            // Cache the result
            dayProgramsCache.set(cacheKey, dayPrograms);
            
            // Draw timeline
            drawTimeline(dayPrograms);
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update analytics
            updateAnalytics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
        }

        function drawTimeline(programs) {
            const container = document.getElementById('timelineContainer');
            const svg = d3.select('#timeline');
            svg.selectAll('*').remove();
            
            const width = container.clientWidth * zoomLevel;
            const height = 150;
            const margin = { top: 20, right: 20, bottom: 30, left: 20 };
            
            svg.attr('width', width);
            
            // Time scale for the selected day in LOCAL time
            const startOfDay = new Date(selectedDay);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            const xScale = d3.scaleTime()
                .domain([startOfDay, endOfDay])
                .range([margin.left, width - margin.right]);
            
            // Draw time axis with local time
            const xAxis = d3.axisBottom(xScale)
                .ticks(d3.timeHour.every(zoomLevel > 2 ? 1 : 2))
                .tickFormat(d3.timeFormat('%H:%M'));
            
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(xAxis);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .ticks(d3.timeHour.every(zoomLevel > 2 ? 1 : 2))
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            // Draw programs
            const programHeight = 60;
            const programY = margin.top + 10;
            
            programs.forEach((program, index) => {
                // Clip program to day boundaries for display
                const programStart = program.start < startOfDay ? startOfDay : program.start;
                const programEnd = program.stop > endOfDay ? endOfDay : program.stop;
                
                const x = xScale(programStart);
                const width = Math.max(1, xScale(programEnd) - x); // Ensure minimum width
                
                const g = svg.append('g')
                    .attr('class', 'program-block')
                    .attr('transform', `translate(${x},${programY})`)
                    .style('cursor', 'pointer')
                    .on('click', () => showProgramDetails(program))
                    .on('mouseenter', function(event) { 
                        showTooltip(event, program); 
                    })
                    .on('mouseleave', function() { 
                        hideTooltip(); 
                    });
                
                // Program block
                g.append('rect')
                    .attr('width', width)
                    .attr('height', programHeight)
                    .attr('rx', 4)
                    .attr('fill', formatColors[program.title] || '#6B7280')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);
                
                // Add opacity if program extends beyond day boundaries
                if (program.start < startOfDay || program.stop > endOfDay) {
                    g.attr('opacity', 0.8);
                }
                
                // Program title (only if there's enough space)
                if (width > 40) {
                    g.append('text')
                        .attr('x', 5)
                        .attr('y', programHeight / 2)
                        .attr('dy', '.35em')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(program.title)
                        .each(function() {
                            const self = d3.select(this);
                            let textLength = self.node().getComputedTextLength();
                            let text = self.text();
                            while (textLength > width - 10 && text.length > 0) {
                                text = text.slice(0, -1);
                                self.text(text + '...');
                                textLength = self.node().getComputedTextLength();
                            }
                        });
                    
                    // Add time label if space permits
                    if (width > 80) {
                        g.append('text')
                            .attr('x', 5)
                            .attr('y', programHeight - 5)
                            .attr('fill', 'white')
                            .attr('font-size', '10px')
                            .text(`${formatTime(program.start)} - ${formatTime(program.stop)}`);
                    }
                }
                
                // Icon indicator if space permits
                if (program.icon && width > 60) {
                    const iconSize = 20;
                    g.append('rect')
                        .attr('x', width - iconSize - 5)
                        .attr('y', 5)
                        .attr('width', iconSize)
                        .attr('height', iconSize)
                        .attr('fill', 'white')
                        .attr('rx', 2);
                    
                    g.append('text')
                        .attr('x', width - iconSize/2 - 5)
                        .attr('y', 15)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '12px')
                        .text('📺');
                }
            });
            
            // Check for gaps
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                
                // Only check gaps within the same day
                if (current.stop < next.start && 
                    current.stop.toDateString() === next.start.toDateString()) {
                    
                    const gap = next.start - current.stop;
                    if (gap > 60000) { // More than 1 minute
                        const x = xScale(current.stop);
                        const width = xScale(next.start) - x;
                        
                        svg.append('rect')
                            .attr('x', x)
                            .attr('y', programY)
                            .attr('width', width)
                            .attr('height', programHeight)
                            .attr('class', 'gap-indicator')
                            .attr('opacity', 0.5);
                        
                        // Add gap duration text if space permits
                        if (width > 40) {
                            const gapMinutes = Math.floor(gap / 60000);
                            svg.append('text')
                                .attr('x', x + width/2)
                                .attr('y', programY + programHeight/2)
                                .attr('text-anchor', 'middle')
                                .attr('fill', 'white')
                                .attr('font-weight', 'bold')
                                .text(`GAP ${gapMinutes}min`);
                        }
                    }
                }
            }
        }

        // Fixed tooltip functions
        function showTooltip(event, program) {
            // Clear any existing timeout
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }
            
            const tooltip = document.getElementById('tooltip');
            
            // Set content
            tooltip.innerHTML = `
                <div class="font-semibold">${program.title}</div>
                <div class="text-xs">${formatTime(program.start)} - ${formatTime(program.stop)}</div>
                <div class="text-xs">Durata: ${formatDuration(program.duration)}</div>
                ${program.category ? `<div class="text-xs">Categoria: ${program.category}</div>` : ''}
                ${program.desc && program.desc.length < 100 ? `<div class="text-xs mt-1">${program.desc}</div>` : ''}
            `;
            
            // Position tooltip - use pageX/pageY for more stable positioning
            const tooltipRect = tooltip.getBoundingClientRect();
            const x = event.pageX;
            const y = event.pageY;
            
            // Calculate position to keep tooltip in viewport
            let left = x + 10;
            let top = y - tooltipRect.height - 10;
            
            // Adjust if tooltip would go off-screen
            if (left + 200 > window.innerWidth) {
                left = x - 210;
            }
            if (top < 10) {
                top = y + 20;
            }
            
            // Apply position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Show with slight delay to prevent flicker
            tooltipTimeout = setTimeout(() => {
                tooltip.classList.add('visible');
            }, 100);
        }

        function hideTooltip() {
            // Clear timeout
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            
            // Hide tooltip
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('visible');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailFormat').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTime(program.start)} - ${formatTime(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailRating').textContent = program.rating || '0';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            // Smooth scroll to details
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                
                row.innerHTML = `
                    <td class="px-4 py-2">
                        <input type="time" value="${program.start.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'})}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">
                        <input type="time" value="${program.stop.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'})}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-2">
                        <div class="w-16 h-9 bg-gray-200 rounded" 
                             style="background-image: url(${program.icon}); background-size: cover;">
                        </div>
                    </td>
                    <td class="px-4 py-2">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function updateAnalytics(programs) {
            // Format distribution chart
            const formatCounts = {};
            programs.forEach(p => {
                formatCounts[p.title] = (formatCounts[p.title] || 0) + p.duration;
            });
            
            const ctx = document.getElementById('formatChart').getContext('2d');
            
            // Destroy existing chart if any
            if (window.formatChart && typeof window.formatChart.destroy === 'function') {
                window.formatChart.destroy();
            }
            
            // Sort formats by duration for better visualization
            const sortedFormats = Object.entries(formatCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10); // Show top 10 formats
            
            window.formatChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: sortedFormats.map(f => f[0]),
                    datasets: [{
                        data: sortedFormats.map(f => f[1] / 3600), // Convert to hours
                        backgroundColor: sortedFormats.map(f => formatColors[f[0]] || '#6B7280')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: { size: 10 },
                                boxWidth: 12
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const hours = context.parsed.toFixed(1);
                                    const percentage = ((context.parsed / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
                                    return `${context.label}: ${hours}h (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for gaps
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                
                // Only check consecutive programs on the same day
                if (current.stop.toDateString() === next.start.toDateString()) {
                    const gap = next.start - current.stop;
                    if (gap > 60000) { // More than 1 minute
                        const gapMinutes = Math.floor(gap / 60000);
                        problems.push({
                            type: 'gap',
                            severity: gapMinutes > 30 ? 'error' : 'warning',
                            message: `Buco di ${gapMinutes} minuti tra "${current.title}" (${formatTime(current.stop)}) e "${next.title}" (${formatTime(next.start)})`
                        });
                    }
                }
            }
            
            // Check for overlaps
            for (let i = 0; i < programs.length - 1; i++) {
                if (programs[i].stop > programs[i + 1].start && 
                    programs[i].stop.toDateString() === programs[i + 1].start.toDateString()) {
                    const overlapMinutes = Math.floor((programs[i].stop - programs[i + 1].start) / 60000);
                    problems.push({
                        type: 'overlap',
                        severity: 'error',
                        message: `Sovrapposizione di ${overlapMinutes} minuti tra "${programs[i].title}" e "${programs[i + 1].title}"`
                    });
                }
            }
            
            // Check for missing icons
            const missingIconPrograms = programs.filter(p => !p.icon || p.icon.includes('placeholder'));
            if (missingIconPrograms.length > 0) {
                problems.push({
                    type: 'icon',
                    severity: 'warning',
                    message: `${missingIconPrograms.length} programmi senza icona: ${missingIconPrograms.slice(0, 3).map(p => p.title).join(', ')}${missingIconPrograms.length > 3 ? '...' : ''}`
                });
            }
            
            // Check for very short programs
            const shortPrograms = programs.filter(p => p.duration < 300); // Less than 5 minutes
            if (shortPrograms.length > 0) {
                problems.push({
                    type: 'duration',
                    severity: 'warning',
                    message: `${shortPrograms.length} programmi molto brevi (< 5 min)`
                });
            }
            
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600">✅ Nessun problema rilevato</p>';
            } else {
                // Sort problems by severity
                problems.sort((a, b) => {
                    if (a.severity === 'error' && b.severity !== 'error') return -1;
                    if (a.severity !== 'error' && b.severity === 'error') return 1;
                    return 0;
                });
                
                problems.forEach(p => {
                    const div = document.createElement('div');
                    div.className = `p-2 rounded text-sm ${p.severity === 'error' ? 'bg-red-50 text-red-700' : 'bg-yellow-50 text-yellow-700'}`;
                    div.innerHTML = `<span class="font-semibold">${p.severity === 'error' ? '❌' : '⚠️'}</span> ${p.message}`;
                    report.appendChild(div);
                });
            }
        }

        // Utility functions
        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTime(date) {
            return date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            loadDay();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
            loadDay();
        }

        function resetZoom() {
            zoomLevel = 1;
            loadDay();
        }

        // Mouse wheel zoom with debouncing
        let zoomTimeout;
        document.getElementById('timelineContainer').addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // Clear existing timeout
            if (zoomTimeout) clearTimeout(zoomTimeout);
            
            // Debounce zoom to improve performance
            zoomTimeout = setTimeout(() => {
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }, 50);
        });

        // Navigation functions
        function prevDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex > 0) {
                selector.selectedIndex--;
                loadDay();
            }
        }

        function nextDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex < selector.options.length - 1) {
                selector.selectedIndex++;
                loadDay();
            }
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = selectedDay.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDate = new Date(document.getElementById('newStartDate').value + 'T00:00:00');
            const oldStartDate = new Date(selectedDay);
            oldStartDate.setHours(0, 0, 0, 0);
            
            const dayDiff = Math.round((newStartDate - oldStartDate) / (1000 * 60 * 60 * 24));
            
            if (dayDiff === 0) {
                showToast('La data selezionata è la stessa', 'warning');
                return;
            }
            
            console.log(`Actualizing schedule by ${dayDiff} days`);
            
            // Create new XML document
            const newDoc = xmlDoc.cloneNode(true);
            
            // Update all program dates
            const programmes = newDoc.querySelectorAll('programme');
            programmes.forEach(prog => {
                const oldStart = parseXMLTVDate(prog.getAttribute('start'));
                const oldStop = parseXMLTVDate(prog.getAttribute('stop'));
                
                const newStart = new Date(oldStart);
                newStart.setDate(newStart.getDate() + dayDiff);
                const newStop = new Date(oldStop);
                newStop.setDate(newStop.getDate() + dayDiff);
                
                prog.setAttribute('start', formatXMLTVDate(newStart));
                prog.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            const tvElement = newDoc.querySelector('tv');
            if (tvElement) {
                tvElement.setAttribute('date', newStartDate.toISOString().split('T')[0]);
            }
            
            // Serialize and download
            const serializer = new XMLSerializer();
            let xmlString = serializer.serializeToString(newDoc);
            
            // Ensure proper XML declaration
            if (!xmlString.startsWith('<?xml')) {
                xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
            }
            
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentChannelId}_actualized_${newStartDate.toISOString().split('T')[0]}.xml`;
            a.click();
            
            URL.revokeObjectURL(url);
            closeActualizationDialog();
            showToast('File attualizzato scaricato con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            let xmlString = serializer.serializeToString(xmlDoc);
            
            // Ensure proper XML declaration
            if (!xmlString.startsWith('<?xml')) {
                xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
            }
            
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentChannelId}_edited_${new Date().toISOString().split('T')[0]}.xml`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Edit functions
        function editCell(cell, programIndex, field) {
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                // Get current day programs
                const dayPrograms = Array.from(dayProgramsCache.get(document.getElementById('daySelector').value) || []);
                
                const program = dayPrograms[programIndex];
                if (program) {
                    program[field] = newValue;
                    
                    // Update XML
                    if (field === 'title') {
                        const titleElem = program.element.querySelector('title');
                        if (titleElem) {
                            titleElem.textContent = newValue;
                        }
                    } else if (field === 'category') {
                        let catElem = program.element.querySelector('category');
                        if (catElem) {
                            catElem.textContent = newValue;
                        } else if (newValue) {
                            catElem = xmlDoc.createElement('category');
                            catElem.setAttribute('lang', 'it');
                            catElem.textContent = newValue;
                            program.element.appendChild(catElem);
                        }
                    }
                    
                    // Clear cache and reload if title changed (affects colors)
                    if (field === 'title') {
                        dayProgramsCache.clear();
                        loadDay();
                    }
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const dayPrograms = Array.from(dayProgramsCache.get(document.getElementById('daySelector').value) || []);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setHours(hours, minutes, 0, 0);
            
            // If end time is before start time, assume it's the next day
            if (timeType === 'stop' && newDate <= program.start) {
                newDate.setDate(newDate.getDate() + 1);
            }
            
            // Update program
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            // Clear cache and reload
            dayProgramsCache.clear();
            loadDay();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const dayPrograms = Array.from(dayProgramsCache.get(document.getElementById('daySelector').value) || []);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from global array
            const globalIndex = currentPrograms.findIndex(p => p.index === program.index);
            if (globalIndex !== -1) {
                currentPrograms.splice(globalIndex, 1);
            }
            
            // Clear cache and reload
            dayProgramsCache.clear();
            loadDay();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            // Get current day programs
            const dayPrograms = Array.from(dayProgramsCache.get(document.getElementById('daySelector').value) || [])
                .filter(p => p.start.toDateString() === selectedDay.toDateString());
            
            // Find last program of the day
            const lastProgram = dayPrograms[dayPrograms.length - 1];
            const newStart = lastProgram ? new Date(lastProgram.stop) : new Date(selectedDay);
            if (!lastProgram) {
                newStart.setHours(6, 0, 0, 0); // Default start at 6:00
            }
            
            const newStop = new Date(newStart);
            newStop.setMinutes(newStop.getMinutes() + 30); // Default 30 minutes duration
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            const rating = xmlDoc.createElement('rating');
            rating.setAttribute('system', 'Italy Parental Rating');
            const value = xmlDoc.createElement('value');
            value.textContent = '0';
            rating.appendChild(value);
            programme.appendChild(rating);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Create program object
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                episodeNum: '',
                duration: 1800,
                element: programme,
                index: currentPrograms.length
            };
            
            // Add to programs array
            currentPrograms.push(newProgram);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colors[colorIndex % colors.length];
                colorIndex++;
            }
            
            // Clear cache and reload
            dayProgramsCache.clear();
            loadDay();
            showToast('Nuovo programma aggiunto', 'success');
            
            // Scroll to the new program in the table
            setTimeout(() => {
                const table = document.getElementById('programTable');
                if (table.lastElementChild) {
                    table.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                setTimeout(() => lucide.createIcons(), 100);
            }
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const now = new Date();
            const utcOffset = -now.getTimezoneOffset() / 60;
            const offsetStr = utcOffset >= 0 ? `+${utcOffset}` : `${utcOffset}`;
            
            const infoText = `XMLTV Viewer & Editor Pro v${APP_VERSION}

Funzionalità:
• Visualizzazione timeline interattiva con zoom
• Conversione automatica UTC ↔ fuso orario locale
• Modifica programmi inline (click sulle celle)
• Attualizzazione date palinsesto
• Analisi e report problemi
• Export XMLTV con date UTC corrette

Miglioramenti v1.3:
• Tooltip stabile senza interferenze
• Gestione ottimizzata date UTC/locale
• Performance migliorate con caching
• Gestione errori migliorata

Fuso orario rilevato: ${userTimezone} (UTC${offsetStr})
Ora locale: ${now.toLocaleString('it-IT')}

Scorciatoie:
• Rotella mouse sulla timeline: Zoom
• Click su programma: Dettagli
• Click su celle tabella: Modifica

Sviluppato per Class CNBC e Class TV Moda`;
            
            alert(infoText);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    prevDay();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextDay();
                    break;
                case '+':
                case '=':
                    e.preventDefault();
                    zoomIn();
                    break;
                case '-':
                case '_':
                    e.preventDefault();
                    zoomOut();
                    break;
                case '0':
                    e.preventDefault();
                    resetZoom();
                    break;
                case 'a':
                case 'A':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        showActualizationDialog();
                    }
                    break;
                case 's':
                case 'S':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        exportXMLTV();
                    }
                    break;
            }
        });

        // Performance monitoring
        if (window.performance && window.performance.mark) {
            window.addEventListener('load', () => {
                console.log('Page load performance:', {
                    domComplete: performance.timing.domComplete - performance.timing.domLoading,
                    loadComplete: performance.timing.loadEventEnd - performance.timing.navigationStart
                });
            });
        }
    </script>
</body>
</html>
