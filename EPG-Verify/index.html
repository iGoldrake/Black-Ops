<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer v4.0.1 - Treemap Sequential Timeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* Treemap Timeline Styles */
        .treemap-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            aspect-ratio: 1;
            background: #f8fafc;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 
                inset 0 0 40px rgba(0, 0, 0, 0.05),
                0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .treemap-program {
            position: absolute;
            border: 2px solid white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .treemap-program:hover {
            transform: scale(1.05);
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .treemap-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        .treemap-label {
            position: relative;
            z-index: 2;
            color: white;
            font-weight: 600;
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: clamp(10px, 1.5vw, 14px);
            max-width: 90%;
            white-space: normal;
            word-wrap: break-word;
            backdrop-filter: blur(4px);
            line-height: 1.2;
        }

        .treemap-gap {
            position: absolute;
            background-image: repeating-linear-gradient(
                45deg,
                #ef4444,
                #ef4444 10px,
                transparent 10px,
                transparent 20px
            );
            opacity: 0.3;
            border: 2px dashed #dc2626;
            border-radius: 8px;
        }

        /* Program preview tooltip */
        .program-preview {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            backdrop-filter: blur(20px);
            color: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            max-width: 350px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .program-preview.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .preview-icon {
            width: 80px;
            height: 45px;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Statistics Cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
        }

        /* Coverage Ring */
        .coverage-ring {
            transform: rotate(-90deg);
            transition: stroke-dasharray 0.5s ease;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .treemap-program.new {
            animation: fadeIn 0.6s ease-out;
        }

        /* Dark mode support */
        .dark .treemap-container {
            background: #1e293b;
            box-shadow: 
                inset 0 0 40px rgba(0, 0, 0, 0.3),
                0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .dark .stat-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Toast improvements */
        .toast {
            animation: slideInRight 0.3s ease-out;
            backdrop-filter: blur(10px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #1e293b;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        .toast.success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.95) 100%);
            color: white;
        }

        .toast.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%);
            color: white;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        /* Gradient text */
        .gradient-text {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Format legend */
        .format-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
        }

        .format-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            background: white;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.2s;
        }

        .format-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .format-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Loading state */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Treemap layout algorithms */
        .layout-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .layout-btn {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            background: white;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layout-btn:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .layout-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        /* Fill percentage indicator */
        .fill-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            backdrop-filter: blur(8px);
            z-index: 10;
        }

        .fill-indicator.complete {
            background: rgba(34, 197, 94, 0.9);
        }

        .fill-indicator.warning {
            background: rgba(245, 158, 11, 0.9);
        }

        .fill-indicator.error {
            background: rgba(239, 68, 68, 0.9);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-4xl font-bold gradient-text flex items-center gap-3">
                        <i data-lucide="tv" class="w-10 h-10 text-blue-600"></i>
                        XMLTV Viewer v4.0.1
                    </h1>
                    <p class="text-gray-600 mt-2">Treemap Sequenziale - Modalit√† UTC</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Dark Mode">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Informazioni">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-8 mb-6 border border-white/50">
            <div class="border-3 border-dashed border-gray-300 rounded-xl p-12 text-center hover:border-blue-500 transition-all duration-300 hover:bg-blue-50/50" id="dropZone">
                <i data-lucide="upload-cloud" class="w-16 h-16 mx-auto text-gray-400 mb-4"></i>
                <p class="text-xl mb-2 font-semibold text-gray-700">Trascina qui il file XMLTV</p>
                <p class="text-gray-500 mb-4">oppure</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-8 py-3 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Stats -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="tv-2" class="w-4 h-4"></i>
                            Canale
                        </h3>
                        <p class="text-2xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="calendar" class="w-4 h-4"></i>
                            Data Palinsesto
                        </h3>
                        <p class="text-2xl font-bold" id="scheduleDate">-</p>
                        <p class="text-sm text-gray-600">
                            <span id="programCount">-</span> programmi
                        </p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="pie-chart" class="w-4 h-4"></i>
                            Copertura
                        </h3>
                        <div class="flex items-center gap-3">
                            <svg width="50" height="50" viewBox="0 0 50 50">
                                <circle cx="25" cy="25" r="20" fill="none" stroke="#e5e7eb" stroke-width="8"/>
                                <circle cx="25" cy="25" r="20" fill="none" stroke="url(#coverageGradient)" stroke-width="8" 
                                    stroke-dasharray="126" stroke-dashoffset="126" class="coverage-ring" id="coverageRing"/>
                                <defs>
                                    <linearGradient id="coverageGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#3b82f6"/>
                                        <stop offset="100%" style="stop-color:#8b5cf6"/>
                                    </linearGradient>
                                </defs>
                            </svg>
                            <div>
                                <p class="text-2xl font-bold" id="coveragePercent">0%</p>
                                <p class="text-sm text-gray-600" id="coverageTime">0h 0m</p>
                            </div>
                        </div>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-700 mb-1 flex items-center gap-2">
                            <i data-lucide="activity" class="w-4 h-4"></i>
                            Statistiche
                        </h3>
                        <div class="space-y-1">
                            <p class="text-sm"><span class="font-semibold" id="gapCount">0</span> gaps</p>
                            <p class="text-sm"><span class="font-semibold" id="formatCount">0</span> format unici</p>
                            <p class="text-sm"><span class="font-semibold" id="avgDuration">0m</span> durata media</p>
                        </div>
                    </div>
                </div>
                
                <!-- Actions -->
                <div class="flex justify-center gap-3 mt-6">
                    <button onclick="showActualizationDialog()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-6 py-2.5 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="calendar-days" class="w-4 h-4"></i>
                        Attualizza Date
                    </button>
                    <button onclick="exportXMLTV()" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        Esporta XMLTV
                    </button>
                </div>
            </div>

            <!-- Treemap Timeline -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="grid-3x3" class="w-6 h-6 text-blue-600"></i>
                        Treemap Aggregato per Format
                    </span>
                    <div class="layout-selector">
                        <span class="text-sm font-normal text-gray-600 mr-3">Layout:</span>
                        <button class="layout-btn active" onclick="setLayout('squarify')" data-layout="squarify">Squarify</button>
                        <button class="layout-btn" onclick="setLayout('binary')" data-layout="binary">Binary</button>
                        <button class="layout-btn" onclick="setLayout('slice')" data-layout="slice">Slice & Dice</button>
                    </div>
                </h3>
                
                <div class="treemap-container" id="treemapContainer">
                    <div class="fill-indicator" id="fillIndicator">
                        <span id="fillPercent">0%</span> riempito
                    </div>
                    <!-- Treemap elements will be added here -->
                </div>
                
                <!-- Format Legend -->
                <div class="mt-6">
                    <h4 class="font-semibold text-gray-700 mb-2">Riepilogo Format</h4>
                    <div class="format-legend" id="formatLegend">
                        <!-- Format items will be added here -->
                    </div>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50" id="programDetails" style="display:none;">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-6 h-6 text-blue-600"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Titolo/Format</p>
                        <p class="font-semibold text-lg" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Orario UTC</p>
                        <p class="font-semibold text-lg" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Durata</p>
                        <p class="font-semibold text-lg" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600 mb-1">Categoria</p>
                        <p class="font-semibold text-lg" id="detailCategory">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600 mb-1">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600 mb-1">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="w-32 h-18 bg-gray-200 rounded-lg overflow-hidden" id="detailIcon" style="background-size: cover; background-position: center;"></div>
                            <p class="text-xs text-gray-500 break-all" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit-3" class="w-6 h-6 text-blue-600"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 py-2 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 text-sm flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="plus-circle" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto rounded-lg border border-gray-200">
                    <table class="w-full text-sm">
                        <thead class="bg-gradient-to-r from-gray-50 to-gray-100">
                            <tr>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Ora Inizio UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Ora Fine UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Durata</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Titolo/Format</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Categoria</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable" class="divide-y divide-gray-200">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Problems Report -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="alert-triangle" class="w-6 h-6 text-orange-600"></i>
                    Report Problemi
                </h3>
                <div id="problemsReport" class="space-y-2">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-2xl p-8 max-w-md w-full shadow-2xl transform transition-all">
                <h3 class="text-2xl font-bold mb-4 gradient-text">Attualizza Date Palinsesto</h3>
                <p class="text-gray-600 mb-6">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none transition-colors">
                <div class="flex justify-end gap-3 mt-6">
                    <button onclick="closeActualizationDialog()" class="px-6 py-2.5 border-2 border-gray-300 rounded-lg hover:bg-gray-50 transition-colors font-semibold">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-3"></div>

        <!-- Program Preview -->
        <div id="programPreview" class="program-preview">
            <div class="preview-icon" id="previewIcon"></div>
            <h4 class="font-bold text-xl mb-3" id="previewTitle"></h4>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                    <span class="text-gray-400">Orario UTC:</span>
                    <span class="font-semibold" id="previewTime"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Durata:</span>
                    <span class="font-semibold" id="previewDuration"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Categoria:</span>
                    <span class="font-semibold" id="previewCategory"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Posizione:</span>
                    <span class="font-semibold" id="previewPosition"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Area:</span>
                    <span class="font-semibold" id="previewArea"></span>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-4 italic" id="previewDesc"></p>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        window.addEventListener('DOMContentLoaded', function() {
            lucide.createIcons();
        });

        // Version
        const APP_VERSION = '4.0.1';
        console.log(`XMLTV Viewer v${APP_VERSION} - Treemap Sequential Timeline`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let scheduleDate = null;
        let formatColors = {};
        let colorIndex = 0;
        let currentPreviewTimeout = null;
        let totalDaySeconds = 86400; // 24 hours in seconds
        let currentLayout = 'squarify'; // Layout algorithm

        // Modern color palette
        const colorPalette = [
            '#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', 
            '#10b981', '#06b6d4', '#6366f1', '#f43f5e',
            '#84cc16', '#a855f7', '#0ea5e9', '#f97316',
            '#14b8a6', '#d946ef', '#0891b2', '#dc2626'
        ];

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('border-blue-500', 'bg-blue-50');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            }, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const files = e.dataTransfer.files;
            handleFiles(files);
        }

        fileInput.addEventListener('change', function(e) {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/xml' || file.type === 'application/xml' || file.name.endsWith('.xml')) {
                    loadFile(file);
                } else {
                    showToast('Seleziona un file XML valido', 'error');
                }
            }
        }

        function loadFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.getElementsByTagName('parsererror');
                    if (parserError.length > 0) {
                        throw new Error('Errore nel parsing XML');
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            currentPrograms = [];
            
            programmes.forEach((prog) => {
                const startStr = prog.getAttribute('start');
                const stopStr = prog.getAttribute('stop');
                
                if (!startStr || !stopStr) return;
                
                const startUTC = parseXMLTVDateUTC(startStr);
                const stopUTC = parseXMLTVDateUTC(stopStr);
                
                const title = prog.querySelector('title')?.textContent || '';
                const desc = prog.querySelector('desc')?.textContent || '';
                const category = prog.querySelector('category')?.textContent || '';
                const ratingValue = prog.querySelector('rating value');
                const rating = ratingValue ? ratingValue.textContent : '0';
                const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                
                const program = {
                    start: startUTC,
                    stop: stopUTC,
                    title,
                    desc,
                    category,
                    rating,
                    icon,
                    duration: (stopUTC - startUTC) / 1000, // seconds
                    element: prog
                };
                
                currentPrograms.push(program);
                
                // Assign color to format
                if (!formatColors[title]) {
                    formatColors[title] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
            });
            
            if (currentPrograms.length === 0) {
                showToast('Nessun programma trovato nel file', 'error');
                return;
            }
            
            // Sort programs by start time
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Auto-detect the main programming day
            detectMainProgrammingDay();
            
            // Load programs
            loadPrograms();
        }

        function detectMainProgrammingDay() {
            // Count programs per day
            const programsByDay = {};
            
            currentPrograms.forEach(program => {
                const dayKey = program.start.toISOString().split('T')[0];
                if (!programsByDay[dayKey]) {
                    programsByDay[dayKey] = [];
                }
                programsByDay[dayKey].push(program);
            });
            
            // Find the day with most programs
            let maxPrograms = 0;
            let bestDay = null;
            
            Object.entries(programsByDay).forEach(([day, programs]) => {
                if (programs.length > maxPrograms) {
                    maxPrograms = programs.length;
                    bestDay = day;
                }
            });
            
            // Set schedule date
            if (bestDay) {
                const [year, month, day] = bestDay.split('-').map(Number);
                scheduleDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
            } else {
                scheduleDate = new Date(currentPrograms[0].start);
                scheduleDate.setUTCHours(0, 0, 0, 0);
            }
            
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
        }

        function parseXMLTVDateUTC(dateStr) {
            // Check if it's ISO 8601 format (contains 'T')
            if (dateStr.includes('T')) {
                // ISO 8601 format: 2025-06-09T21:00:00+0000
                // Remove timezone info and parse as UTC
                const cleanDate = dateStr.replace(/[+-]\d{4}$/, '');
                const [datePart, timePart] = cleanDate.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, minute, second] = timePart.split(':').map(Number);
                
                return new Date(Date.UTC(year, month - 1, day, hour, minute, second || 0));
            } else {
                // Classic XMLTV format: YYYYMMDDHHmmss +0000
                const year = parseInt(dateStr.substr(0, 4));
                const month = parseInt(dateStr.substr(4, 2)) - 1;
                const day = parseInt(dateStr.substr(6, 2));
                const hour = parseInt(dateStr.substr(8, 2));
                const minute = parseInt(dateStr.substr(10, 2));
                const second = parseInt(dateStr.substr(12, 2));
                
                return new Date(Date.UTC(year, month, day, hour, minute, second));
            }
        }

        function formatXMLTVDate(date) {
            // Use ISO 8601 format for better compatibility
            const pad = (n) => String(n).padStart(2, '0');
            const year = date.getUTCFullYear();
            const month = pad(date.getUTCMonth() + 1);
            const day = pad(date.getUTCDate());
            const hours = pad(date.getUTCHours());
            const minutes = pad(date.getUTCMinutes());
            const seconds = pad(date.getUTCSeconds());
            
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+0000`;
        }

        // Add global variable to store format groups
        let formatGroups = {};

        function loadPrograms() {
            // Get programs for the schedule day (including evening programs from previous day)
            const dayStart = new Date(scheduleDate);
            dayStart.setUTCHours(21, 0, 0, 0); // Start from 21:00 previous day
            dayStart.setUTCDate(dayStart.getUTCDate() - 1);
            
            const dayEnd = new Date(scheduleDate);
            dayEnd.setUTCHours(21, 0, 0, 0); // End at 21:00 current day
            
            const dayPrograms = currentPrograms.filter(p => {
                return (p.start >= dayStart && p.start < dayEnd) || 
                       (p.start < dayStart && p.stop > dayStart);
            }).sort((a, b) => a.start - b.start);
            
            document.getElementById('programCount').textContent = dayPrograms.length;
            
            // Draw treemap
            drawTreemap(dayPrograms);
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update statistics
            updateStatistics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
            
            // Update format legend
            updateFormatLegend(dayPrograms);
        }

        function drawTreemap(programs) {
            const container = document.getElementById('treemapContainer');
            
            // Clear existing content (except fill indicator)
            const fillIndicator = document.getElementById('fillIndicator');
            container.innerHTML = '';
            container.appendChild(fillIndicator);
            
            const containerWidth = 800;
            const containerHeight = 800;
            
            // Group programs by format and calculate total duration per format
            formatGroups = {};
            let totalUsedSeconds = 0;
            
            programs.forEach((program) => {
                const format = program.title;
                if (!formatGroups[format]) {
                    formatGroups[format] = {
                        title: format,
                        programs: [],
                        totalDuration: 0,
                        icon: program.icon,
                        category: program.category,
                        color: formatColors[format]
                    };
                }
                
                formatGroups[format].programs.push(program);
                formatGroups[format].totalDuration += program.duration;
                totalUsedSeconds += program.duration;
                
                // Use the first icon found for this format
                if (!formatGroups[format].icon && program.icon) {
                    formatGroups[format].icon = program.icon;
                }
            });
            
            // Convert to array and prepare for treemap
            const formatNodes = Object.values(formatGroups).map(group => ({
                ...group,
                value: group.totalDuration,
                programCount: group.programs.length
            }));
            
            // Sort by duration (largest first)
            formatNodes.sort((a, b) => b.value - a.value);
            
            // Update fill indicator
            const fillPercent = (totalUsedSeconds / totalDaySeconds) * 100;
            document.getElementById('fillPercent').textContent = `${fillPercent.toFixed(1)}%`;
            
            if (fillPercent >= 100) {
                fillIndicator.className = 'fill-indicator complete';
            } else if (fillPercent >= 80) {
                fillIndicator.className = 'fill-indicator warning';
            } else {
                fillIndicator.className = 'fill-indicator error';
            }
            
            // Calculate treemap layout
            const root = {
                x0: 0,
                y0: 0,
                x1: containerWidth,
                y1: containerHeight,
                value: totalDaySeconds,
                children: formatNodes
            };
            
            // Apply treemap algorithm
            if (currentLayout === 'squarify') {
                squarify(root.children, root, totalDaySeconds);
            } else if (currentLayout === 'binary') {
                binary(root.children, root, totalDaySeconds);
            } else if (currentLayout === 'slice') {
                sliceDice(root.children, root, totalDaySeconds);
            }
            
            // Draw format blocks
            formatNodes.forEach((formatNode) => {
                const div = document.createElement('div');
                div.className = 'treemap-program new';
                
                const width = formatNode.x1 - formatNode.x0;
                const height = formatNode.y1 - formatNode.y0;
                
                div.style.left = `${formatNode.x0}px`;
                div.style.top = `${formatNode.y0}px`;
                div.style.width = `${width}px`;
                div.style.height = `${height}px`;
                div.style.backgroundColor = formatNode.color;
                
                // Add icon if available and space allows
                if (formatNode.icon && width > 60 && height > 60) {
                    const img = document.createElement('img');
                    img.src = formatNode.icon;
                    img.className = 'treemap-icon';
                    img.onerror = function() {
                        this.style.display = 'none';
                    };
                    div.appendChild(img);
                }
                
                // Add enhanced label
                if (width > 50 && height > 40) {
                    const label = document.createElement('div');
                    label.className = 'treemap-label';
                    label.style.fontSize = Math.min(16, width / 10) + 'px';
                    
                    // Multi-line label with format name and stats
                    const durationHours = (formatNode.totalDuration / 3600).toFixed(1);
                    const percentage = ((formatNode.totalDuration / totalDaySeconds) * 100).toFixed(1);
                    
                    label.innerHTML = `
                        <div style="font-weight: 700;">${formatNode.title}</div>
                        ${height > 60 ? `<div style="font-size: 0.8em; margin-top: 4px;">${formatNode.programCount} episodi</div>` : ''}
                        ${height > 80 ? `<div style="font-size: 0.8em;">${durationHours}h (${percentage}%)</div>` : ''}
                    `;
                    
                    div.appendChild(label);
                }
                
                // Event handlers - show aggregated format info
                div.onclick = () => showFormatDetails(formatNode);
                div.onmouseenter = (e) => showFormatPreview(e, formatNode, width * height);
                div.onmouseleave = hideProgramPreview;
                
                container.appendChild(div);
            });
            
            // Draw gap area if any
            if (totalUsedSeconds < totalDaySeconds) {
                const gapValue = totalDaySeconds - totalUsedSeconds;
                const gapArea = (gapValue / totalDaySeconds) * containerWidth * containerHeight;
                
                // Simple placement for gap - fill remaining space
                const div = document.createElement('div');
                div.className = 'treemap-gap';
                
                // Calculate gap dimensions based on remaining area
                const gapWidth = Math.sqrt(gapArea);
                const gapHeight = gapArea / gapWidth;
                
                div.style.right = '0';
                div.style.bottom = '0';
                div.style.width = `${gapWidth}px`;
                div.style.height = `${gapHeight}px`;
                
                const gapHours = (gapValue / 3600).toFixed(1);
                const gapPercent = ((gapValue / totalDaySeconds) * 100).toFixed(1);
                
                // Add gap label if space allows
                if (gapWidth > 80 && gapHeight > 60) {
                    const gapLabel = document.createElement('div');
                    gapLabel.className = 'treemap-label';
                    gapLabel.style.background = 'rgba(220, 38, 38, 0.8)';
                    gapLabel.innerHTML = `
                        <div style="font-weight: 700;">VUOTO</div>
                        <div style="font-size: 0.8em; margin-top: 4px;">${gapHours}h (${gapPercent}%)</div>
                    `;
                    div.appendChild(gapLabel);
                }
                
                container.appendChild(div);
            }
        }

        // Treemap layout algorithms
        function squarify(children, parent, totalValue) {
            const area = (parent.x1 - parent.x0) * (parent.y1 - parent.y0);
            
            children.forEach((child) => {
                const childArea = (child.value / totalValue) * area;
                child.area = childArea;
            });
            
            squarifyRecursive(children, parent.x0, parent.y0, parent.x1, parent.y1);
        }

        function squarifyRecursive(children, x0, y0, x1, y1) {
            if (children.length === 0) return;
            
            const totalArea = (x1 - x0) * (y1 - y0);
            const totalValue = children.reduce((sum, child) => sum + child.area, 0);
            
            if (children.length === 1) {
                const child = children[0];
                child.x0 = x0;
                child.y0 = y0;
                child.x1 = x1;
                child.y1 = y1;
                return;
            }
            
            const width = x1 - x0;
            const height = y1 - y0;
            const vertical = width <= height;
            
            let accumulatedArea = 0;
            let i = 0;
            
            while (i < children.length) {
                const child = children[i];
                accumulatedArea += child.area;
                
                const ratio = accumulatedArea / totalArea;
                
                if (vertical) {
                    const splitY = y0 + ratio * height;
                    
                    if (i === children.length - 1 || wouldImproveRatio(children, i + 1, width, splitY - y0)) {
                        // Place children 0 to i
                        layoutRow(children.slice(0, i + 1), x0, y0, x1, splitY, true);
                        
                        // Recursively layout remaining children
                        if (i < children.length - 1) {
                            squarifyRecursive(children.slice(i + 1), x0, splitY, x1, y1);
                        }
                        break;
                    }
                } else {
                    const splitX = x0 + ratio * width;
                    
                    if (i === children.length - 1 || wouldImproveRatio(children, i + 1, splitX - x0, height)) {
                        // Place children 0 to i
                        layoutRow(children.slice(0, i + 1), x0, y0, splitX, y1, false);
                        
                        // Recursively layout remaining children
                        if (i < children.length - 1) {
                            squarifyRecursive(children.slice(i + 1), splitX, y0, x1, y1);
                        }
                        break;
                    }
                }
                
                i++;
            }
        }

        function wouldImproveRatio(children, nextIndex, width, height) {
            if (nextIndex >= children.length) return false;
            
            const currentRatio = Math.max(width / height, height / width);
            const nextArea = children[nextIndex].area;
            const newHeight = height * (1 + nextArea / (width * height));
            const newRatio = Math.max(width / newHeight, newHeight / width);
            
            return newRatio < currentRatio;
        }

        function layoutRow(children, x0, y0, x1, y1, vertical) {
            const totalArea = children.reduce((sum, child) => sum + child.area, 0);
            
            if (vertical) {
                const width = x1 - x0;
                let currentX = x0;
                
                children.forEach(child => {
                    const childWidth = (child.area / totalArea) * width;
                    child.x0 = currentX;
                    child.y0 = y0;
                    child.x1 = currentX + childWidth;
                    child.y1 = y1;
                    currentX += childWidth;
                });
            } else {
                const height = y1 - y0;
                let currentY = y0;
                
                children.forEach(child => {
                    const childHeight = (child.area / totalArea) * height;
                    child.x0 = x0;
                    child.y0 = currentY;
                    child.x1 = x1;
                    child.y1 = currentY + childHeight;
                    currentY += childHeight;
                });
            }
        }

        function binary(children, parent, totalValue) {
            binaryRecursive(children, parent.x0, parent.y0, parent.x1, parent.y1, totalValue);
        }

        function binaryRecursive(children, x0, y0, x1, y1, totalValue) {
            if (children.length === 0) return;
            
            if (children.length === 1) {
                const child = children[0];
                child.x0 = x0;
                child.y0 = y0;
                child.x1 = x1;
                child.y1 = y1;
                return;
            }
            
            const mid = Math.floor(children.length / 2);
            const leftChildren = children.slice(0, mid);
            const rightChildren = children.slice(mid);
            
            const leftValue = leftChildren.reduce((sum, child) => sum + child.value, 0);
            const rightValue = rightChildren.reduce((sum, child) => sum + child.value, 0);
            
            const width = x1 - x0;
            const height = y1 - y0;
            
            if (width > height) {
                // Split vertically
                const splitX = x0 + (leftValue / totalValue) * width;
                binaryRecursive(leftChildren, x0, y0, splitX, y1, leftValue);
                binaryRecursive(rightChildren, splitX, y0, x1, y1, rightValue);
            } else {
                // Split horizontally
                const splitY = y0 + (leftValue / totalValue) * height;
                binaryRecursive(leftChildren, x0, y0, x1, splitY, leftValue);
                binaryRecursive(rightChildren, x0, splitY, x1, y1, rightValue);
            }
        }

        function sliceDice(children, parent, totalValue) {
            const width = parent.x1 - parent.x0;
            const height = parent.y1 - parent.y0;
            const area = width * height;
            
            let currentX = parent.x0;
            let currentY = parent.y0;
            let rowHeight = 0;
            let rowChildren = [];
            let rowValue = 0;
            
            children.forEach((child, index) => {
                const childArea = (child.value / totalValue) * area;
                const childWidth = Math.sqrt(childArea);
                
                if (currentX + childWidth > parent.x1 && rowChildren.length > 0) {
                    // Layout current row
                    layoutRowSlice(rowChildren, parent.x0, currentY, parent.x1, currentY + rowHeight);
                    
                    // Start new row
                    currentY += rowHeight;
                    currentX = parent.x0;
                    rowHeight = 0;
                    rowChildren = [];
                    rowValue = 0;
                }
                
                rowChildren.push(child);
                rowValue += child.value;
                rowHeight = Math.max(rowHeight, childArea / childWidth);
                currentX += childWidth;
            });
            
            // Layout last row
            if (rowChildren.length > 0) {
                layoutRowSlice(rowChildren, parent.x0, currentY, parent.x1, Math.min(parent.y1, currentY + rowHeight));
            }
        }

        function layoutRowSlice(children, x0, y0, x1, y1) {
            const totalValue = children.reduce((sum, child) => sum + child.value, 0);
            const width = x1 - x0;
            let currentX = x0;
            
            children.forEach(child => {
                const childWidth = (child.value / totalValue) * width;
                child.x0 = currentX;
                child.y0 = y0;
                child.x1 = Math.min(currentX + childWidth, x1);
                child.y1 = y1;
                currentX += childWidth;
            });
        }

        function setLayout(layout) {
            currentLayout = layout;
            
            // Update UI
            document.querySelectorAll('.layout-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-layout="${layout}"]`).classList.add('active');
            
            // Redraw
            if (currentPrograms.length > 0) {
                loadPrograms();
            }
            
            showToast(`Layout cambiato in ${layout}`, 'success');
        }

        function updateStatistics(programs) {
            // Calculate total coverage
            const totalDuration = programs.reduce((sum, p) => sum + p.duration, 0);
            const coveragePercent = Math.min(100, (totalDuration / totalDaySeconds) * 100);
            const coverageHours = Math.floor(totalDuration / 3600);
            const coverageMinutes = Math.floor((totalDuration % 3600) / 60);
            
            document.getElementById('coveragePercent').textContent = `${coveragePercent.toFixed(1)}%`;
            document.getElementById('coverageTime').textContent = `${coverageHours}h ${coverageMinutes}m`;
            
            // Update coverage ring
            const ring = document.getElementById('coverageRing');
            const circumference = 2 * Math.PI * 20;
            const offset = circumference - (coveragePercent / 100) * circumference;
            ring.style.strokeDashoffset = offset;
            
            // Count gaps
            let gapCount = 0;
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                if (sortedPrograms[i + 1].start > sortedPrograms[i].stop) {
                    gapCount++;
                }
            }
            document.getElementById('gapCount').textContent = gapCount;
            
            // Count unique formats
            const uniqueFormats = [...new Set(programs.map(p => p.title))];
            document.getElementById('formatCount').textContent = uniqueFormats.length;
            
            // Calculate average duration
            const avgDuration = totalDuration / programs.length;
            const avgMinutes = Math.floor(avgDuration / 60);
            document.getElementById('avgDuration').textContent = `${avgMinutes}m`;
        }

        function updateFormatLegend(programs) {
            const legend = document.getElementById('formatLegend');
            legend.innerHTML = '';
            
            // Usa i format groups se disponibili
            if (Object.keys(formatGroups).length > 0) {
                const sortedFormats = Object.values(formatGroups)
                    .sort((a, b) => b.totalDuration - a.totalDuration);
                
                sortedFormats.forEach(format => {
                    const item = document.createElement('div');
                    item.className = 'format-item';
                    const hours = (format.totalDuration / 3600).toFixed(1);
                    const percentage = ((format.totalDuration / totalDaySeconds) * 100).toFixed(1);
                    
                    item.innerHTML = `
                        <div class="format-color" style="background: ${format.color}"></div>
                        <span>${format.title}</span>
                        <span style="margin-left: auto; font-size: 11px; color: #666;">
                            ${format.programCount} ep. ‚Ä¢ ${hours}h ‚Ä¢ ${percentage}%
                        </span>
                    `;
                    legend.appendChild(item);
                });
            } else {
                // Fallback alla vecchia versione
                const formats = [...new Set(programs.map(p => p.title))];
                formats.forEach(format => {
                    const item = document.createElement('div');
                    item.className = 'format-item';
                    item.innerHTML = `
                        <div class="format-color" style="background: ${formatColors[format]}"></div>
                        <span>${format}</span>
                    `;
                    legend.appendChild(item);
                });
            }
        }

        function showFormatDetails(formatNode) {
            const detailsDiv = document.getElementById('programDetails');
            detailsDiv.style.display = 'block';
            
            // Mostra informazioni aggregate del format
            document.getElementById('detailTitle').textContent = formatNode.title;
            
            // Calcola orari di inizio e fine del format
            const sortedPrograms = formatNode.programs.sort((a, b) => a.start - b.start);
            const firstProgram = sortedPrograms[0];
            const lastProgram = sortedPrograms[sortedPrograms.length - 1];
            
            document.getElementById('detailTime').textContent = `Prima: ${formatTimeUTC(firstProgram.start)} - Ultima: ${formatTimeUTC(lastProgram.stop)}`;
            document.getElementById('detailDuration').textContent = `${(formatNode.totalDuration / 3600).toFixed(1)} ore totali (${formatNode.programCount} episodi)`;
            document.getElementById('detailCategory').textContent = formatNode.category || '-';
            
            // Lista tutti gli episodi
            const episodesList = sortedPrograms.map(p => 
                `‚Ä¢ ${formatTimeUTC(p.start)} - ${formatTimeUTC(p.stop)} (${formatDuration(p.duration)})`
            ).join('\n');
            
            document.getElementById('detailDescription').textContent = `Episodi:\n${episodesList}`;
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (formatNode.icon) {
                iconDiv.style.backgroundImage = `url(${formatNode.icon})`;
                iconUrl.textContent = formatNode.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            detailsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function showFormatPreview(event, formatNode, area) {
            if (currentPreviewTimeout) {
                clearTimeout(currentPreviewTimeout);
            }
            
            currentPreviewTimeout = setTimeout(() => {
                const preview = document.getElementById('programPreview');
                
                document.getElementById('previewTitle').textContent = formatNode.title;
                
                // Mostra info aggregate
                const durationHours = (formatNode.totalDuration / 3600).toFixed(1);
                const percentage = ((formatNode.totalDuration / totalDaySeconds) * 100).toFixed(1);
                
                document.getElementById('previewTime').textContent = `${formatNode.programCount} episodi`;
                document.getElementById('previewDuration').textContent = `${durationHours} ore totali`;
                document.getElementById('previewCategory').textContent = formatNode.category || 'N/A';
                
                // Show format rank by duration
                const allFormats = Object.keys(formatGroups).length;
                const sortedFormats = Object.values(formatGroups)
                    .sort((a, b) => b.totalDuration - a.totalDuration);
                const formatRank = sortedFormats.findIndex(f => f.title === formatNode.title) + 1;
                
                document.getElementById('previewPosition').textContent = `${formatRank}¬∞ su ${allFormats} format`;
                
                // Show area percentage
                const totalArea = 800 * 800;
                const areaPercent = (area / totalArea) * 100;
                document.getElementById('previewArea').textContent = `${percentage}% del tempo`;
                
                // Show time slots
                const timeSlots = formatNode.programs
                    .sort((a, b) => a.start - b.start)
                    .slice(0, 3)
                    .map(p => formatTimeUTC(p.start))
                    .join(', ');
                
                document.getElementById('previewDesc').textContent = `Orari: ${timeSlots}${formatNode.programs.length > 3 ? '...' : ''}`;
                
                const iconDiv = document.getElementById('previewIcon');
                if (formatNode.icon) {
                    iconDiv.style.backgroundImage = `url(${formatNode.icon})`;
                    iconDiv.style.display = 'block';
                } else {
                    iconDiv.style.display = 'none';
                }
                
                // Position preview
                const rect = event.target.getBoundingClientRect();
                let top = rect.bottom + 10;
                let left = rect.left + rect.width / 2 - 175;
                
                if (left < 10) left = 10;
                if (left + 350 > window.innerWidth) left = window.innerWidth - 360;
                if (top + 300 > window.innerHeight) {
                    top = rect.top - 300 - 10;
                }
                
                preview.style.left = left + 'px';
                preview.style.top = top + 'px';
                preview.classList.add('show');
            }, 300);
        }

        function hideProgramPreview() {
            if (currentPreviewTimeout) {
                clearTimeout(currentPreviewTimeout);
                currentPreviewTimeout = null;
            }
            document.getElementById('programPreview').classList.remove('show');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTimeUTC(program.start)} - ${formatTimeUTC(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                
                const startTimeStr = `${program.start.getUTCHours().toString().padStart(2, '0')}:${program.start.getUTCMinutes().toString().padStart(2, '0')}`;
                const stopTimeStr = `${program.stop.getUTCHours().toString().padStart(2, '0')}:${program.stop.getUTCMinutes().toString().padStart(2, '0')}`;
                
                row.innerHTML = `
                    <td class="px-4 py-3">
                        <input type="time" value="${startTimeStr}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none">
                    </td>
                    <td class="px-4 py-3">
                        <input type="time" value="${stopTimeStr}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none">
                    </td>
                    <td class="px-4 py-3">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-3 cursor-pointer hover:bg-blue-50 rounded transition-colors" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-3 cursor-pointer hover:bg-blue-50 rounded transition-colors" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-3">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700 transition-colors p-2 hover:bg-red-50 rounded-lg" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            lucide.createIcons();
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for overlaps
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    if (programs[i].stop > programs[j].start && programs[i].start < programs[j].stop) {
                        const overlapMinutes = Math.floor((Math.min(programs[i].stop, programs[j].stop) - Math.max(programs[i].start, programs[j].start)) / 60000);
                        problems.push({
                            type: 'overlap',
                            severity: 'error',
                            message: `Sovrapposizione di ${overlapMinutes} minuti tra "${programs[i].title}" e "${programs[j].title}"`
                        });
                    }
                }
            }
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                const gap = sortedPrograms[i + 1].start - sortedPrograms[i].stop;
                if (gap > 60000) { // More than 1 minute
                    const gapMinutes = Math.floor(gap / 60000);
                    problems.push({
                        type: 'gap',
                        severity: gapMinutes > 30 ? 'error' : 'warning',
                        message: `Buco di ${gapMinutes} minuti dopo "${sortedPrograms[i].title}"`
                    });
                }
            }
            
            // Check total coverage
            const totalDuration = programs.reduce((sum, p) => sum + p.duration, 0);
            if (totalDuration < totalDaySeconds) {
                const missingHours = ((totalDaySeconds - totalDuration) / 3600).toFixed(1);
                problems.push({
                    type: 'coverage',
                    severity: 'info',
                    message: `Mancano ${missingHours} ore per completare le 24h`
                });
            }
            
            // Display problems
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600 font-semibold">‚úÖ Nessun problema rilevato</p>';
            } else {
                problems.forEach(problem => {
                    const div = document.createElement('div');
                    div.className = `p-3 rounded-lg text-sm ${
                        problem.severity === 'error' ? 'bg-red-50 text-red-700 border border-red-200' :
                        problem.severity === 'warning' ? 'bg-yellow-50 text-yellow-700 border border-yellow-200' :
                        'bg-blue-50 text-blue-700 border border-blue-200'
                    }`;
                    div.textContent = problem.message;
                    report.appendChild(div);
                });
            }
        }

        function getCurrentDayPrograms() {
            const dayStart = new Date(scheduleDate);
            dayStart.setUTCHours(21, 0, 0, 0);
            dayStart.setUTCDate(dayStart.getUTCDate() - 1);
            
            const dayEnd = new Date(scheduleDate);
            dayEnd.setUTCHours(21, 0, 0, 0);
            
            return currentPrograms.filter(p => {
                return (p.start >= dayStart && p.start < dayEnd) || 
                       (p.start < dayStart && p.stop > dayStart);
            }).sort((a, b) => a.start - b.start);
        }

        // Edit functions
        function editCell(cell, programIndex, field) {
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded-lg focus:border-blue-500 focus:outline-none';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                program[field] = newValue;
                
                // Update XML
                const elem = program.element.querySelector(field);
                if (elem) {
                    elem.textContent = newValue;
                } else if (field === 'category' && newValue) {
                    const catElem = xmlDoc.createElement('category');
                    catElem.setAttribute('lang', 'it');
                    catElem.textContent = newValue;
                    program.element.appendChild(catElem);
                }
                
                // Reload if title changed
                if (field === 'title') {
                    if (!formatColors[newValue]) {
                        formatColors[newValue] = colorPalette[colorIndex % colorPalette.length];
                        colorIndex++;
                    }
                    loadPrograms();
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setUTCHours(hours, minutes, 0, 0);
            
            // Ensure stop time is after start time
            if (timeType === 'stop' && newDate <= program.start) {
                newDate.setUTCDate(newDate.getUTCDate() + 1);
            }
            
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            loadPrograms();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const dayPrograms = getCurrentDayPrograms();
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from global array
            const globalIndex = currentPrograms.indexOf(program);
            if (globalIndex > -1) {
                currentPrograms.splice(globalIndex, 1);
            }
            
            loadPrograms();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            const dayPrograms = getCurrentDayPrograms();
            const lastProgram = dayPrograms[dayPrograms.length - 1];
            
            let newStart;
            if (lastProgram) {
                newStart = new Date(lastProgram.stop);
            } else {
                newStart = new Date(scheduleDate);
                newStart.setUTCHours(6, 0, 0, 0);
            }
            
            const newStop = new Date(newStart);
            newStop.setUTCMinutes(newStop.getUTCMinutes() + 30);
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Add to programs array
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                duration: 1800,
                element: programme
            };
            
            currentPrograms.push(newProgram);
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            
            loadPrograms();
            showToast('Nuovo programma aggiunto', 'success');
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = scheduleDate.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDateStr = document.getElementById('newStartDate').value;
            const [year, month, day] = newStartDateStr.split('-').map(Number);
            const newStartDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
            
            const dayDiff = Math.floor((newStartDate - scheduleDate) / (1000 * 60 * 60 * 24));
            
            if (dayDiff === 0) {
                showToast('La data selezionata √® la stessa', 'info');
                closeActualizationDialog();
                return;
            }
            
            // Update all program dates
            currentPrograms.forEach(program => {
                const newStart = new Date(program.start);
                newStart.setUTCDate(newStart.getUTCDate() + dayDiff);
                const newStop = new Date(program.stop);
                newStop.setUTCDate(newStop.getUTCDate() + dayDiff);
                
                program.start = newStart;
                program.stop = newStop;
                
                program.element.setAttribute('start', formatXMLTVDate(newStart));
                program.element.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            xmlDoc.querySelector('tv').setAttribute('date', newStartDate.toISOString().split('T')[0]);
            
            // Update schedule date
            scheduleDate = newStartDate;
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
            
            // Reload programs
            loadPrograms();
            
            closeActualizationDialog();
            showToast('Date attualizzate con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlDoc);
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `${currentChannelId}_treemap_${date}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Utility functions
        function formatDateUTC(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTimeUTC(date) {
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}min`;
            } else {
                return `${minutes}min`;
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${type} min-w-[250px]`;
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <i data-lucide="${type === 'success' ? 'check-circle' : type === 'error' ? 'x-circle' : 'info'}" class="w-5 h-5"></i>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            container.appendChild(toast);
            
            // Re-initialize icons
            lucide.createIcons();
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            alert(`XMLTV Viewer v${APP_VERSION}\n\nTreemap Aggregato per Format\n\nNuove Funzionalit√† v4.0.1:\n- Fix calcolo posizione format nel preview\n\nFunzionalit√† v4.0:\n- Visualizzazione TREEMAP AGGREGATA: ogni format ha un unico rettangolo\n- L'area di ogni rettangolo √® proporzionale al tempo totale del format\n- Mostra numero episodi, ore totali e percentuale per format\n- Icone format visibili nei rettangoli (quando disponibili)\n- 3 algoritmi di layout: Squarify, Binary, Slice & Dice\n- Indicatore di riempimento con codice colore\n- Gap visualizzati con pattern rosso tratteggiato\n- Click su un format mostra tutti gli episodi\n\nModalit√† UTC - Nessuna conversione timezone\n\nSviluppato per Class CNBC e Class TV Moda`);
        }

        // Initialize
        console.log('XMLTV Viewer v4.0.1 - Treemap Sequential Timeline ready!');
    </script>
</body>
</html>
