<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer & Editor Professional v1.5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .timeline-container { overflow-x: auto; overflow-y: hidden; }
        .program-block { cursor: pointer; transition: all 0.2s; }
        .program-block:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .gap-indicator { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 10px, #dc2626 10px, #dc2626 20px); }
        .icon-preview { background-size: cover; background-position: center; }
        .toast { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
        .dark { background: #0f172a; color: #e2e8f0; }
        .dark .bg-white { background: #1e293b; }
        .dark .bg-gray-50 { background: #334155; }
        .dark .text-gray-900 { color: #e2e8f0; }
        .dark .text-gray-700 { color: #cbd5e1; }
        .dark .border-gray-200 { border-color: #475569; }
        input[type="datetime-local"] { color-scheme: light dark; }
        .editable-cell { cursor: text; }
        .editable-cell:hover { background: rgba(59, 130, 246, 0.1); }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-blue-600 flex items-center gap-2">
                        <i data-lucide="tv" class="w-8 h-8"></i>
                        XMLTV Viewer & Editor Pro
                    </h1>
                    <p class="text-gray-600 mt-1">Visualizza e modifica palinsesti TV - v1.5</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors" id="dropZone">
                <i data-lucide="upload" class="w-12 h-12 mx-auto text-gray-400 mb-4"></i>
                <p class="text-lg mb-2">Trascina qui il file XMLTV o clicca per selezionarlo</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Canale</h3>
                        <p class="text-xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Seleziona Giorno</h3>
                        <div class="flex items-center gap-2">
                            <button onclick="prevDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-left" class="w-5 h-5"></i>
                            </button>
                            <select id="daySelector" onchange="loadDay()" class="flex-1 px-3 py-2 border rounded">
                                <!-- Options populated dynamically -->
                            </select>
                            <button onclick="nextDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-right" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Fuso orario: Europa/Roma (UTC+1/+2)</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Azioni</h3>
                        <div class="flex gap-2">
                            <button onclick="showActualizationDialog()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center gap-1">
                                <i data-lucide="calendar" class="w-4 h-4"></i>
                                Attualizza
                            </button>
                            <button onclick="exportXMLTV()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-1">
                                <i data-lucide="download" class="w-4 h-4"></i>
                                Esporta
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="clock" class="w-5 h-5"></i>
                    Timeline Giornaliera
                </h3>
                <div class="mb-2 flex items-center gap-4">
                    <button onclick="zoomIn()" class="p-2 hover:bg-gray-100 rounded" title="Zoom In">
                        <i data-lucide="zoom-in" class="w-5 h-5"></i>
                    </button>
                    <button onclick="zoomOut()" class="p-2 hover:bg-gray-100 rounded" title="Zoom Out">
                        <i data-lucide="zoom-out" class="w-5 h-5"></i>
                    </button>
                    <button onclick="resetZoom()" class="p-2 hover:bg-gray-100 rounded" title="Reset Zoom">
                        <i data-lucide="maximize-2" class="w-5 h-5"></i>
                    </button>
                    <span class="text-sm text-gray-600">Usa la rotella del mouse per zoom</span>
                </div>
                <div class="timeline-container border rounded-lg p-4" id="timelineContainer">
                    <svg id="timeline" width="100%" height="150"></svg>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" id="programDetails" style="display:none;">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-5 h-5"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <p class="text-sm text-gray-600">Titolo</p>
                        <p class="font-semibold" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Format</p>
                        <p class="font-semibold" id="detailFormat">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Orario</p>
                        <p class="font-semibold" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Durata</p>
                        <p class="font-semibold" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Categoria</p>
                        <p class="font-semibold" id="detailCategory">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Rating</p>
                        <p class="font-semibold" id="detailRating">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="icon-preview w-32 h-18 border rounded" id="detailIcon"></div>
                            <p class="text-xs text-gray-500" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit" class="w-5 h-5"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 text-sm flex items-center gap-1">
                        <i data-lucide="plus" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left">Ora Inizio</th>
                                <th class="px-4 py-2 text-left">Ora Fine</th>
                                <th class="px-4 py-2 text-left">Durata</th>
                                <th class="px-4 py-2 text-left">Titolo/Format</th>
                                <th class="px-4 py-2 text-left">Categoria</th>
                                <th class="px-4 py-2 text-left">Icona</th>
                                <th class="px-4 py-2 text-left">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Analytics -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="pie-chart" class="w-5 h-5"></i>
                        Distribuzione Format
                    </h3>
                    <canvas id="formatChart" width="400" height="300"></canvas>
                </div>
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        Report Problemi
                    </h3>
                    <div id="problemsReport" class="space-y-2">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full">
                <h3 class="text-lg font-semibold mb-4">Attualizza Date Palinsesto</h3>
                <p class="text-sm text-gray-600 mb-4">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-3 py-2 border rounded mb-4">
                <div class="flex justify-end gap-2">
                    <button onclick="closeActualizationDialog()" class="px-4 py-2 border rounded hover:bg-gray-50">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

        <!-- Tooltip - Fixed positioning -->
        <div id="tooltip" class="fixed bg-gray-900 text-white p-3 rounded shadow-lg text-sm hidden" style="z-index: 9999; pointer-events: none;"></div>
    </div>

    <script>
        // Initialize Lucide icons after DOM is loaded
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    // Fallback to emoji if Lucide doesn't load
                    console.warn('Lucide not loaded, using emoji fallbacks');
                    document.querySelectorAll('[data-lucide]').forEach(el => {
                        const iconMap = {
                            'tv': '📺',
                            'moon': '🌙',
                            'info': 'ℹ️',
                            'upload': '📤',
                            'chevron-left': '◀',
                            'chevron-right': '▶',
                            'calendar': '📅',
                            'download': '💾',
                            'clock': '🕐',
                            'zoom-in': '🔍+',
                            'zoom-out': '🔍-',
                            'maximize-2': '⛶',
                            'tv-2': '📺',
                            'edit': '✏️',
                            'plus': '➕',
                            'pie-chart': '📊',
                            'alert-triangle': '⚠️',
                            'trash-2': '🗑️'
                        };
                        const iconName = el.getAttribute('data-lucide');
                        el.textContent = iconMap[iconName] || '•';
                        el.style.fontStyle = 'normal';
                    });
                }
            }, 100);
        });

        // Version
        const APP_VERSION = '1.5';
        console.log(`XMLTV Viewer & Editor Pro v${APP_VERSION} - Fixed file loading and date handling`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let selectedDay = null;
        let zoomLevel = 1;
        let formatColors = {};
        let colorIndex = 0;

        // Color palette
        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];

        // File handling - FIXED VERSION
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            dropZone.classList.add('border-blue-400', 'bg-blue-50');
        }

        function unhighlight(e) {
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
        }

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        // Handle file input change
        fileInput.addEventListener('change', function(e) {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/xml' || file.type === 'application/xml' || file.name.endsWith('.xml')) {
                    loadFile(file);
                } else {
                    showToast('Seleziona un file XML valido', 'error');
                }
            }
        }

        function loadFile(file) {
            console.log('Loading file:', file.name);
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const xmlContent = e.target.result;
                    console.log('File content loaded, length:', xmlContent.length);
                    
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.getElementsByTagName('parsererror');
                    if (parserError.length > 0) {
                        throw new Error('Errore nel parsing XML: ' + parserError[0].textContent);
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    console.log('Channel found:', currentChannelName, '(ID:', currentChannelId, ')');
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            
            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                showToast('Errore nella lettura del file', 'error');
            };
            
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            console.log('Found programmes:', programmes.length);
            
            currentPrograms = [];
            const daysMap = new Map();
            
            programmes.forEach((prog, index) => {
                try {
                    const startStr = prog.getAttribute('start');
                    const stopStr = prog.getAttribute('stop');
                    
                    if (!startStr || !stopStr) {
                        console.warn(`Programme ${index} missing start or stop time`);
                        return;
                    }
                    
                    const startUTC = parseXMLTVDate(startStr);
                    const stopUTC = parseXMLTVDate(stopStr);
                    
                    // Debug first few programs
                    if (index < 3) {
                        console.log(`Program ${index}:`, prog.querySelector('title')?.textContent);
                        console.log('  Start string:', startStr);
                        console.log('  Start UTC:', startUTC.toISOString());
                        console.log('  Start Local:', startUTC.toString());
                        console.log('  Stop string:', stopStr);
                        console.log('  Stop UTC:', stopUTC.toISOString());
                        console.log('  Stop Local:', stopUTC.toString());
                    }
                    
                    const title = prog.querySelector('title')?.textContent || '';
                    const desc = prog.querySelector('desc')?.textContent || '';
                    const category = prog.querySelector('category')?.textContent || '';
                    const ratingValue = prog.querySelector('rating value');
                    const rating = ratingValue ? ratingValue.textContent : '0';
                    const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                    const episodeNum = prog.querySelector('episode-num')?.textContent || '';
                    
                    const program = {
                        start: startUTC,
                        stop: stopUTC,
                        title,
                        desc,
                        category,
                        rating,
                        icon,
                        episodeNum,
                        duration: (stopUTC - startUTC) / 1000, // seconds
                        element: prog
                    };
                    
                    currentPrograms.push(program);
                    
                    // Add all days where this program appears
                    const startDate = new Date(startUTC);
                    const endDate = new Date(stopUTC);
                    
                    // Normalize to midnight for date tracking
                    const currentDate = new Date(startDate);
                    currentDate.setHours(0, 0, 0, 0);
                    
                    while (currentDate <= endDate) {
                        const dateKey = currentDate.toISOString().split('T')[0];
                        if (!daysMap.has(dateKey)) {
                            daysMap.set(dateKey, new Date(currentDate));
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    // Assign color to format
                    if (!formatColors[title]) {
                        formatColors[title] = colors[colorIndex % colors.length];
                        colorIndex++;
                    }
                } catch (error) {
                    console.error(`Error parsing programme ${index}:`, error);
                }
            });
            
            console.log('Parsed programs:', currentPrograms.length);
            console.log('Found days:', Array.from(daysMap.keys()));
            
            // Populate day selector
            const daySelector = document.getElementById('daySelector');
            daySelector.innerHTML = '';
            
            // Sort days
            const sortedDays = Array.from(daysMap.entries())
                .sort((a, b) => a[1] - b[1]);
            
            sortedDays.forEach(([dateKey, date]) => {
                const option = document.createElement('option');
                option.value = dateKey;
                
                // Count programs for this day
                const dayStart = new Date(date);
                dayStart.setHours(0, 0, 0, 0);
                const dayEnd = new Date(date);
                dayEnd.setHours(23, 59, 59, 999);
                
                const programCount = currentPrograms.filter(p => {
                    return (p.start < dayEnd && p.stop > dayStart);
                }).length;
                
                option.textContent = `${formatDate(date)} (${programCount} programmi)`;
                daySelector.appendChild(option);
            });
            
            if (sortedDays.length > 0) {
                // Select the first day with programs
                selectedDay = sortedDays[0][1];
                daySelector.selectedIndex = 0;
                loadDay();
            } else {
                showToast('Nessun programma trovato nel file', 'error');
            }
        }

        function parseXMLTVDate(dateStr) {
            // XMLTV format: YYYYMMDDHHmmss +0000
            // Extract components
            const year = parseInt(dateStr.substr(0, 4));
            const month = parseInt(dateStr.substr(4, 2)) - 1; // JavaScript months are 0-based
            const day = parseInt(dateStr.substr(6, 2));
            const hour = parseInt(dateStr.substr(8, 2));
            const minute = parseInt(dateStr.substr(10, 2));
            const second = parseInt(dateStr.substr(12, 2));
            
            // Create UTC date
            const utcDate = new Date(Date.UTC(year, month, day, hour, minute, second));
            
            // Return date object (will be automatically converted to local timezone by JavaScript)
            return utcDate;
        }

        function formatXMLTVDate(date) {
            // Convert local date to UTC for XML format
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getUTCFullYear()}${pad(date.getUTCMonth() + 1)}${pad(date.getUTCDate())}` +
                   `${pad(date.getUTCHours())}${pad(date.getUTCMinutes())}${pad(date.getUTCSeconds())} +0000`;
        }

        function loadDay() {
            const dayValue = document.getElementById('daySelector').value;
            if (!dayValue) return;
            
            console.log('Loading day:', dayValue);
            
            // Create date at midnight local time
            const [year, month, day] = dayValue.split('-').map(Number);
            selectedDay = new Date(year, month - 1, day, 0, 0, 0, 0);
            
            // Set boundaries for the selected day
            const startOfDay = new Date(selectedDay);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            console.log('Day boundaries:', startOfDay.toString(), 'to', endOfDay.toString());
            
            // Filter programs that appear in this day
            const dayPrograms = currentPrograms.filter(p => {
                return p.start < endOfDay && p.stop > startOfDay;
            });
            
            console.log(`Found ${dayPrograms.length} programs for ${formatDate(selectedDay)}`);
            
            // Sort by start time
            dayPrograms.sort((a, b) => a.start - b.start);
            
            // Draw timeline
            try {
                drawTimeline(dayPrograms);
            } catch (err) {
                console.error('Error in drawTimeline:', err);
                showToast('Errore nella visualizzazione timeline: ' + err.message, 'error');
            }
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update analytics
            updateAnalytics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
        }

        function drawTimeline(programs) {
            const container = document.getElementById('timelineContainer');
            const svg = d3.select('#timeline');
            svg.selectAll('*').remove();
            
            const width = container.clientWidth * zoomLevel;
            const height = 150;
            const margin = { top: 20, right: 20, bottom: 30, left: 20 };
            
            svg.attr('width', width).attr('height', height);
            
            // Time scale for the selected day in LOCAL time
            const startOfDay = new Date(selectedDay);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            const xScale = d3.scaleTime()
                .domain([startOfDay, endOfDay])
                .range([margin.left, width - margin.right]);
            
            // Draw time axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(d3.timeHour.every(zoomLevel > 2 ? 1 : 2))
                .tickFormat(d3.timeFormat('%H:%M'));
            
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(xAxis);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .ticks(d3.timeHour.every(1))
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            // Group overlapping programs into rows
            const rows = [];
            programs.forEach(program => {
                let placed = false;
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    const row = rows[rowIndex];
                    const fits = !row.some(p => 
                        (program.start < p.stop && program.stop > p.start)
                    );
                    if (fits) {
                        row.push(program);
                        placed = true;
                        program.row = rowIndex;
                        break;
                    }
                }
                if (!placed) {
                    rows.push([program]);
                    program.row = rows.length - 1;
                }
            });
            
            // Adjust SVG height based on number of rows
            const programHeight = 40;
            const rowGap = 5;
            const neededHeight = Math.max(150, margin.top + margin.bottom + (rows.length * (programHeight + rowGap)) + 20);
            svg.attr('height', neededHeight);
            
            // Re-draw axis at new position
            svg.select('g').remove();
            svg.append('g')
                .attr('transform', `translate(0,${neededHeight - margin.bottom})`)
                .call(xAxis);
            
            // Draw programs
            const baseY = margin.top + 10;
            
            programs.forEach((program, index) => {
                // Clip program to day boundaries
                const programStart = program.start < startOfDay ? startOfDay : program.start;
                const programEnd = program.stop > endOfDay ? endOfDay : program.stop;
                
                const x = xScale(programStart);
                const width = Math.max(1, xScale(programEnd) - x);
                const y = baseY + (program.row || 0) * (programHeight + rowGap);
                
                const g = svg.append('g')
                    .attr('class', 'program-block')
                    .attr('transform', `translate(${x},${y})`)
                    .style('cursor', 'pointer')
                    .on('click', () => showProgramDetails(program))
                    .on('mouseenter', (event) => showTooltip(event, program))
                    .on('mouseleave', hideTooltip);
                
                // Check for overlaps
                const hasOverlap = programs.some((p, i) => 
                    i !== index && p.start < program.stop && p.stop > program.start
                );
                
                // Program block
                g.append('rect')
                    .attr('width', width)
                    .attr('height', programHeight)
                    .attr('rx', 4)
                    .attr('fill', formatColors[program.title] || '#6B7280')
                    .attr('stroke', hasOverlap ? '#ff0000' : '#fff')
                    .attr('stroke-width', hasOverlap ? 3 : 1);
                
                // Add opacity if program extends beyond day boundaries
                if (program.start < startOfDay || program.stop > endOfDay) {
                    g.attr('opacity', 0.8);
                }
                
                // Program title
                if (width > 30) {
                    g.append('text')
                        .attr('x', 5)
                        .attr('y', programHeight / 2 - 5)
                        .attr('dy', '.35em')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(program.title)
                        .each(function() {
                            const self = d3.select(this);
                            let textLength = self.node().getComputedTextLength();
                            let text = self.text();
                            while (textLength > width - 10 && text.length > 0) {
                                text = text.slice(0, -1);
                                self.text(text + '...');
                                textLength = self.node().getComputedTextLength();
                            }
                        });
                    
                    // Add time label
                    if (width > 60) {
                        g.append('text')
                            .attr('x', 5)
                            .attr('y', programHeight - 5)
                            .attr('fill', 'white')
                            .attr('font-size', '10px')
                            .text(`${formatTime(program.start)} - ${formatTime(program.stop)}`);
                    }
                }
                
                // Warning icon for overlaps
                if (hasOverlap && width > 20) {
                    g.append('text')
                        .attr('x', width - 15)
                        .attr('y', programHeight / 2)
                        .attr('dy', '.35em')
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '14px')
                        .text('⚠️');
                }
            });
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            let lastEnd = null;
            
            sortedPrograms.forEach(program => {
                if (lastEnd && program.start > lastEnd) {
                    const gap = program.start - lastEnd;
                    if (gap > 60000) { // More than 1 minute
                        const x = xScale(lastEnd);
                        const width = xScale(program.start) - x;
                        
                        svg.append('rect')
                            .attr('x', x)
                            .attr('y', baseY)
                            .attr('width', width)
                            .attr('height', programHeight)
                            .attr('class', 'gap-indicator')
                            .attr('opacity', 0.5);
                        
                        // Add gap duration text
                        const gapMinutes = Math.floor(gap / 60000);
                        if (width > 40) {
                            svg.append('text')
                                .attr('x', x + width/2)
                                .attr('y', baseY + programHeight/2)
                                .attr('text-anchor', 'middle')
                                .attr('dy', '.35em')
                                .attr('fill', 'white')
                                .attr('font-weight', 'bold')
                                .attr('font-size', '12px')
                                .text(`GAP ${gapMinutes}min`);
                        }
                    }
                }
                
                if (!lastEnd || program.stop > lastEnd) {
                    lastEnd = program.stop;
                }
            });
        }

        // Tooltip functions
        let currentTooltipTimeout = null;
        
        function showTooltip(event, program) {
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
            }
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="font-semibold">${program.title}</div>
                <div class="text-xs">${formatTime(program.start)} - ${formatTime(program.stop)}</div>
                <div class="text-xs">Durata: ${formatDuration(program.duration)}</div>
                ${program.category ? `<div class="text-xs">Categoria: ${program.category}</div>` : ''}
            `;
            
            currentTooltipTimeout = setTimeout(() => {
                const [mouseX, mouseY] = d3.pointer(event, document.body);
                tooltip.style.left = (mouseX + 10) + 'px';
                tooltip.style.top = (mouseY - 40) + 'px';
                tooltip.classList.remove('hidden');
            }, 200);
        }

        function hideTooltip() {
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
                currentTooltipTimeout = null;
            }
            document.getElementById('tooltip').classList.add('hidden');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailFormat').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTime(program.start)} - ${formatTime(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailRating').textContent = program.rating || '0';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                
                row.innerHTML = `
                    <td class="px-4 py-2">
                        <input type="time" value="${program.start.toTimeString().substr(0, 5)}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">
                        <input type="time" value="${program.stop.toTimeString().substr(0, 5)}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-2">
                        <div class="w-16 h-9 bg-gray-200 rounded" 
                             style="background-image: url(${program.icon}); background-size: cover;">
                        </div>
                    </td>
                    <td class="px-4 py-2">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function updateAnalytics(programs) {
            const formatCounts = {};
            programs.forEach(p => {
                formatCounts[p.title] = (formatCounts[p.title] || 0) + p.duration;
            });
            
            const ctx = document.getElementById('formatChart').getContext('2d');
            
            if (window.formatChart && typeof window.formatChart.destroy === 'function') {
                window.formatChart.destroy();
            }
            
            window.formatChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(formatCounts),
                    datasets: [{
                        data: Object.values(formatCounts).map(s => s / 3600),
                        backgroundColor: Object.keys(formatCounts).map(f => formatColors[f] || '#6B7280')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.parsed.toFixed(1) + ' ore';
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for overlaps
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    if (programs[i].stop > programs[j].start && programs[i].start < programs[j].stop) {
                        const overlapStart = Math.max(programs[i].start, programs[j].start);
                        const overlapEnd = Math.min(programs[i].stop, programs[j].stop);
                        const overlapMinutes = Math.floor((overlapEnd - overlapStart) / 60000);
                        
                        problems.push({
                            type: 'overlap',
                            severity: 'error',
                            message: `Sovrapposizione di ${overlapMinutes} minuti tra "${programs[i].title}" e "${programs[j].title}"`
                        });
                    }
                }
            }
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                let nextNonOverlapping = null;
                for (let j = i + 1; j < sortedPrograms.length; j++) {
                    if (sortedPrograms[j].start >= sortedPrograms[i].stop) {
                        nextNonOverlapping = sortedPrograms[j];
                        break;
                    }
                }
                
                if (nextNonOverlapping) {
                    const gap = nextNonOverlapping.start - sortedPrograms[i].stop;
                    if (gap > 60000) {
                        const gapMinutes = Math.floor(gap / 60000);
                        problems.push({
                            type: 'gap',
                            severity: gapMinutes > 30 ? 'error' : 'warning',
                            message: `Buco di ${gapMinutes} minuti dopo "${sortedPrograms[i].title}"`
                        });
                    }
                }
            }
            
            // Check for missing icons
            const missingIcons = programs.filter(p => 
                !p.icon || p.icon.includes('placeholder') || p.icon.includes('default.jpg')
            ).length;
            
            if (missingIcons > 0) {
                problems.push({
                    type: 'icon',
                    severity: 'info',
                    message: `${missingIcons} programmi con icone mancanti o default`
                });
            }
            
            // Display problems
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600">✅ Nessun problema rilevato</p>';
            } else {
                problems.forEach(problem => {
                    const div = document.createElement('div');
                    div.className = `p-2 rounded text-sm mb-1 ${
                        problem.severity === 'error' ? 'bg-red-50 text-red-700' :
                        problem.severity === 'warning' ? 'bg-yellow-50 text-yellow-700' :
                        'bg-blue-50 text-blue-700'
                    }`;
                    div.textContent = problem.message;
                    report.appendChild(div);
                });
            }
        }

        // Utility functions
        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTime(date) {
            return date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (hours > 0) {
                return `${hours}h ${minutes}min`;
            } else {
                return `${minutes}min`;
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            loadDay();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
            loadDay();
        }

        function resetZoom() {
            zoomLevel = 1;
            loadDay();
        }

        // Mouse wheel zoom
        document.getElementById('timelineContainer').addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Navigation functions
        function prevDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex > 0) {
                selector.selectedIndex--;
                loadDay();
            }
        }

        function nextDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex < selector.options.length - 1) {
                selector.selectedIndex++;
                loadDay();
            }
        }

        // Edit functions
        function editCell(cell, programIndex, field) {
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                // Get current day programs
                const dayPrograms = currentPrograms.filter(p => {
                    const startOfDay = new Date(selectedDay);
                    const endOfDay = new Date(selectedDay);
                    endOfDay.setHours(23, 59, 59, 999);
                    return p.start < endOfDay && p.stop > startOfDay;
                }).sort((a, b) => a.start - b.start);
                
                const program = dayPrograms[programIndex];
                if (program) {
                    program[field] = newValue;
                    
                    // Update XML
                    const elem = program.element.querySelector(field);
                    if (elem) {
                        elem.textContent = newValue;
                    } else if (field === 'category' && newValue) {
                        const catElem = xmlDoc.createElement('category');
                        catElem.setAttribute('lang', 'it');
                        catElem.textContent = newValue;
                        program.element.appendChild(catElem);
                    }
                    
                    // Reload if title changed
                    if (field === 'title') {
                        if (!formatColors[newValue]) {
                            formatColors[newValue] = formatColors[program.title] || colors[colorIndex % colors.length];
                            colorIndex++;
                        }
                        loadDay();
                    }
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const dayPrograms = currentPrograms.filter(p => {
                const startOfDay = new Date(selectedDay);
                const endOfDay = new Date(selectedDay);
                endOfDay.setHours(23, 59, 59, 999);
                return p.start < endOfDay && p.stop > startOfDay;
            }).sort((a, b) => a.start - b.start);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setHours(hours, minutes, 0, 0);
            
            // If the time crosses midnight, adjust the date
            if (timeType === 'stop' && newDate < program.start) {
                newDate.setDate(newDate.getDate() + 1);
            }
            
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            loadDay();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const dayPrograms = currentPrograms.filter(p => {
                const startOfDay = new Date(selectedDay);
                const endOfDay = new Date(selectedDay);
                endOfDay.setHours(23, 59, 59, 999);
                return p.start < endOfDay && p.stop > startOfDay;
            }).sort((a, b) => a.start - b.start);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from array
            const globalIndex = currentPrograms.indexOf(program);
            currentPrograms.splice(globalIndex, 1);
            
            loadDay();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            // Find last program of the day
            const dayPrograms = currentPrograms.filter(p => {
                const startOfDay = new Date(selectedDay);
                const endOfDay = new Date(selectedDay);
                endOfDay.setHours(23, 59, 59, 999);
                return p.start >= startOfDay && p.start < endOfDay;
            }).sort((a, b) => a.start - b.start);
            
            const lastProgram = dayPrograms[dayPrograms.length - 1];
            const newStart = lastProgram ? new Date(lastProgram.stop) : new Date(selectedDay);
            if (!lastProgram) {
                newStart.setHours(20, 0, 0, 0);
            }
            
            const newStop = new Date(newStart);
            newStop.setMinutes(newStop.getMinutes() + 30);
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            const rating = xmlDoc.createElement('rating');
            rating.setAttribute('system', 'Italy Parental Rating');
            const value = xmlDoc.createElement('value');
            value.textContent = '0';
            rating.appendChild(value);
            programme.appendChild(rating);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Add to programs array
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                episodeNum: '',
                duration: 1800,
                element: programme
            };
            
            currentPrograms.push(newProgram);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colors[colorIndex % colors.length];
                colorIndex++;
            }
            
            loadDay();
            showToast('Nuovo programma aggiunto', 'success');
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = selectedDay.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDate = new Date(document.getElementById('newStartDate').value);
            const oldStartDate = selectedDay;
            const dayDiff = Math.floor((newStartDate - oldStartDate) / (1000 * 60 * 60 * 24));
            
            if (dayDiff === 0) {
                showToast('La data selezionata è la stessa', 'info');
                closeActualizationDialog();
                return;
            }
            
            // Update all program dates
            currentPrograms.forEach(program => {
                const newStart = new Date(program.start);
                newStart.setDate(newStart.getDate() + dayDiff);
                const newStop = new Date(program.stop);
                newStop.setDate(newStop.getDate() + dayDiff);
                
                program.start = newStart;
                program.stop = newStop;
                
                program.element.setAttribute('start', formatXMLTVDate(newStart));
                program.element.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            xmlDoc.querySelector('tv').setAttribute('date', newStartDate.toISOString().split('T')[0]);
            
            // Re-parse programs to update day selector
            parsePrograms();
            
            closeActualizationDialog();
            showToast('Date attualizzate con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlDoc);
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `${currentChannelId}_edited_${date}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const utcOffset = new Date().getTimezoneOffset() / -60;
            const offsetStr = utcOffset >= 0 ? `+${utcOffset}` : `${utcOffset}`;
            
            alert(`XMLTV Viewer & Editor Pro v${APP_VERSION}\n\nFunzionalità:\n- Visualizzazione timeline interattiva con zoom\n- Conversione automatica UTC → fuso orario locale\n- Modifica programmi inline\n- Rilevamento sovrapposizioni e buchi\n- Attualizzazione date palinsesto\n- Analisi distribuzione format\n- Export XMLTV modificato\n\nFuso orario rilevato: ${userTimezone} (UTC${offsetStr})\n\nSviluppato per Class CNBC e Class TV Moda`);
        }
    </script>
</body>
</html>
