<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer & Editor Professional v1.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .timeline-container { overflow-x: auto; overflow-y: hidden; }
        .program-block { cursor: pointer; transition: all 0.2s; }
        .program-block:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .gap-indicator { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 10px, #dc2626 10px, #dc2626 20px); }
        .icon-preview { background-size: cover; background-position: center; }
        .toast { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
        .dark { background: #0f172a; color: #e2e8f0; }
        .dark .bg-white { background: #1e293b; }
        .dark .bg-gray-50 { background: #334155; }
        .dark .text-gray-900 { color: #e2e8f0; }
        .dark .text-gray-700 { color: #cbd5e1; }
        .dark .border-gray-200 { border-color: #475569; }
        input[type="datetime-local"] { color-scheme: light dark; }
        .editable-cell { cursor: text; }
        .editable-cell:hover { background: rgba(59, 130, 246, 0.1); }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-blue-600 flex items-center gap-2">
                        <i data-lucide="tv" class="w-8 h-8"></i>
                        XMLTV Viewer & Editor Pro
                    </h1>
                    <p class="text-gray-600 mt-1">Visualizza e modifica palinsesti TV - v1.3</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors" id="dropZone">
                <i data-lucide="upload" class="w-12 h-12 mx-auto text-gray-400 mb-4"></i>
                <p class="text-lg mb-2">Trascina qui il file XMLTV o clicca per selezionarlo</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Canale</h3>
                        <p class="text-xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Seleziona Giorno</h3>
                        <div class="flex items-center gap-2">
                            <button onclick="prevDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-left" class="w-5 h-5"></i>
                            </button>
                            <select id="daySelector" onchange="loadDay()" class="flex-1 px-3 py-2 border rounded">
                                <!-- Options populated dynamically -->
                            </select>
                            <button onclick="nextDay()" class="p-2 hover:bg-gray-100 rounded">
                                <i data-lucide="chevron-right" class="w-5 h-5"></i>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Fuso orario: Europa/Roma (UTC+1/+2)</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Azioni</h3>
                        <div class="flex gap-2">
                            <button onclick="showActualizationDialog()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center gap-1">
                                <i data-lucide="calendar" class="w-4 h-4"></i>
                                Attualizza
                            </button>
                            <button onclick="exportXMLTV()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-1">
                                <i data-lucide="download" class="w-4 h-4"></i>
                                Esporta
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="clock" class="w-5 h-5"></i>
                    Timeline Giornaliera
                </h3>
                <div class="mb-2 flex items-center gap-4">
                    <button onclick="zoomIn()" class="p-2 hover:bg-gray-100 rounded" title="Zoom In">
                        <i data-lucide="zoom-in" class="w-5 h-5"></i>
                    </button>
                    <button onclick="zoomOut()" class="p-2 hover:bg-gray-100 rounded" title="Zoom Out">
                        <i data-lucide="zoom-out" class="w-5 h-5"></i>
                    </button>
                    <button onclick="resetZoom()" class="p-2 hover:bg-gray-100 rounded" title="Reset Zoom">
                        <i data-lucide="maximize-2" class="w-5 h-5"></i>
                    </button>
                    <span class="text-sm text-gray-600">Usa la rotella del mouse per zoom</span>
                </div>
                <div class="timeline-container border rounded-lg p-4" id="timelineContainer">
                    <svg id="timeline" width="100%" height="150"></svg>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" id="programDetails" style="display:none;">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-5 h-5"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <p class="text-sm text-gray-600">Titolo</p>
                        <p class="font-semibold" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Format</p>
                        <p class="font-semibold" id="detailFormat">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Orario</p>
                        <p class="font-semibold" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Durata</p>
                        <p class="font-semibold" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Categoria</p>
                        <p class="font-semibold" id="detailCategory">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Rating</p>
                        <p class="font-semibold" id="detailRating">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="icon-preview w-32 h-18 border rounded" id="detailIcon"></div>
                            <p class="text-xs text-gray-500" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit" class="w-5 h-5"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 text-sm flex items-center gap-1">
                        <i data-lucide="plus" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left">Ora Inizio</th>
                                <th class="px-4 py-2 text-left">Ora Fine</th>
                                <th class="px-4 py-2 text-left">Durata</th>
                                <th class="px-4 py-2 text-left">Titolo/Format</th>
                                <th class="px-4 py-2 text-left">Categoria</th>
                                <th class="px-4 py-2 text-left">Icona</th>
                                <th class="px-4 py-2 text-left">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Analytics -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="pie-chart" class="w-5 h-5"></i>
                        Distribuzione Format
                    </h3>
                    <canvas id="formatChart" width="400" height="300"></canvas>
                </div>
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        Report Problemi
                    </h3>
                    <div id="problemsReport" class="space-y-2">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full">
                <h3 class="text-lg font-semibold mb-4">Attualizza Date Palinsesto</h3>
                <p class="text-sm text-gray-600 mb-4">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-3 py-2 border rounded mb-4">
                <div class="flex justify-end gap-2">
                    <button onclick="closeActualizationDialog()" class="px-4 py-2 border rounded hover:bg-gray-50">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

        <!-- Tooltip - Fixed positioning -->
        <div id="tooltip" class="fixed bg-gray-900 text-white p-3 rounded shadow-lg text-sm hidden" style="z-index: 9999; pointer-events: none;"></div>
    </div>

    <script>
        // Fallback icons in case Lucide doesn't load
        window.addEventListener('DOMContentLoaded', function() {
            // Try to initialize Lucide icons after DOM is loaded
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    // Replace Lucide icon placeholders with emoji
                    document.querySelectorAll('[data-lucide]').forEach(el => {
                        const iconMap = {
                            'tv': '📺',
                            'moon': '🌙',
                            'info': 'ℹ️',
                            'upload': '📤',
                            'chevron-left': '◀',
                            'chevron-right': '▶',
                            'calendar': '📅',
                            'download': '💾',
                            'clock': '🕐',
                            'zoom-in': '🔍+',
                            'zoom-out': '🔍-',
                            'maximize-2': '⛶',
                            'tv-2': '📺',
                            'edit': '✏️',
                            'plus': '➕',
                            'pie-chart': '📊',
                            'alert-triangle': '⚠️',
                            'trash-2': '🗑️'
                        };
                        const iconName = el.getAttribute('data-lucide');
                        el.textContent = iconMap[iconName] || '•';
                        el.style.fontStyle = 'normal';
                    });
                }
            }, 100);
        });

        // Version
        const APP_VERSION = '1.3';
        console.log(`XMLTV Viewer & Editor Pro v${APP_VERSION} - Fixed tooltip, UTC handling & performance`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let selectedDay = null;
        let zoomLevel = 1;
        let formatColors = {};
        let colorIndex = 0;

        // Format dictionaries
        const formatIcons = {
            'ClassCNBC': {
                "Trading Room": "trading-room.jpg",
                "Business Class": "business-class.jpg",
                "Mercati in 10 minuti": "mercati-10.jpg",
                "Class Meteo": "meteo.jpg",
                "Borse Oggi": "borse-oggi.jpg",
                "Apertura Mercati": "apertura-mercati.jpg",
                "Market Driver": "market-driver.jpg",
                "Wall Street": "wall-street.jpg",
                "Chiusura Mercati": "chiusura-mercati.jpg",
                "Business Talk": "business-talk.jpg",
                "Class Life": "class-life.jpg",
                "Report": "report.jpg",
                "Documentario": "documentario.jpg",
                "Programmazione notturna": "default.jpg"
            },
            'ClassTVModa': {
                "CATWALKS": "catwalks.jpg",
                "FASHION NEWS": "fashion-news.jpg",
                "FRONT ROW": "front-row.jpg",
                "SPOTLIGHT": "spotlight.jpg",
                "(UN)ACCESSING BACKSTAGE": "backstage.jpg",
                "CLASS TV MODA STORIES": "tv-moda-stories.jpg",
                "DESIGN MAP": "design-map.jpg",
                "DISTRICTS": "districts.jpg",
                "FASHION&BEYOND": "fashion-beyond.jpg",
                "GREEN REVOLUTION FORWARD": "green-revolution.jpg",
                "SOUND OF FASHION": "sound-of-fashion.jpg",
                "VOICES": "voices.jpg",
                "WHAT WOMEN WEAR": "what-women-wear.jpg",
                "Programmazione": "default.jpg"
            }
        };

        const iconBaseUrls = {
            'ClassCNBC': 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassCNBC_IT_samsung/Images/',
            'ClassTVModa': 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassTVModa_IT_samsung/Images/'
        };

        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];

        // Initialize Lucide icons
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        } else {
            console.warn('Lucide not loaded, using emoji fallbacks');
        }

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', (e) => {
            // Prevent double trigger when clicking the button
            if (e.target.tagName !== 'BUTTON') {
                fileInput.click();
            }
        });
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-blue-400', 'bg-blue-50');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.xml')) {
                loadFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadFile(file);
            }
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    currentChannelId = channel.getAttribute('id');
                    currentChannelName = channel.querySelector('display-name').textContent;
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            currentPrograms = [];
            const daysMap = new Map(); // Map to track unique days
            
            programmes.forEach(prog => {
                const startUTC = parseXMLTVDate(prog.getAttribute('start'));
                const stopUTC = parseXMLTVDate(prog.getAttribute('stop'));
                
                // Debug first few programs
                if (currentPrograms.length < 5) {
                    console.log('Program:', prog.querySelector('title')?.textContent);
                    console.log('  Start UTC string:', prog.getAttribute('start'));
                    console.log('  Start UTC parsed:', startUTC.toISOString());
                    console.log('  Start Local:', startUTC.toString());
                    console.log('  Stop UTC string:', prog.getAttribute('stop'));
                    console.log('  Stop Local:', stopUTC.toString());
                }
                
                const title = prog.querySelector('title')?.textContent || '';
                const desc = prog.querySelector('desc')?.textContent || '';
                const category = prog.querySelector('category')?.textContent || '';
                const rating = prog.querySelector('rating value')?.textContent || '0';
                const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                const episodeNum = prog.querySelector('episode-num')?.textContent || '';
                
                const program = {
                    start: startUTC,
                    stop: stopUTC,
                    title,
                    desc,
                    category,
                    rating,
                    icon,
                    episodeNum,
                    duration: (stopUTC - startUTC) / 1000, // seconds
                    element: prog
                };
                
                currentPrograms.push(program);
                
                // Create date keys for ALL days where this program appears
                // A program should appear in the day where it AIRS, not just where it starts
                const startDate = new Date(startUTC);
                const endDate = new Date(stopUTC);
                
                // Add all days from start to end
                const currentDate = new Date(startDate);
                currentDate.setHours(0, 0, 0, 0);
                
                while (currentDate <= endDate) {
                    const dateKey = currentDate.toISOString().split('T')[0];
                    if (!daysMap.has(dateKey)) {
                        daysMap.set(dateKey, new Date(currentDate));
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                
                // Assign color to format
                if (!formatColors[title]) {
                    formatColors[title] = colors[colorIndex % colors.length];
                    colorIndex++;
                }
            });
            
            // Populate day selector with unique days
            const daySelector = document.getElementById('daySelector');
            daySelector.innerHTML = '';
            
            // Sort days
            const sortedDays = Array.from(daysMap.entries())
                .sort((a, b) => a[1] - b[1]);
            
            console.log('Found days:', sortedDays.map(d => d[0]));
            console.log('Total programs:', currentPrograms.length);
            
            sortedDays.forEach(([dateKey, date]) => {
                const option = document.createElement('option');
                option.value = dateKey;
                
                // Count programs for this day
                const [year, month, day] = dateKey.split('-').map(Number);
                const dayStart = new Date(year, month - 1, day, 0, 0, 0, 0);
                const dayEnd = new Date(year, month - 1, day, 23, 59, 59, 999);
                
                const programCount = currentPrograms.filter(p => {
                    return (p.start < dayEnd && p.stop > dayStart);
                }).length;
                
                option.textContent = `${formatDate(date)} (${programCount} programmi)`;
                daySelector.appendChild(option);
            });
            
            if (sortedDays.length > 0) {
                // Select the day with most programs (usually the main day)
                let maxPrograms = 0;
                let bestDayIndex = 0;
                
                sortedDays.forEach(([dateKey, date], index) => {
                    const [year, month, day] = dateKey.split('-').map(Number);
                    const dayStart = new Date(year, month - 1, day, 0, 0, 0, 0);
                    const dayEnd = new Date(year, month - 1, day, 23, 59, 59, 999);
                    
                    const programCount = currentPrograms.filter(p => {
                        return (p.start < dayEnd && p.stop > dayStart);
                    }).length;
                    
                    if (programCount > maxPrograms) {
                        maxPrograms = programCount;
                        bestDayIndex = index;
                    }
                });
                
                selectedDay = sortedDays[bestDayIndex][1];
                daySelector.selectedIndex = bestDayIndex;
                loadDay();
            }
        }

        function parseXMLTVDate(dateStr) {
            // Format: YYYYMMDDHHmmss +0000
            const year = parseInt(dateStr.substr(0, 4));
            const month = parseInt(dateStr.substr(4, 2)) - 1;
            const day = parseInt(dateStr.substr(6, 2));
            const hour = parseInt(dateStr.substr(8, 2));
            const minute = parseInt(dateStr.substr(10, 2));
            const second = parseInt(dateStr.substr(12, 2));
            
            // Create UTC date
            const utcDate = new Date(Date.UTC(year, month, day, hour, minute, second));
            
            // Return date object (JavaScript automatically handles timezone conversion)
            return utcDate;
        }

        function formatXMLTVDate(date) {
            // Convert local date back to UTC for XML format
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getUTCFullYear()}${pad(date.getUTCMonth() + 1)}${pad(date.getUTCDate())}` +
                   `${pad(date.getUTCHours())}${pad(date.getUTCMinutes())}${pad(date.getUTCSeconds())} +0000`;
        }

        function loadDay() {
            const dayValue = document.getElementById('daySelector').value;
            console.log('Selected day value:', dayValue);
            
            // Create date at midnight local time
            const [year, month, day] = dayValue.split('-').map(Number);
            selectedDay = new Date(year, month - 1, day, 0, 0, 0, 0);
            
            // Set boundaries for the selected day in local time
            const startOfDay = new Date(selectedDay);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            console.log('Loading day:', formatDate(selectedDay));
            console.log('Day boundaries (local):', startOfDay.toString(), 'to', endOfDay.toString());
            console.log('Day boundaries (ISO):', startOfDay.toISOString(), 'to', endOfDay.toISOString());
            
            // Filter programs that appear in this local day
            // A program appears in a day if ANY part of it airs during that day
            const dayPrograms = currentPrograms.filter(p => {
                // Program overlaps with this day if it starts before the day ends
                // AND ends after the day starts
                const overlaps = p.start < endOfDay && p.stop > startOfDay;
                
                return overlaps;
            });
            
            console.log(`Found ${dayPrograms.length} programs for ${formatDate(selectedDay)}`);
            
            // Log first few overlapping programs for debugging
            dayPrograms.slice(0, 5).forEach((p, i) => {
                console.log(`  ${i + 1}. ${p.title}: ${formatTime(p.start)} - ${formatTime(p.stop)}`);
            });
            
            // Sort by start time
            dayPrograms.sort((a, b) => a.start - b.start);
            
            // Log first and last programs for debugging
            if (dayPrograms.length > 0) {
                console.log(`First program: ${dayPrograms[0].title} at ${formatTime(dayPrograms[0].start)}`);
                console.log(`Last program: ${dayPrograms[dayPrograms.length-1].title} at ${formatTime(dayPrograms[dayPrograms.length-1].start)}`);
            }
            
            // Draw timeline
                                drawTimeline(dayPrograms);
                } catch (err) {
                    console.error('Error in drawTimeline:', err);
                    showToast('Errore nella visualizzazione timeline: ' + err.message, 'error');
                }
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update analytics
            updateAnalytics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
        }

        function drawTimeline(programs) {
            const container = document.getElementById('timelineContainer');
            const svg = d3.select('#timeline');
            svg.selectAll('*').remove();
            
            const width = container.clientWidth * zoomLevel;
            const height = 150;
            const margin = { top: 20, right: 20, bottom: 30, left: 20 };
            
            svg.attr('width', width).attr('height', height);
            
            // Time scale for the selected day in LOCAL time
            const startOfDay = new Date(selectedDay);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(selectedDay);
            endOfDay.setHours(23, 59, 59, 999);
            
            const xScale = d3.scaleTime()
                .domain([startOfDay, endOfDay])
                .range([margin.left, width - margin.right]);
            
            // Draw time axis with local time
            const xAxis = d3.axisBottom(xScale)
                .ticks(d3.timeHour.every(1))
                .tickFormat(d3.timeFormat('%H:%M'));
            
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(xAxis);
            
            // Add grid lines for better readability
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .ticks(d3.timeHour.every(1))
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            // Group overlapping programs into rows
            const rows = [];
            programs.forEach(program => {
                let placed = false;
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    const row = rows[rowIndex];
                    // Check if program fits in this row without overlap
                    const fits = !row.some(p => 
                        (program.start < p.stop && program.stop > p.start)
                    );
                    if (fits) {
                        row.push(program);
                        placed = true;
                        program.row = rowIndex;
                        break;
                    }
                }
                if (!placed) {
                    rows.push([program]);
                    program.row = rows.length - 1;
                }
            });
            
            // Draw programs
            const programHeight = 50;
            const rowGap = 5;
            const baseY = margin.top + 10;
            
            programs.forEach((program, index) => {
                // Clip program to day boundaries
                const programStart = program.start < startOfDay ? startOfDay : program.start;
                const programEnd = program.stop > endOfDay ? endOfDay : program.stop;
                
                const x = xScale(programStart);
                const width = Math.max(1, xScale(programEnd) - x);
                const y = baseY + (program.row || 0) * (programHeight + rowGap);
                
                const g = svg.append('g')
                    .attr('class', 'program-block')
                    .attr('transform', `translate(${x},${y})`)
                    .style('cursor', 'pointer')
                    .on('click', () => showProgramDetails(program))
                    .on('mouseenter', (event) => showTooltip(event, program))
                    .on('mouseleave', hideTooltip);
                
                // Highlight overlapping programs
                const hasOverlap = programs.some((p, i) => 
                    i !== index && p.start < program.stop && p.stop > program.start
                );
                
                // Program block
                g.append('rect')
                    .attr('width', width)
                    .attr('height', programHeight)
                    .attr('rx', 4)
                    .attr('fill', formatColors[program.title] || '#6B7280')
                    .attr('stroke', hasOverlap ? '#ff0000' : '#fff')
                    .attr('stroke-width', hasOverlap ? 3 : 2);
                
                // Add opacity if program extends beyond day boundaries
                if (program.start < startOfDay || program.stop > endOfDay) {
                    g.attr('opacity', 0.8);
                }
                
                // Program title
                if (width > 30) {
                    g.append('text')
                        .attr('x', 5)
                        .attr('y', programHeight / 2 - 5)
                        .attr('dy', '.35em')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(program.title)
                        .each(function() {
                            const self = d3.select(this);
                            let textLength = self.node().getComputedTextLength();
                            let text = self.text();
                            while (textLength > width - 10 && text.length > 0) {
                                text = text.slice(0, -1);
                                self.text(text + '...');
                                textLength = self.node().getComputedTextLength();
                            }
                        });
                    
                    // Add time label
                    if (width > 80) {
                        g.append('text')
                            .attr('x', 5)
                            .attr('y', programHeight - 8)
                            .attr('fill', 'white')
                            .attr('font-size', '10px')
                            .text(`${formatTime(program.start)} - ${formatTime(program.stop)}`);
                    }
                }
                
                // Warning icon for overlaps
                if (hasOverlap && width > 30) {
                    g.append('text')
                        .attr('x', width - 20)
                        .attr('y', programHeight / 2)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '16px')
                        .text('⚠️');
                }
            });
            
            // Check for gaps between consecutive programs (considering overlaps)
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            let lastEnd = null;
            
            sortedPrograms.forEach(program => {
                if (lastEnd && program.start > lastEnd) {
                    const gap = program.start - lastEnd;
                    if (gap > 60000) { // More than 1 minute
                        const x = xScale(lastEnd);
                        const width = xScale(program.start) - x;
                        
                        svg.append('rect')
                            .attr('x', x)
                            .attr('y', baseY)
                            .attr('width', width)
                            .attr('height', programHeight)
                            .attr('class', 'gap-indicator')
                            .attr('opacity', 0.5);
                        
                        // Add gap duration text
                        const gapMinutes = Math.floor(gap / 60000);
                        svg.append('text')
                            .attr('x', x + width/2)
                            .attr('y', baseY + programHeight/2)
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'white')
                            .attr('font-weight', 'bold')
                            .text(`GAP ${gapMinutes}min`);
                    }
                }
                
                // Update lastEnd to be the maximum end time seen so far
                if (!lastEnd || program.stop > lastEnd) {
                    lastEnd = program.stop;
                }
            });
            
            // Update axis to 24h display
            svg.attr('width', width).attr('height', height);

        // Fixed tooltip implementation
        let currentTooltipTimeout = null;
        
        function showTooltip(event, program) {
            // Clear any existing timeout
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
            }
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="font-semibold">${program.title}</div>
                <div class="text-xs">${formatTime(program.start)} - ${formatTime(program.stop)}</div>
                <div class="text-xs">Durata: ${formatDuration(program.duration)}</div>
                ${program.category ? `<div class="text-xs">Categoria: ${program.category}</div>` : ''}
            `;
            
            // Small delay to prevent flicker
            currentTooltipTimeout = setTimeout(() => {
                // Get mouse position from D3 event
                const [mouseX, mouseY] = d3.pointer(event, document.body);
                
                // Position tooltip
                tooltip.style.left = (mouseX + 10) + 'px';
                tooltip.style.top = (mouseY - 40) + 'px';
                tooltip.classList.remove('hidden');
            }, 200);
        }

        function hideTooltip() {
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
                currentTooltipTimeout = null;
            }
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.add('hidden');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailFormat').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTime(program.start)} - ${formatTime(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailRating').textContent = program.rating || '0';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            // Scroll to details
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            // Get programs for current day including filtering
            const dayPrograms = programs;
            
            dayPrograms.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                
                const startTime = formatTime(program.start);
                const endTime = formatTime(program.stop);
                const duration = formatDuration(program.duration);
                
                row.innerHTML = `
                    <td class="px-4 py-2">
                        <input type="time" value="${program.start.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'})}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">
                        <input type="time" value="${program.stop.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'})}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">${duration}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-2">
                        <div class="w-16 h-9 bg-gray-200 rounded" 
                             style="background-image: url(${program.icon}); background-size: cover;">
                        </div>
                    </td>
                    <td class="px-4 py-2">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function updateAnalytics(programs) {
            // Format distribution chart
            const formatCounts = {};
            programs.forEach(p => {
                formatCounts[p.title] = (formatCounts[p.title] || 0) + p.duration;
            });
            
            const ctx = document.getElementById('formatChart').getContext('2d');
            
            // Destroy existing chart if any
            if (window.formatChart && typeof window.formatChart.destroy === 'function') {
                window.formatChart.destroy();
            }
            
            window.formatChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(formatCounts),
                    datasets: [{
                        data: Object.values(formatCounts).map(s => s / 3600), // Convert to hours
                        backgroundColor: Object.keys(formatCounts).map(f => formatColors[f] || '#6B7280')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.parsed.toFixed(1) + ' ore';
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for overlaps
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    if (programs[i].stop > programs[j].start && programs[i].start < programs[j].stop) {
                        const overlapStart = Math.max(programs[i].start, programs[j].start);
                        const overlapEnd = Math.min(programs[i].stop, programs[j].stop);
                        const overlapMinutes = Math.floor((overlapEnd - overlapStart) / 60000);
                        
                        problems.push({
                            type: 'overlap',
                            severity: 'error',
                            message: `⚠️ SOVRAPPOSIZIONE di ${overlapMinutes} minuti tra "${programs[i].title}" (${formatTime(programs[i].start)}-${formatTime(programs[i].stop)}) e "${programs[j].title}" (${formatTime(programs[j].start)}-${formatTime(programs[j].stop)})`
                        });
                    }
                }
            }
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                // Find the next program that doesn't overlap with current
                let nextNonOverlapping = null;
                for (let j = i + 1; j < sortedPrograms.length; j++) {
                    if (sortedPrograms[j].start >= sortedPrograms[i].stop) {
                        nextNonOverlapping = sortedPrograms[j];
                        break;
                    }
                }
                
                if (nextNonOverlapping) {
                    const gap = nextNonOverlapping.start - sortedPrograms[i].stop;
                    if (gap > 60000) { // More than 1 minute
                        const gapMinutes = Math.floor(gap / 60000);
                        problems.push({
                            type: 'gap',
                            severity: gapMinutes > 30 ? 'error' : 'warning',
                            message: `Buco di ${gapMinutes} minuti tra "${sortedPrograms[i].title}" (${formatTime(sortedPrograms[i].stop)}) e "${nextNonOverlapping.title}" (${formatTime(nextNonOverlapping.start)})`
                        });
                    }
                }
            }
            
            // Check for missing icons
            programs.forEach(p => {
                if (!p.icon || p.icon.includes('placeholder') || p.icon.includes('default.jpg')) {
                    problems.push({
                        type: 'icon',
                        severity: 'warning',
                        message: `Icona mancante o default per "${p.title}"`
                    });
                }
            });
            
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600">✅ Nessun problema rilevato</p>';
            } else {
                // Group problems by type
                const overlaps = problems.filter(p => p.type === 'overlap');
                const gaps = problems.filter(p => p.type === 'gap');
                const icons = problems.filter(p => p.type === 'icon');
                
                if (overlaps.length > 0) {
                    const div = document.createElement('div');
                    div.className = 'mb-3';
                    div.innerHTML = `<h4 class="font-semibold text-red-700 mb-1">❌ Sovrapposizioni (${overlaps.length})</h4>`;
                    overlaps.forEach(p => {
                        const item = document.createElement('div');
                        item.className = 'p-2 rounded bg-red-50 text-red-700 text-sm mb-1';
                        item.textContent = p.message;
                        div.appendChild(item);
                    });
                    report.appendChild(div);
                }
                
                if (gaps.length > 0) {
                    const div = document.createElement('div');
                    div.className = 'mb-3';
                    div.innerHTML = `<h4 class="font-semibold text-yellow-700 mb-1">⚠️ Buchi nel palinsesto (${gaps.length})</h4>`;
                    gaps.forEach(p => {
                        const item = document.createElement('div');
                        item.className = `p-2 rounded text-sm mb-1 ${p.severity === 'error' ? 'bg-red-50 text-red-700' : 'bg-yellow-50 text-yellow-700'}`;
                        item.textContent = p.message;
                        div.appendChild(item);
                    });
                    report.appendChild(div);
                }
                
                if (icons.length > 0) {
                    const div = document.createElement('div');
                    div.className = 'mb-3';
                    div.innerHTML = `<h4 class="font-semibold text-blue-700 mb-1">ℹ️ Icone mancanti (${icons.length})</h4>`;
                    const item = document.createElement('div');
                    item.className = 'p-2 rounded bg-blue-50 text-blue-700 text-sm';
                    item.textContent = `${icons.length} programmi con icone mancanti o default`;
                    div.appendChild(item);
                    report.appendChild(div);
                }
            }
        }

        // Utility functions
        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTime(date) {
            return date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            loadDay();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
            loadDay();
        }

        function resetZoom() {
            zoomLevel = 1;
            loadDay();
        }

        // Mouse wheel zoom
        document.getElementById('timelineContainer').addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Navigation functions
        function prevDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex > 0) {
                selector.selectedIndex--;
                loadDay();
            }
        }

        function nextDay() {
            const selector = document.getElementById('daySelector');
            if (selector.selectedIndex < selector.options.length - 1) {
                selector.selectedIndex++;
                loadDay();
            }
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = selectedDay.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDate = new Date(document.getElementById('newStartDate').value);
            const oldStartDate = selectedDay;
            const dayDiff = Math.floor((newStartDate - oldStartDate) / (1000 * 60 * 60 * 24));
            
            // Create new XML document
            const newDoc = xmlDoc.cloneNode(true);
            
            // Update all program dates
            const programmes = newDoc.querySelectorAll('programme');
            programmes.forEach(prog => {
                const oldStart = parseXMLTVDate(prog.getAttribute('start'));
                const oldStop = parseXMLTVDate(prog.getAttribute('stop'));
                
                const newStart = new Date(oldStart);
                newStart.setDate(newStart.getDate() + dayDiff);
                const newStop = new Date(oldStop);
                newStop.setDate(newStop.getDate() + dayDiff);
                
                prog.setAttribute('start', formatXMLTVDate(newStart));
                prog.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            newDoc.querySelector('tv').setAttribute('date', newStartDate.toISOString().split('T')[0]);
            
            // Download new file
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(newDoc);
            const blob = new Blob([xmlString], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentChannelId}_actualized_${newStartDate.toISOString().split('T')[0]}.xml`;
            a.click();
            
            URL.revokeObjectURL(url);
            closeActualizationDialog();
            showToast('File attualizzato scaricato con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlDoc);
            const blob = new Blob([xmlString], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentChannelId}_edited_${new Date().toISOString().split('T')[0]}.xml`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Edit functions
        function editCell(cell, programIndex, field) {
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                // Update program
                const dayPrograms = currentPrograms.filter(p => 
                    p.start.toDateString() === selectedDay.toDateString() ||
                    (p.start < selectedDay && p.stop > selectedDay)
                ).sort((a, b) => a.start - b.start);
                
                const program = dayPrograms[programIndex];
                if (program) {
                    program[field] = newValue;
                    
                    // Update XML
                    const titleElem = program.element.querySelector(field);
                    if (titleElem) {
                        titleElem.textContent = newValue;
                    } else if (field === 'category') {
                        const catElem = xmlDoc.createElement('category');
                        catElem.setAttribute('lang', 'it');
                        catElem.textContent = newValue;
                        program.element.appendChild(catElem);
                    }
                    
                    // Reload if title changed (affects colors)
                    if (field === 'title') {
                        loadDay();
                    }
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const dayPrograms = currentPrograms.filter(p => 
                p.start.toDateString() === selectedDay.toDateString() ||
                (p.start < selectedDay && p.stop > selectedDay)
            ).sort((a, b) => a.start - b.start);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setHours(hours, minutes, 0, 0);
            
            // If the time crosses midnight, adjust the date
            if (timeType === 'stop' && newDate < program.start) {
                newDate.setDate(newDate.getDate() + 1);
            }
            
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            loadDay();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const dayPrograms = currentPrograms.filter(p => 
                p.start.toDateString() === selectedDay.toDateString() ||
                (p.start < selectedDay && p.stop > selectedDay)
            ).sort((a, b) => a.start - b.start);
            
            const program = dayPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from array
            const globalIndex = currentPrograms.indexOf(program);
            currentPrograms.splice(globalIndex, 1);
            
            loadDay();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            // Find last program of the day
            const dayPrograms = currentPrograms.filter(p => 
                p.start.toDateString() === selectedDay.toDateString()
            ).sort((a, b) => a.start - b.start);
            
            const lastProgram = dayPrograms[dayPrograms.length - 1];
            const newStart = lastProgram ? new Date(lastProgram.stop) : new Date(selectedDay);
            if (!lastProgram) {
                newStart.setHours(0, 0, 0, 0);
            }
            
            const newStop = new Date(newStart);
            newStop.setMinutes(newStop.getMinutes() + 30);
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            const rating = xmlDoc.createElement('rating');
            rating.setAttribute('system', 'Italy Parental Rating');
            const value = xmlDoc.createElement('value');
            value.textContent = '0';
            rating.appendChild(value);
            programme.appendChild(rating);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Add to programs array
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                episodeNum: '',
                duration: 1800,
                element: programme
            };
            
            currentPrograms.push(newProgram);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colors[colorIndex % colors.length];
                colorIndex++;
            }
            
            loadDay();
            showToast('Nuovo programma aggiunto', 'success');
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const utcOffset = new Date().getTimezoneOffset() / -60;
            const offsetStr = utcOffset >= 0 ? `+${utcOffset}` : `${utcOffset}`;
            
            alert(`XMLTV Viewer & Editor Pro v${APP_VERSION}\n\nFunzionalità:\n- Visualizzazione timeline interattiva\n- Conversione automatica da UTC a fuso orario locale\n- Modifica programmi inline\n- Attualizzazione date\n- Analisi e report\n- Export XMLTV\n\nFuso orario rilevato: ${userTimezone} (UTC${offsetStr})\n\nSviluppato per Class CNBC e Class TV Moda`);
        }
    </script>
</body>
</html>
