<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer & Editor Professional v1.6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .timeline-container { overflow-x: auto; overflow-y: hidden; }
        .program-block { cursor: pointer; transition: all 0.2s; }
        .program-block:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .gap-indicator { background: repeating-linear-gradient(45deg, #ef4444, #ef4444 10px, #dc2626 10px, #dc2626 20px); }
        .icon-preview { background-size: cover; background-position: center; }
        .toast { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }
        .dark { background: #0f172a; color: #e2e8f0; }
        .dark .bg-white { background: #1e293b; }
        .dark .bg-gray-50 { background: #334155; }
        .dark .text-gray-900 { color: #e2e8f0; }
        .dark .text-gray-700 { color: #cbd5e1; }
        .dark .border-gray-200 { border-color: #475569; }
        input[type="datetime-local"] { color-scheme: light dark; }
        .editable-cell { cursor: text; }
        .editable-cell:hover { background: rgba(59, 130, 246, 0.1); }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-blue-600 flex items-center gap-2">
                        <i data-lucide="tv" class="w-8 h-8"></i>
                        XMLTV Viewer & Editor Pro
                    </h1>
                    <p class="text-gray-600 mt-1">Visualizza e modifica palinsesti TV - v1.6</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-2 rounded hover:bg-gray-100">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors" id="dropZone">
                <i data-lucide="upload" class="w-12 h-12 mx-auto text-gray-400 mb-4"></i>
                <p class="text-lg mb-2">Trascina qui il file XMLTV o clicca per selezionarlo</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Canale</h3>
                        <p class="text-xl font-bold" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Data Palinsesto</h3>
                        <p class="text-xl font-bold" id="scheduleDate">-</p>
                        <p class="text-sm text-gray-600">
                            <span id="programCount">-</span> programmi
                        </p>
                        <p class="text-xs text-gray-500 mt-1">Fuso orario: Europa/Roma (UTC+1/+2)</p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2">Azioni</h3>
                        <div class="flex gap-2">
                            <button onclick="showActualizationDialog()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center gap-1">
                                <i data-lucide="calendar" class="w-4 h-4"></i>
                                Attualizza
                            </button>
                            <button onclick="exportXMLTV()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-1">
                                <i data-lucide="download" class="w-4 h-4"></i>
                                Esporta
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="clock" class="w-5 h-5"></i>
                    Timeline Giornaliera <span id="timelineDate" class="text-sm font-normal text-gray-600"></span>
                </h3>
                <div class="mb-2 flex items-center gap-4">
                    <button onclick="zoomIn()" class="p-2 hover:bg-gray-100 rounded" title="Zoom In">
                        <i data-lucide="zoom-in" class="w-5 h-5"></i>
                    </button>
                    <button onclick="zoomOut()" class="p-2 hover:bg-gray-100 rounded" title="Zoom Out">
                        <i data-lucide="zoom-out" class="w-5 h-5"></i>
                    </button>
                    <button onclick="resetZoom()" class="p-2 hover:bg-gray-100 rounded" title="Reset Zoom">
                        <i data-lucide="maximize-2" class="w-5 h-5"></i>
                    </button>
                    <span class="text-sm text-gray-600">Usa la rotella del mouse per zoom</span>
                </div>
                <div class="timeline-container border rounded-lg p-4" id="timelineContainer">
                    <svg id="timeline" width="100%" height="150"></svg>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" id="programDetails" style="display:none;">
                <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-5 h-5"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <p class="text-sm text-gray-600">Titolo</p>
                        <p class="font-semibold" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Format</p>
                        <p class="font-semibold" id="detailFormat">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Orario</p>
                        <p class="font-semibold" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Durata</p>
                        <p class="font-semibold" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Categoria</p>
                        <p class="font-semibold" id="detailCategory">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-600">Rating</p>
                        <p class="font-semibold" id="detailRating">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Descrizione</p>
                        <p class="font-semibold" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-600">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="icon-preview w-32 h-18 border rounded" id="detailIcon"></div>
                            <p class="text-xs text-gray-500" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit" class="w-5 h-5"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 text-sm flex items-center gap-1">
                        <i data-lucide="plus" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-2 text-left">Ora Inizio</th>
                                <th class="px-4 py-2 text-left">Ora Fine</th>
                                <th class="px-4 py-2 text-left">Durata</th>
                                <th class="px-4 py-2 text-left">Titolo/Format</th>
                                <th class="px-4 py-2 text-left">Categoria</th>
                                <th class="px-4 py-2 text-left">Icona</th>
                                <th class="px-4 py-2 text-left">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Analytics -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="pie-chart" class="w-5 h-5"></i>
                        Distribuzione Format
                    </h3>
                    <canvas id="formatChart" width="400" height="300"></canvas>
                </div>
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                        <i data-lucide="alert-triangle" class="w-5 h-5"></i>
                        Report Problemi
                    </h3>
                    <div id="problemsReport" class="space-y-2">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full">
                <h3 class="text-lg font-semibold mb-4">Attualizza Date Palinsesto</h3>
                <p class="text-sm text-gray-600 mb-4">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-3 py-2 border rounded mb-4">
                <div class="flex justify-end gap-2">
                    <button onclick="closeActualizationDialog()" class="px-4 py-2 border rounded hover:bg-gray-50">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

        <!-- Tooltip -->
        <div id="tooltip" class="fixed bg-gray-900 text-white p-3 rounded shadow-lg text-sm hidden" style="z-index: 9999; pointer-events: none;"></div>
    </div>

    <script>
        // Initialize Lucide icons after DOM is loaded
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    console.warn('Lucide not loaded, using emoji fallbacks');
                    document.querySelectorAll('[data-lucide]').forEach(el => {
                        const iconMap = {
                            'tv': 'ðŸ“º',
                            'moon': 'ðŸŒ™',
                            'info': 'â„¹ï¸',
                            'upload': 'ðŸ“¤',
                            'calendar': 'ðŸ“…',
                            'download': 'ðŸ’¾',
                            'clock': 'ðŸ•',
                            'zoom-in': 'ðŸ”+',
                            'zoom-out': 'ðŸ”-',
                            'maximize-2': 'â›¶',
                            'tv-2': 'ðŸ“º',
                            'edit': 'âœï¸',
                            'plus': 'âž•',
                            'pie-chart': 'ðŸ“Š',
                            'alert-triangle': 'âš ï¸',
                            'trash-2': 'ðŸ—‘ï¸'
                        };
                        const iconName = el.getAttribute('data-lucide');
                        el.textContent = iconMap[iconName] || 'â€¢';
                        el.style.fontStyle = 'normal';
                    });
                }
            }, 100);
        });

        // Version
        const APP_VERSION = '1.6';
        console.log(`XMLTV Viewer & Editor Pro v${APP_VERSION} - Single day view with proper UTC handling`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let scheduleDate = null;
        let timelineStartDate = null;
        let timelineEndDate = null;
        let zoomLevel = 1;
        let formatColors = {};
        let colorIndex = 0;

        // Color palette
        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            dropZone.classList.add('border-blue-400', 'bg-blue-50');
        }

        function unhighlight(e) {
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
        }

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        // Handle file input change
        fileInput.addEventListener('change', function(e) {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/xml' || file.type === 'application/xml' || file.name.endsWith('.xml')) {
                    loadFile(file);
                } else {
                    showToast('Seleziona un file XML valido', 'error');
                }
            }
        }

        function loadFile(file) {
            console.log('Loading file:', file.name);
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const xmlContent = e.target.result;
                    console.log('File content loaded, length:', xmlContent.length);
                    
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.getElementsByTagName('parsererror');
                    if (parserError.length > 0) {
                        throw new Error('Errore nel parsing XML: ' + parserError[0].textContent);
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    console.log('Channel found:', currentChannelName, '(ID:', currentChannelId, ')');
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            
            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                showToast('Errore nella lettura del file', 'error');
            };
            
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            console.log('Found programmes:', programmes.length);
            
            currentPrograms = [];
            
            // Parse all programs
            programmes.forEach((prog, index) => {
                try {
                    const startStr = prog.getAttribute('start');
                    const stopStr = prog.getAttribute('stop');
                    
                    if (!startStr || !stopStr) {
                        console.warn(`Programme ${index} missing start or stop time`);
                        return;
                    }
                    
                    const startUTC = parseXMLTVDate(startStr);
                    const stopUTC = parseXMLTVDate(stopStr);
                    
                    // Debug first few programs
                    if (index < 3) {
                        console.log(`Program ${index}:`, prog.querySelector('title')?.textContent);
                        console.log('  Start string:', startStr);
                        console.log('  Start Local:', startUTC.toString());
                        console.log('  Stop string:', stopStr);
                        console.log('  Stop Local:', stopUTC.toString());
                    }
                    
                    const title = prog.querySelector('title')?.textContent || '';
                    const desc = prog.querySelector('desc')?.textContent || '';
                    const category = prog.querySelector('category')?.textContent || '';
                    const ratingValue = prog.querySelector('rating value');
                    const rating = ratingValue ? ratingValue.textContent : '0';
                    const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                    const episodeNum = prog.querySelector('episode-num')?.textContent || '';
                    
                    const program = {
                        start: startUTC,
                        stop: stopUTC,
                        title,
                        desc,
                        category,
                        rating,
                        icon,
                        episodeNum,
                        duration: (stopUTC - startUTC) / 1000, // seconds
                        element: prog
                    };
                    
                    currentPrograms.push(program);
                    
                    // Assign color to format
                    if (!formatColors[title]) {
                        formatColors[title] = colors[colorIndex % colors.length];
                        colorIndex++;
                    }
                } catch (error) {
                    console.error(`Error parsing programme ${index}:`, error);
                }
            });
            
            console.log('Parsed programs:', currentPrograms.length);
            
            if (currentPrograms.length === 0) {
                showToast('Nessun programma trovato nel file', 'error');
                return;
            }
            
            // Sort programs by start time
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Determine the main schedule date
            // Count programs by date
            const dateCounts = {};
            currentPrograms.forEach(p => {
                const dateKey = p.start.toISOString().split('T')[0];
                dateCounts[dateKey] = (dateCounts[dateKey] || 0) + 1;
            });
            
            // Find the date with most programs
            let maxCount = 0;
            let mainDateKey = null;
            Object.entries(dateCounts).forEach(([dateKey, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    mainDateKey = dateKey;
                }
            });
            
            console.log('Date counts:', dateCounts);
            console.log('Main date:', mainDateKey, 'with', maxCount, 'programs');
            
            // Set schedule date
            scheduleDate = new Date(mainDateKey + 'T00:00:00');
            
            // Determine timeline boundaries
            // Start from midnight of the main day
            timelineStartDate = new Date(scheduleDate);
            timelineStartDate.setHours(0, 0, 0, 0);
            
            // End at the stop time of the last program
            const lastProgram = currentPrograms[currentPrograms.length - 1];
            timelineEndDate = new Date(lastProgram.stop);
            
            // If timeline is less than 24 hours, extend to 24 hours
            const timelineHours = (timelineEndDate - timelineStartDate) / (1000 * 60 * 60);
            if (timelineHours < 24) {
                timelineEndDate = new Date(timelineStartDate);
                timelineEndDate.setHours(23, 59, 59, 999);
            }
            
            console.log('Timeline boundaries:', timelineStartDate.toString(), 'to', timelineEndDate.toString());
            
            // Update UI
            document.getElementById('scheduleDate').textContent = formatDate(scheduleDate);
            document.getElementById('programCount').textContent = currentPrograms.length;
            document.getElementById('timelineDate').textContent = 
                `(${formatTime(timelineStartDate)} - ${formatTime(timelineEndDate)})`;
            
            // Load programs
            loadPrograms();
        }

        function parseXMLTVDate(dateStr) {
            // XMLTV format: YYYYMMDDHHmmss +0000
            const year = parseInt(dateStr.substr(0, 4));
            const month = parseInt(dateStr.substr(4, 2)) - 1;
            const day = parseInt(dateStr.substr(6, 2));
            const hour = parseInt(dateStr.substr(8, 2));
            const minute = parseInt(dateStr.substr(10, 2));
            const second = parseInt(dateStr.substr(12, 2));
            
            // Create UTC date
            const utcDate = new Date(Date.UTC(year, month, day, hour, minute, second));
            
            // Return date object (automatically converted to local timezone)
            return utcDate;
        }

        function formatXMLTVDate(date) {
            // Convert local date to UTC for XML format
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getUTCFullYear()}${pad(date.getUTCMonth() + 1)}${pad(date.getUTCDate())}` +
                   `${pad(date.getUTCHours())}${pad(date.getUTCMinutes())}${pad(date.getUTCSeconds())} +0000`;
        }

        function loadPrograms() {
            // Draw timeline with all programs
            drawTimeline(currentPrograms);
            
            // Update table
            updateProgramTable(currentPrograms);
            
            // Update analytics
            updateAnalytics(currentPrograms);
            
            // Check for problems
            checkProblems(currentPrograms);
        }

        function drawTimeline(programs) {
            const container = document.getElementById('timelineContainer');
            const svg = d3.select('#timeline');
            svg.selectAll('*').remove();
            
            const width = container.clientWidth * zoomLevel;
            const height = 150;
            const margin = { top: 20, right: 20, bottom: 30, left: 20 };
            
            svg.attr('width', width).attr('height', height);
            
            // Time scale based on timeline boundaries
            const xScale = d3.scaleTime()
                .domain([timelineStartDate, timelineEndDate])
                .range([margin.left, width - margin.right]);
            
            // Calculate appropriate tick interval based on timeline duration
            const timelineHours = (timelineEndDate - timelineStartDate) / (1000 * 60 * 60);
            let tickInterval;
            if (timelineHours <= 24) {
                tickInterval = d3.timeHour.every(zoomLevel > 2 ? 1 : 2);
            } else {
                tickInterval = d3.timeHour.every(Math.ceil(timelineHours / 24) * (zoomLevel > 2 ? 1 : 2));
            }
            
            // Draw time axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(tickInterval)
                .tickFormat(d => {
                    const hours = d.getHours();
                    const minutes = d.getMinutes();
                    // Show date change indicator
                    if (hours === 0 && minutes === 0 && d > timelineStartDate) {
                        return d3.timeFormat('%d/%m %H:%M')(d);
                    }
                    return d3.timeFormat('%H:%M')(d);
                });
            
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(xAxis);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .ticks(d3.timeHour.every(1))
                    .tickSize(-height + margin.top + margin.bottom)
                    .tickFormat(''))
                .style('stroke-dasharray', '2,2')
                .style('opacity', 0.3);
            
            // Add midnight line if timeline crosses midnight
            const midnights = [];
            const currentMidnight = new Date(timelineStartDate);
            currentMidnight.setHours(24, 0, 0, 0);
            while (currentMidnight < timelineEndDate) {
                midnights.push(new Date(currentMidnight));
                currentMidnight.setDate(currentMidnight.getDate() + 1);
            }
            
            midnights.forEach(midnight => {
                const x = xScale(midnight);
                svg.append('line')
                    .attr('x1', x)
                    .attr('y1', margin.top)
                    .attr('x2', x)
                    .attr('y2', height - margin.bottom)
                    .attr('stroke', '#ef4444')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                svg.append('text')
                    .attr('x', x)
                    .attr('y', margin.top - 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#ef4444')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .text('MEZZANOTTE');
            });
            
            // Group overlapping programs into rows
            const rows = [];
            programs.forEach(program => {
                let placed = false;
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    const row = rows[rowIndex];
                    const fits = !row.some(p => 
                        (program.start < p.stop && program.stop > p.start)
                    );
                    if (fits) {
                        row.push(program);
                        placed = true;
                        program.row = rowIndex;
                        break;
                    }
                }
                if (!placed) {
                    rows.push([program]);
                    program.row = rows.length - 1;
                }
            });
            
            // Adjust SVG height based on number of rows
            const programHeight = 40;
            const rowGap = 5;
            const neededHeight = Math.max(150, margin.top + margin.bottom + (rows.length * (programHeight + rowGap)) + 20);
            svg.attr('height', neededHeight);
            
            // Re-draw axis at new position
            svg.select('g').remove();
            svg.append('g')
                .attr('transform', `translate(0,${neededHeight - margin.bottom})`)
                .call(xAxis);
            
            // Draw programs
            const baseY = margin.top + 10;
            
            programs.forEach((program, index) => {
                const x = xScale(program.start);
                const width = Math.max(1, xScale(program.stop) - x);
                const y = baseY + (program.row || 0) * (programHeight + rowGap);
                
                const g = svg.append('g')
                    .attr('class', 'program-block')
                    .attr('transform', `translate(${x},${y})`)
                    .style('cursor', 'pointer')
                    .on('click', () => showProgramDetails(program))
                    .on('mouseenter', (event) => showTooltip(event, program))
                    .on('mouseleave', hideTooltip);
                
                // Check for overlaps
                const hasOverlap = programs.some((p, i) => 
                    i !== index && p.start < program.stop && p.stop > program.start
                );
                
                // Program block
                g.append('rect')
                    .attr('width', width)
                    .attr('height', programHeight)
                    .attr('rx', 4)
                    .attr('fill', formatColors[program.title] || '#6B7280')
                    .attr('stroke', hasOverlap ? '#ff0000' : '#fff')
                    .attr('stroke-width', hasOverlap ? 3 : 1);
                
                // Program title
                if (width > 30) {
                    g.append('text')
                        .attr('x', 5)
                        .attr('y', programHeight / 2 - 5)
                        .attr('dy', '.35em')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text(program.title)
                        .each(function() {
                            const self = d3.select(this);
                            let textLength = self.node().getComputedTextLength();
                            let text = self.text();
                            while (textLength > width - 10 && text.length > 0) {
                                text = text.slice(0, -1);
                                self.text(text + '...');
                                textLength = self.node().getComputedTextLength();
                            }
                        });
                    
                    // Add time label
                    if (width > 60) {
                        g.append('text')
                            .attr('x', 5)
                            .attr('y', programHeight - 5)
                            .attr('fill', 'white')
                            .attr('font-size', '10px')
                            .text(`${formatTime(program.start)} - ${formatTime(program.stop)}`);
                    }
                }
                
                // Warning icon for overlaps
                if (hasOverlap && width > 20) {
                    g.append('text')
                        .attr('x', width - 15)
                        .attr('y', programHeight / 2)
                        .attr('dy', '.35em')
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '14px')
                        .text('âš ï¸');
                }
            });
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            let lastEnd = null;
            
            sortedPrograms.forEach(program => {
                if (lastEnd && program.start > lastEnd) {
                    const gap = program.start - lastEnd;
                    if (gap > 60000) { // More than 1 minute
                        const x = xScale(lastEnd);
                        const width = xScale(program.start) - x;
                        
                        svg.append('rect')
                            .attr('x', x)
                            .attr('y', baseY)
                            .attr('width', width)
                            .attr('height', programHeight)
                            .attr('class', 'gap-indicator')
                            .attr('opacity', 0.5);
                        
                        // Add gap duration text
                        const gapMinutes = Math.floor(gap / 60000);
                        if (width > 40) {
                            svg.append('text')
                                .attr('x', x + width/2)
                                .attr('y', baseY + programHeight/2)
                                .attr('text-anchor', 'middle')
                                .attr('dy', '.35em')
                                .attr('fill', 'white')
                                .attr('font-weight', 'bold')
                                .attr('font-size', '12px')
                                .text(`GAP ${gapMinutes}min`);
                        }
                    }
                }
                
                if (!lastEnd || program.stop > lastEnd) {
                    lastEnd = program.stop;
                }
            });
        }

        // Tooltip functions
        let currentTooltipTimeout = null;
        
        function showTooltip(event, program) {
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
            }
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="font-semibold">${program.title}</div>
                <div class="text-xs">${formatTime(program.start)} - ${formatTime(program.stop)}</div>
                <div class="text-xs">Durata: ${formatDuration(program.duration)}</div>
                ${program.category ? `<div class="text-xs">Categoria: ${program.category}</div>` : ''}
            `;
            
            currentTooltipTimeout = setTimeout(() => {
                const [mouseX, mouseY] = d3.pointer(event, document.body);
                tooltip.style.left = (mouseX + 10) + 'px';
                tooltip.style.top = (mouseY - 40) + 'px';
                tooltip.classList.remove('hidden');
            }, 200);
        }

        function hideTooltip() {
            if (currentTooltipTimeout) {
                clearTimeout(currentTooltipTimeout);
                currentTooltipTimeout = null;
            }
            document.getElementById('tooltip').classList.add('hidden');
        }

        function showProgramDetails(program) {
            document.getElementById('programDetails').style.display = 'block';
            document.getElementById('detailTitle').textContent = program.title;
            document.getElementById('detailFormat').textContent = program.title;
            document.getElementById('detailTime').textContent = `${formatTime(program.start)} - ${formatTime(program.stop)}`;
            document.getElementById('detailDuration').textContent = formatDuration(program.duration);
            document.getElementById('detailCategory').textContent = program.category || '-';
            document.getElementById('detailRating').textContent = program.rating || '0';
            document.getElementById('detailDescription').textContent = program.desc || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (program.icon) {
                iconDiv.style.backgroundImage = `url(${program.icon})`;
                iconUrl.textContent = program.icon;
            } else {
                iconDiv.style.backgroundImage = 'none';
                iconDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400">Nessuna icona</div>';
                iconUrl.textContent = 'Nessuna icona specificata';
            }
            
            document.getElementById('programDetails').scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                
                row.innerHTML = `
                    <td class="px-4 py-2">
                        <input type="time" value="${program.start.toTimeString().substr(0, 5)}" 
                               onchange="updateProgramTime(${index}, 'start', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">
                        <input type="time" value="${program.stop.toTimeString().substr(0, 5)}" 
                               onchange="updateProgramTime(${index}, 'stop', this.value)"
                               class="px-2 py-1 border rounded">
                    </td>
                    <td class="px-4 py-2">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'title')">${program.title}</td>
                    <td class="px-4 py-2 editable-cell" onclick="editCell(this, ${index}, 'category')">${program.category || '-'}</td>
                    <td class="px-4 py-2">
                        <div class="w-16 h-9 bg-gray-200 rounded" 
                             style="background-image: url(${program.icon}); background-size: cover;">
                        </div>
                    </td>
                    <td class="px-4 py-2">
                        <button onclick="deleteProgram(${index})" class="text-red-500 hover:text-red-700" title="Elimina">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function updateAnalytics(programs) {
            const formatCounts = {};
            programs.forEach(p => {
                formatCounts[p.title] = (formatCounts[p.title] || 0) + p.duration;
            });
            
            const ctx = document.getElementById('formatChart').getContext('2d');
            
            if (window.formatChart && typeof window.formatChart.destroy === 'function') {
                window.formatChart.destroy();
            }
            
            window.formatChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(formatCounts),
                    datasets: [{
                        data: Object.values(formatCounts).map(s => s / 3600),
                        backgroundColor: Object.keys(formatCounts).map(f => formatColors[f] || '#6B7280')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.parsed.toFixed(1) + ' ore';
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkProblems(programs) {
            const report = document.getElementById('problemsReport');
            report.innerHTML = '';
            const problems = [];
            
            // Check for overlaps
            for (let i = 0; i < programs.length; i++) {
                for (let j = i + 1; j < programs.length; j++) {
                    if (programs[i].stop > programs[j].start && programs[i].start < programs[j].stop) {
                        const overlapStart = Math.max(programs[i].start, programs[j].start);
                        const overlapEnd = Math.min(programs[i].stop, programs[j].stop);
                        const overlapMinutes = Math.floor((overlapEnd - overlapStart) / 60000);
                        
                        problems.push({
                            type: 'overlap',
                            severity: 'error',
                            message: `Sovrapposizione di ${overlapMinutes} minuti tra "${programs[i].title}" e "${programs[j].title}"`
                        });
                    }
                }
            }
            
            // Check for gaps
            const sortedPrograms = [...programs].sort((a, b) => a.start - b.start);
            for (let i = 0; i < sortedPrograms.length - 1; i++) {
                let nextNonOverlapping = null;
                for (let j = i + 1; j < sortedPrograms.length; j++) {
                    if (sortedPrograms[j].start >= sortedPrograms[i].stop) {
                        nextNonOverlapping = sortedPrograms[j];
                        break;
                    }
                }
                
                if (nextNonOverlapping) {
                    const gap = nextNonOverlapping.start - sortedPrograms[i].stop;
                    if (gap > 60000) {
                        const gapMinutes = Math.floor(gap / 60000);
                        problems.push({
                            type: 'gap',
                            severity: gapMinutes > 30 ? 'error' : 'warning',
                            message: `Buco di ${gapMinutes} minuti dopo "${sortedPrograms[i].title}"`
                        });
                    }
                }
            }
            
            // Check for missing icons
            const missingIcons = programs.filter(p => 
                !p.icon || p.icon.includes('placeholder') || p.icon.includes('default.jpg')
            ).length;
            
            if (missingIcons > 0) {
                problems.push({
                    type: 'icon',
                    severity: 'info',
                    message: `${missingIcons} programmi con icone mancanti o default`
                });
            }
            
            // Display problems
            if (problems.length === 0) {
                report.innerHTML = '<p class="text-green-600">âœ… Nessun problema rilevato</p>';
            } else {
                problems.forEach(problem => {
                    const div = document.createElement('div');
                    div.className = `p-2 rounded text-sm mb-1 ${
                        problem.severity === 'error' ? 'bg-red-50 text-red-700' :
                        problem.severity === 'warning' ? 'bg-yellow-50 text-yellow-700' :
                        'bg-blue-50 text-blue-700'
                    }`;
                    div.textContent = problem.message;
                    report.appendChild(div);
                });
            }
        }

        // Utility functions
        function formatDate(date) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        function formatTime(date) {
            return date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}min`;
            } else {
                return `${minutes}min`;
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast p-4 rounded-lg shadow-lg ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            loadPrograms();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.5);
            loadPrograms();
        }

        function resetZoom() {
            zoomLevel = 1;
            loadPrograms();
        }

        // Mouse wheel zoom
        document.getElementById('timelineContainer').addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Edit functions
        function editCell(cell, programIndex, field) {
            const currentValue = cell.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '-' ? '' : currentValue;
            input.className = 'w-full px-2 py-1 border rounded';
            
            input.onblur = () => {
                const newValue = input.value.trim();
                cell.textContent = newValue || '-';
                
                const program = currentPrograms[programIndex];
                if (program) {
                    program[field] = newValue;
                    
                    // Update XML
                    const elem = program.element.querySelector(field);
                    if (elem) {
                        elem.textContent = newValue;
                    } else if (field === 'category' && newValue) {
                        const catElem = xmlDoc.createElement('category');
                        catElem.setAttribute('lang', 'it');
                        catElem.textContent = newValue;
                        program.element.appendChild(catElem);
                    }
                    
                    // Reload if title changed
                    if (field === 'title') {
                        if (!formatColors[newValue]) {
                            formatColors[newValue] = formatColors[program.title] || colors[colorIndex % colors.length];
                            colorIndex++;
                        }
                        loadPrograms();
                    }
                }
            };
            
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    cell.textContent = currentValue;
                }
            };
            
            cell.textContent = '';
            cell.appendChild(input);
            input.focus();
            input.select();
        }

        function updateProgramTime(programIndex, timeType, newTime) {
            const program = currentPrograms[programIndex];
            if (!program) return;
            
            const [hours, minutes] = newTime.split(':').map(Number);
            const newDate = new Date(program[timeType === 'start' ? 'start' : 'stop']);
            newDate.setHours(hours, minutes, 0, 0);
            
            // If the time crosses midnight, adjust the date
            if (timeType === 'stop' && newDate < program.start) {
                newDate.setDate(newDate.getDate() + 1);
            }
            
            if (timeType === 'start') {
                program.start = newDate;
                program.element.setAttribute('start', formatXMLTVDate(newDate));
            } else {
                program.stop = newDate;
                program.element.setAttribute('stop', formatXMLTVDate(newDate));
            }
            
            program.duration = (program.stop - program.start) / 1000;
            
            loadPrograms();
            showToast('Orario aggiornato', 'success');
        }

        function deleteProgram(programIndex) {
            if (!confirm('Eliminare questo programma?')) return;
            
            const program = currentPrograms[programIndex];
            if (!program) return;
            
            // Remove from XML
            program.element.remove();
            
            // Remove from array
            currentPrograms.splice(programIndex, 1);
            
            loadPrograms();
            showToast('Programma eliminato', 'success');
        }

        function addProgram() {
            // Find last program
            const lastProgram = currentPrograms[currentPrograms.length - 1];
            const newStart = lastProgram ? new Date(lastProgram.stop) : new Date(scheduleDate);
            if (!lastProgram) {
                newStart.setHours(20, 0, 0, 0);
            }
            
            const newStop = new Date(newStart);
            newStop.setMinutes(newStop.getMinutes() + 30);
            
            // Create new program element
            const programme = xmlDoc.createElement('programme');
            programme.setAttribute('start', formatXMLTVDate(newStart));
            programme.setAttribute('stop', formatXMLTVDate(newStop));
            programme.setAttribute('channel', currentChannelId);
            
            const title = xmlDoc.createElement('title');
            title.setAttribute('lang', 'it');
            title.textContent = 'Nuovo Programma';
            programme.appendChild(title);
            
            const desc = xmlDoc.createElement('desc');
            desc.setAttribute('lang', 'it');
            desc.textContent = 'Descrizione del nuovo programma';
            programme.appendChild(desc);
            
            const rating = xmlDoc.createElement('rating');
            rating.setAttribute('system', 'Italy Parental Rating');
            const value = xmlDoc.createElement('value');
            value.textContent = '0';
            rating.appendChild(value);
            programme.appendChild(rating);
            
            // Add to XML
            xmlDoc.querySelector('tv').appendChild(programme);
            
            // Add to programs array
            const newProgram = {
                start: newStart,
                stop: newStop,
                title: 'Nuovo Programma',
                desc: 'Descrizione del nuovo programma',
                category: '',
                rating: '0',
                icon: '',
                episodeNum: '',
                duration: 1800,
                element: programme
            };
            
            currentPrograms.push(newProgram);
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Assign color
            if (!formatColors[newProgram.title]) {
                formatColors[newProgram.title] = colors[colorIndex % colors.length];
                colorIndex++;
            }
            
            loadPrograms();
            showToast('Nuovo programma aggiunto', 'success');
        }

        // Actualization functions
        function showActualizationDialog() {
            document.getElementById('actualizationDialog').classList.remove('hidden');
            document.getElementById('newStartDate').value = scheduleDate.toISOString().split('T')[0];
        }

        function closeActualizationDialog() {
            document.getElementById('actualizationDialog').classList.add('hidden');
        }

        function actualizeSchedule() {
            const newStartDate = new Date(document.getElementById('newStartDate').value);
            const oldStartDate = scheduleDate;
            const dayDiff = Math.floor((newStartDate - oldStartDate) / (1000 * 60 * 60 * 24));
            
            if (dayDiff === 0) {
                showToast('La data selezionata Ã¨ la stessa', 'info');
                closeActualizationDialog();
                return;
            }
            
            // Update all program dates
            currentPrograms.forEach(program => {
                const newStart = new Date(program.start);
                newStart.setDate(newStart.getDate() + dayDiff);
                const newStop = new Date(program.stop);
                newStop.setDate(newStop.getDate() + dayDiff);
                
                program.start = newStart;
                program.stop = newStop;
                
                program.element.setAttribute('start', formatXMLTVDate(newStart));
                program.element.setAttribute('stop', formatXMLTVDate(newStop));
            });
            
            // Update tv date attribute
            xmlDoc.querySelector('tv').setAttribute('date', newStartDate.toISOString().split('T')[0]);
            
            // Update schedule date
            scheduleDate = newStartDate;
            
            // Update timeline boundaries
            timelineStartDate = new Date(scheduleDate);
            timelineStartDate.setHours(0, 0, 0, 0);
            
            const lastProgram = currentPrograms[currentPrograms.length - 1];
            timelineEndDate = new Date(lastProgram.stop);
            
            const timelineHours = (timelineEndDate - timelineStartDate) / (1000 * 60 * 60);
            if (timelineHours < 24) {
                timelineEndDate = new Date(timelineStartDate);
                timelineEndDate.setHours(23, 59, 59, 999);
            }
            
            // Update UI
            document.getElementById('scheduleDate').textContent = formatDate(scheduleDate);
            document.getElementById('timelineDate').textContent = 
                `(${formatTime(timelineStartDate)} - ${formatTime(timelineEndDate)})`;
            
            // Reload programs
            loadPrograms();
            
            closeActualizationDialog();
            showToast('Date attualizzate con successo', 'success');
        }

        // Export function
        function exportXMLTV() {
            const serializer = new XMLSerializer();
            const xmlString = serializer.serializeToString(xmlDoc);
            const blob = new Blob([xmlString], { type: 'application/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `${currentChannelId}_edited_${date}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            showToast('File esportato con successo', 'success');
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            localStorage.setItem('darkMode', document.body.classList.contains('dark'));
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark');
        }

        // Show info
        function showInfo() {
            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const utcOffset = new Date().getTimezoneOffset() / -60;
            const offsetStr = utcOffset >= 0 ? `+${utcOffset}` : `${utcOffset}`;
            
            alert(`XMLTV Viewer & Editor Pro v${APP_VERSION}\n\nFunzionalitÃ :\n- Visualizzazione timeline singolo giorno\n- Conversione automatica UTC â†’ fuso orario locale\n- Gestione programmi che attraversano la mezzanotte\n- Modifica programmi inline\n- Rilevamento sovrapposizioni e buchi\n- Attualizzazione date palinsesto\n- Analisi distribuzione format\n- Export XMLTV modificato\n\nFuso orario rilevato: ${userTimezone} (UTC${offsetStr})\n\nSviluppato per Class CNBC e Class TV Moda`);
        }
    </script>
</body>
</html>
