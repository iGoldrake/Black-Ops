<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLTV Viewer v5.0 - Analisi Fasce Orarie</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* Treemap Timeline Styles */
        .treemap-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            aspect-ratio: 1;
            background: #ffffff;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 
                inset 0 0 0 2px rgba(0, 0, 0, 0.1),
                0 20px 60px rgba(0, 0, 0, 0.1);
        }

        .treemap-program {
            position: absolute;
            border: 3px solid white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .treemap-program:hover {
            transform: scale(1.05);
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .treemap-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }

        .treemap-label {
            position: relative;
            z-index: 2;
            color: white;
            font-weight: 600;
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.75);
            border-radius: 6px;
            font-size: clamp(11px, 1.5vw, 15px);
            max-width: 90%;
            white-space: normal;
            word-wrap: break-word;
            backdrop-filter: blur(4px);
            line-height: 1.3;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Program preview tooltip */
        .program-preview {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            backdrop-filter: blur(20px);
            color: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            max-width: 350px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .program-preview.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .preview-icon {
            width: 80px;
            height: 45px;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Statistics Cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
        }

        /* Coverage Ring */
        .coverage-ring {
            transform: rotate(-90deg);
            transition: stroke-dasharray 0.5s ease;
        }

        /* Time slot badge */
        .time-slot-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .time-slot-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .prime-time-badge {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .treemap-program.new {
            animation: fadeIn 0.6s ease-out;
        }

        /* Dark mode */
        .dark .treemap-container {
            background: #0f172a;
            box-shadow: 
                inset 0 0 40px rgba(0, 0, 0, 0.5),
                0 20px 60px rgba(0, 0, 0, 0.7);
        }

        .dark .treemap-program {
            border-color: #1e293b;
        }

        .dark .treemap-label {
            background: rgba(0, 0, 0, 0.85);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .dark .stat-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
            border-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }

        .dark .stat-card h3 {
            color: #cbd5e1;
        }

        .dark .stat-card p {
            color: #f1f5f9;
        }

        .dark .time-analysis-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .dark .time-slot-card {
            background: rgba(30, 41, 59, 0.5);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .dark .format-legend {
            background: rgba(15, 23, 42, 0.5);
            border-color: rgba(255, 255, 255, 0.05);
        }

        .dark .format-item {
            background: rgba(30, 41, 59, 0.8);
            border-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }

        /* Toast */
        .toast {
            animation: slideInRight 0.3s ease-out;
            backdrop-filter: blur(10px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #1e293b;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        .toast.success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.95) 100%);
            color: white;
        }

        .toast.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.95) 0%, rgba(220, 38, 38, 0.95) 100%);
            color: white;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        /* Gradient text */
        .gradient-text {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Format legend */
        .format-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .format-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: white;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0, 0, 0, 0.06);
            transition: all 0.2s;
            color: #1e293b;
        }

        .format-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .format-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Layout selector */
        .layout-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .layout-btn {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            background: white;
            border: 2px solid #d1d5db;
            cursor: pointer;
            transition: all 0.2s;
            color: #374151;
        }

        .layout-btn:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #1e40af;
        }

        .layout-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        /* Fill percentage indicator */
        .fill-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(15, 23, 42, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            backdrop-filter: blur(8px);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .fill-indicator.complete {
            background: rgba(34, 197, 94, 0.9);
        }

        .fill-indicator.warning {
            background: rgba(245, 158, 11, 0.9);
        }

        .fill-indicator.error {
            background: rgba(239, 68, 68, 0.9);
        }

        /* Time Analysis Styles */
        .time-analysis-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.98) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
        }

        .time-slot-card {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s;
        }

        .time-slot-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: rgba(59, 130, 246, 0.2);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-4xl font-bold gradient-text flex items-center gap-3">
                        <i data-lucide="tv" class="w-10 h-10 text-blue-600"></i>
                        XMLTV Viewer v5.0
                    </h1>
                    <p class="text-gray-600 mt-2">Treemap Sequenziale con Analisi Fasce Orarie - Modalità UTC</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleDarkMode()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Dark Mode">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <button onclick="showInfo()" class="p-3 rounded-lg hover:bg-gray-100 transition-colors" title="Informazioni">
                        <i data-lucide="info" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-8 mb-6 border border-white/50">
            <div class="border-3 border-dashed border-gray-300 rounded-xl p-12 text-center hover:border-blue-500 transition-all duration-300 hover:bg-blue-50/50" id="dropZone">
                <i data-lucide="upload-cloud" class="w-16 h-16 mx-auto text-gray-400 mb-4"></i>
                <p class="text-xl mb-2 font-semibold text-gray-700">Trascina qui il file XMLTV</p>
                <p class="text-gray-500 mb-4">oppure</p>
                <input type="file" id="fileInput" accept=".xml" class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-8 py-3 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105">
                    Seleziona File
                </button>
            </div>
        </div>

        <!-- Main Content (hidden until file loaded) -->
        <div id="mainContent" class="hidden">
            <!-- Channel Info & Stats -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-800 mb-1 flex items-center gap-2">
                            <i data-lucide="tv-2" class="w-4 h-4 text-blue-600"></i>
                            Canale
                        </h3>
                        <p class="text-2xl font-bold text-gray-900" id="channelName">-</p>
                        <p class="text-sm text-gray-600" id="channelId">-</p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-800 mb-1 flex items-center gap-2">
                            <i data-lucide="calendar" class="w-4 h-4 text-blue-600"></i>
                            Data Palinsesto
                        </h3>
                        <p class="text-2xl font-bold text-gray-900" id="scheduleDate">-</p>
                        <p class="text-sm text-gray-600">
                            <span id="programCount">-</span> programmi
                        </p>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-800 mb-1 flex items-center gap-2">
                            <i data-lucide="pie-chart" class="w-4 h-4 text-blue-600"></i>
                            Copertura
                        </h3>
                        <div class="flex items-center gap-3">
                            <svg width="50" height="50" viewBox="0 0 50 50">
                                <circle cx="25" cy="25" r="20" fill="none" stroke="#e5e7eb" stroke-width="8"/>
                                <circle cx="25" cy="25" r="20" fill="none" stroke="url(#coverageGradient)" stroke-width="8" 
                                    stroke-dasharray="126" stroke-dashoffset="126" class="coverage-ring" id="coverageRing"/>
                                <defs>
                                    <linearGradient id="coverageGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#3b82f6"/>
                                        <stop offset="100%" style="stop-color:#8b5cf6"/>
                                    </linearGradient>
                                </defs>
                            </svg>
                            <div>
                                <p class="text-2xl font-bold text-gray-900" id="coveragePercent">0%</p>
                                <p class="text-sm text-gray-600" id="coverageTime">0h 0m</p>
                            </div>
                        </div>
                    </div>
                    <div class="stat-card rounded-xl p-4">
                        <h3 class="font-semibold text-gray-800 mb-1 flex items-center gap-2">
                            <i data-lucide="activity" class="w-4 h-4 text-blue-600"></i>
                            Statistiche
                        </h3>
                        <div class="space-y-1">
                            <p class="text-sm text-gray-700"><span class="font-semibold text-gray-900" id="gapCount">0</span> gaps</p>
                            <p class="text-sm text-gray-700"><span class="font-semibold text-gray-900" id="formatCount">0</span> format unici</p>
                            <p class="text-sm text-gray-700"><span class="font-semibold text-gray-900" id="avgDuration">0m</span> durata media</p>
                        </div>
                    </div>
                </div>
                
                <!-- Actions -->
                <div class="flex justify-center gap-3 mt-6">
                    <button onclick="showActualizationDialog()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-6 py-2.5 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="calendar-days" class="w-4 h-4"></i>
                        Attualizza Date
                    </button>
                    <button onclick="exportXMLTV()" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        Esporta XMLTV
                    </button>
                </div>
            </div>

            <!-- Time Slot Analysis -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50 time-analysis-card">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="clock-3" class="w-6 h-6 text-blue-600"></i>
                        Analisi Fasce Orarie
                    </span>
                    <div class="flex gap-2">
                        <span class="time-slot-badge prime-time-badge">
                            <i data-lucide="star" class="w-3 h-3"></i>
                            Prime Time
                        </span>
                    </div>
                </h3>
                
                <!-- Time Slots Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Morning Slot -->
                    <div class="time-slot-card rounded-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="sunrise" class="w-4 h-4 text-blue-500"></i>
                                Mattina
                            </h4>
                            <span class="text-sm text-gray-600">06:00 - 12:00</span>
                        </div>
                        <div id="morningStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="morningCoverage" class="h-full bg-blue-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Afternoon Slot -->
                    <div class="time-slot-card rounded-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="sun" class="w-4 h-4 text-green-500"></i>
                                Pomeriggio
                            </h4>
                            <span class="text-sm text-gray-600">12:00 - 18:00</span>
                        </div>
                        <div id="afternoonStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="afternoonCoverage" class="h-full bg-green-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Evening Slot -->
                    <div class="time-slot-card rounded-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="sunset" class="w-4 h-4 text-purple-500"></i>
                                Sera
                            </h4>
                            <span class="text-sm text-gray-600">18:00 - 20:30</span>
                        </div>
                        <div id="eveningStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="eveningCoverage" class="h-full bg-purple-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Prime Time Slot -->
                    <div class="time-slot-card rounded-xl p-4 border-2 border-amber-400 bg-gradient-to-br from-amber-50 to-orange-50">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="star" class="w-4 h-4 text-amber-600"></i>
                                Prime Time
                            </h4>
                            <span class="text-sm text-gray-600 font-semibold">20:30 - 22:30</span>
                        </div>
                        <div id="primeTimeStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="primeTimeCoverage" class="h-full bg-gradient-to-r from-amber-500 to-orange-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Late Evening Slot -->
                    <div class="time-slot-card rounded-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="moon" class="w-4 h-4 text-indigo-500"></i>
                                Seconda Serata
                            </h4>
                            <span class="text-sm text-gray-600">22:30 - 01:00</span>
                        </div>
                        <div id="lateEveningStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="lateEveningCoverage" class="h-full bg-indigo-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Night Slot -->
                    <div class="time-slot-card rounded-xl p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-800 flex items-center gap-2">
                                <i data-lucide="moon-star" class="w-4 h-4 text-gray-600"></i>
                                Notte
                            </h4>
                            <span class="text-sm text-gray-600">01:00 - 06:00</span>
                        </div>
                        <div id="nightStats" class="space-y-2">
                            <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">-</span></p>
                            <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">-</span></p>
                            <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div id="nightCoverage" class="h-full bg-gray-600 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Treemap Timeline -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="grid-3x3" class="w-6 h-6 text-blue-600"></i>
                        Treemap Aggregato per Format
                    </span>
                    <div class="layout-selector">
                        <span class="text-sm font-normal text-gray-700 mr-3">Layout:</span>
                        <button class="layout-btn active" onclick="setLayout('squarify')" data-layout="squarify">Squarify</button>
                        <button class="layout-btn" onclick="setLayout('binary')" data-layout="binary">Binary</button>
                        <button class="layout-btn" onclick="setLayout('slice')" data-layout="slice">Slice & Dice</button>
                    </div>
                </h3>
                
                <div class="treemap-container" id="treemapContainer">
                    <div class="fill-indicator" id="fillIndicator">
                        <span id="fillPercent">0%</span> riempito
                    </div>
                </div>
                
                <!-- Format Legend -->
                <div class="mt-6">
                    <h4 class="font-semibold text-gray-800 mb-2">Riepilogo Format</h4>
                    <div class="format-legend" id="formatLegend"></div>
                </div>
            </div>

            <!-- Program Details -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50" id="programDetails" style="display:none;">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="tv-2" class="w-6 h-6 text-blue-600"></i>
                    Dettagli Programma
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <p class="text-sm text-gray-700 mb-1">Titolo/Format</p>
                        <p class="font-semibold text-lg text-gray-900" id="detailTitle">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-700 mb-1">Orario UTC</p>
                        <p class="font-semibold text-lg text-gray-900" id="detailTime">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-700 mb-1">Durata</p>
                        <p class="font-semibold text-lg text-gray-900" id="detailDuration">-</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-700 mb-1">Categoria</p>
                        <p class="font-semibold text-lg text-gray-900" id="detailCategory">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-700 mb-1">Descrizione</p>
                        <p class="font-semibold text-gray-900" id="detailDescription">-</p>
                    </div>
                    <div class="md:col-span-2">
                        <p class="text-sm text-gray-700 mb-1">Icona</p>
                        <div class="flex items-center gap-4 mt-2">
                            <div class="w-32 h-18 bg-gray-200 rounded-lg overflow-hidden" id="detailIcon" style="background-size: cover; background-position: center;"></div>
                            <p class="text-xs text-gray-500 break-all" id="detailIconUrl">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Editor Table -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-6 flex items-center justify-between">
                    <span class="flex items-center gap-2">
                        <i data-lucide="edit-3" class="w-6 h-6 text-blue-600"></i>
                        Editor Programmi
                    </span>
                    <button onclick="addProgram()" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white px-4 py-2 rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 text-sm flex items-center gap-2 shadow-lg hover:shadow-xl transform hover:scale-105">
                        <i data-lucide="plus-circle" class="w-4 h-4"></i>
                        Aggiungi Programma
                    </button>
                </h3>
                <div class="overflow-x-auto rounded-lg border border-gray-200">
                    <table class="w-full text-sm">
                        <thead class="bg-gradient-to-r from-gray-100 to-gray-50 border-b border-gray-200">
                            <tr>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Ora Inizio UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Ora Fine UTC</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Durata</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Titolo/Format</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Categoria</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-800">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="programTable" class="divide-y divide-gray-200"></tbody>
                    </table>
                </div>
            </div>

            <!-- Problems Report -->
            <div class="bg-white/90 backdrop-blur-md rounded-2xl shadow-xl p-6 mb-6 border border-white/50">
                <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                    <i data-lucide="alert-triangle" class="w-6 h-6 text-orange-600"></i>
                    Report Problemi
                </h3>
                <div id="problemsReport" class="space-y-2"></div>
            </div>
        </div>

        <!-- Actualization Dialog -->
        <div id="actualizationDialog" class="fixed inset-0 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-2xl p-8 max-w-md w-full shadow-2xl transform transition-all">
                <h3 class="text-2xl font-bold mb-4 gradient-text">Attualizza Date Palinsesto</h3>
                <p class="text-gray-600 mb-6">Seleziona la nuova data di inizio. Gli orari rimarranno invariati.</p>
                <input type="date" id="newStartDate" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none transition-colors">
                <div class="flex justify-end gap-3 mt-6">
                    <button onclick="closeActualizationDialog()" class="px-6 py-2.5 border-2 border-gray-300 rounded-lg hover:bg-gray-50 transition-colors font-semibold">
                        Annulla
                    </button>
                    <button onclick="actualizeSchedule()" class="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-2.5 rounded-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl">
                        Attualizza
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-3"></div>

        <!-- Program Preview -->
        <div id="programPreview" class="program-preview">
            <div class="preview-icon" id="previewIcon"></div>
            <h4 class="font-bold text-xl mb-3" id="previewTitle"></h4>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                    <span class="text-gray-400">Orario UTC:</span>
                    <span class="font-semibold" id="previewTime"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Durata:</span>
                    <span class="font-semibold" id="previewDuration"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Categoria:</span>
                    <span class="font-semibold" id="previewCategory"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Posizione:</span>
                    <span class="font-semibold" id="previewPosition"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Area:</span>
                    <span class="font-semibold" id="previewArea"></span>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-4 italic" id="previewDesc"></p>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        window.addEventListener('DOMContentLoaded', function() {
            lucide.createIcons();
        });

        // Version
        const APP_VERSION = '5.0';
        console.log(`XMLTV Viewer v${APP_VERSION} - Ottimizzato`);

        // Global state
        let xmlDoc = null;
        let currentPrograms = [];
        let currentChannelId = '';
        let currentChannelName = '';
        let scheduleDate = null;
        let formatColors = {};
        let colorIndex = 0;
        let totalDaySeconds = 86400; // 24 hours in seconds
        let currentLayout = 'squarify';

        // Modern color palette
        const colorPalette = [
            '#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', 
            '#10b981', '#06b6d4', '#6366f1', '#f43f5e',
            '#84cc16', '#a855f7', '#0ea5e9', '#f97316',
            '#14b8a6', '#d946ef', '#0891b2', '#dc2626'
        ];

        // Time slot definitions (in UTC hours)
        const timeSlots = {
            morning: { start: 6, end: 12, name: 'Mattina', icon: 'sunrise' },
            afternoon: { start: 12, end: 18, name: 'Pomeriggio', icon: 'sun' },
            evening: { start: 18, end: 20.5, name: 'Sera', icon: 'sunset' },
            primeTime: { start: 20.5, end: 22.5, name: 'Prime Time', icon: 'star' },
            lateEvening: { start: 22.5, end: 25, name: 'Seconda Serata', icon: 'moon' }, // 25 = 1:00 next day
            night: { start: 1, end: 6, name: 'Notte', icon: 'moon-star' }
        };

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('border-blue-500', 'bg-blue-50');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            }, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const files = e.dataTransfer.files;
            handleFiles(files);
        }

        fileInput.addEventListener('change', function(e) {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/xml' || file.type === 'application/xml' || file.name.endsWith('.xml')) {
                    loadFile(file);
                } else {
                    showToast('Seleziona un file XML valido', 'error');
                }
            }
        }

        function loadFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const parser = new DOMParser();
                    xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.getElementsByTagName('parsererror');
                    if (parserError.length > 0) {
                        throw new Error('Errore nel parsing XML');
                    }
                    
                    // Parse channel info
                    const channel = xmlDoc.querySelector('channel');
                    if (!channel) {
                        throw new Error('Nessun canale trovato nel file XML');
                    }
                    
                    currentChannelId = channel.getAttribute('id');
                    const displayName = channel.querySelector('display-name');
                    currentChannelName = displayName ? displayName.textContent : currentChannelId;
                    
                    document.getElementById('channelName').textContent = currentChannelName;
                    document.getElementById('channelId').textContent = `ID: ${currentChannelId}`;
                    
                    // Parse programs
                    parsePrograms();
                    
                    // Show main content
                    document.getElementById('mainContent').classList.remove('hidden');
                    
                    showToast('File caricato con successo', 'success');
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('Errore nel caricamento del file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }

        function parsePrograms() {
            const programmes = xmlDoc.querySelectorAll('programme');
            currentPrograms = [];
            
            programmes.forEach((prog) => {
                const startStr = prog.getAttribute('start');
                const stopStr = prog.getAttribute('stop');
                
                if (!startStr || !stopStr) return;
                
                const startUTC = parseXMLTVDateUTC(startStr);
                const stopUTC = parseXMLTVDateUTC(stopStr);
                
                const title = prog.querySelector('title')?.textContent || '';
                const desc = prog.querySelector('desc')?.textContent || '';
                const category = prog.querySelector('category')?.textContent || '';
                const ratingValue = prog.querySelector('rating value');
                const rating = ratingValue ? ratingValue.textContent : '0';
                const icon = prog.querySelector('icon')?.getAttribute('src') || '';
                
                const program = {
                    start: startUTC,
                    stop: stopUTC,
                    title,
                    desc,
                    category,
                    rating,
                    icon,
                    duration: (stopUTC - startUTC) / 1000, // seconds
                    element: prog
                };
                
                currentPrograms.push(program);
                
                // Assign color to format
                if (!formatColors[title]) {
                    formatColors[title] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
            });
            
            if (currentPrograms.length === 0) {
                showToast('Nessun programma trovato nel file', 'error');
                return;
            }
            
            // Sort programs by start time
            currentPrograms.sort((a, b) => a.start - b.start);
            
            // Auto-detect the main programming day
            detectMainProgrammingDay();
            
            // Load programs
            loadPrograms();
        }

        function detectMainProgrammingDay() {
            // Count programs per day
            const programsByDay = {};
            
            currentPrograms.forEach(program => {
                const dayKey = program.start.toISOString().split('T')[0];
                if (!programsByDay[dayKey]) {
                    programsByDay[dayKey] = [];
                }
                programsByDay[dayKey].push(program);
            });
            
            // Find the day with most programs
            let maxPrograms = 0;
            let bestDay = null;
            
            Object.entries(programsByDay).forEach(([day, programs]) => {
                if (programs.length > maxPrograms) {
                    maxPrograms = programs.length;
                    bestDay = day;
                }
            });
            
            // Set schedule date
            if (bestDay) {
                const [year, month, day] = bestDay.split('-').map(Number);
                scheduleDate = new Date(Date.UTC(year, month - 1, day, 0, 0, 0));
            } else {
                scheduleDate = new Date(currentPrograms[0].start);
                scheduleDate.setUTCHours(0, 0, 0, 0);
            }
            
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
        }

        function parseXMLTVDateUTC(dateStr) {
            // Check if it's ISO 8601 format (contains 'T')
            if (dateStr.includes('T')) {
                // ISO 8601 format: 2025-06-09T21:00:00+0000
                const cleanDate = dateStr.replace(/[+-]\d{4}$/, '');
                const [datePart, timePart] = cleanDate.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, minute, second] = timePart.split(':').map(Number);
                
                return new Date(Date.UTC(year, month - 1, day, hour, minute, second || 0));
            } else {
                // Classic XMLTV format: YYYYMMDDHHmmss +0000
                const year = parseInt(dateStr.substr(0, 4));
                const month = parseInt(dateStr.substr(4, 2)) - 1;
                const day = parseInt(dateStr.substr(6, 2));
                const hour = parseInt(dateStr.substr(8, 2));
                const minute = parseInt(dateStr.substr(10, 2));
                const second = parseInt(dateStr.substr(12, 2));
                
                return new Date(Date.UTC(year, month, day, hour, minute, second));
            }
        }

        function formatXMLTVDate(date) {
            const pad = (n) => String(n).padStart(2, '0');
            const year = date.getUTCFullYear();
            const month = pad(date.getUTCMonth() + 1);
            const day = pad(date.getUTCDate());
            const hours = pad(date.getUTCHours());
            const minutes = pad(date.getUTCMinutes());
            const seconds = pad(date.getUTCSeconds());
            
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+0000`;
        }

        function loadPrograms() {
            // Get programs for the schedule day
            const dayStart = new Date(scheduleDate);
            dayStart.setUTCHours(21, 0, 0, 0);
            dayStart.setUTCDate(dayStart.getUTCDate() - 1);
            
            const dayEnd = new Date(scheduleDate);
            dayEnd.setUTCHours(21, 0, 0, 0);
            
            const dayPrograms = currentPrograms.filter(p => {
                return (p.start >= dayStart && p.start < dayEnd) || 
                       (p.start < dayStart && p.stop > dayStart);
            }).sort((a, b) => a.start - b.start);
            
            document.getElementById('programCount').textContent = dayPrograms.length;
            
            // Draw treemap
            drawTreemap(dayPrograms);
            
            // Update table
            updateProgramTable(dayPrograms);
            
            // Update statistics
            updateStatistics(dayPrograms);
            
            // Check for problems
            checkProblems(dayPrograms);
            
            // Update format legend
            updateFormatLegend(dayPrograms);
            
            // Analyze time slots
            analyzeTimeSlots(dayPrograms);
        }

        // Analyze time slots
        function analyzeTimeSlots(programs) {
            Object.entries(timeSlots).forEach(([slotKey, slot]) => {
                const slotPrograms = programs.filter(p => {
                    const startHour = p.start.getUTCHours() + p.start.getUTCMinutes() / 60;
                    const stopHour = p.stop.getUTCHours() + p.stop.getUTCMinutes() / 60;
                    
                    if (slot.end > 24) {
                        return (startHour >= slot.start || startHour < slot.end - 24) ||
                               (stopHour > slot.start || stopHour < slot.end - 24);
                    } else if (slotKey === 'night') {
                        return (startHour >= slot.start && startHour < slot.end) ||
                               (stopHour > slot.start && stopHour <= slot.end);
                    } else {
                        return (startHour < slot.end && stopHour > slot.start);
                    }
                });
                
                // Calculate coverage
                let totalSlotSeconds = (slot.end - slot.start) * 3600;
                if (slot.end > 24) {
                    totalSlotSeconds = ((slot.end - 24) + (24 - slot.start)) * 3600;
                }
                
                let coveredSeconds = 0;
                const formatCounts = {};
                
                slotPrograms.forEach(p => {
                    const slotStart = new Date(scheduleDate);
                    slotStart.setUTCHours(Math.floor(slot.start), (slot.start % 1) * 60, 0, 0);
                    
                    const slotEnd = new Date(scheduleDate);
                    if (slot.end > 24) {
                        slotEnd.setUTCDate(slotEnd.getUTCDate() + 1);
                        slotEnd.setUTCHours(Math.floor(slot.end - 24), ((slot.end - 24) % 1) * 60, 0, 0);
                    } else {
                        slotEnd.setUTCHours(Math.floor(slot.end), (slot.end % 1) * 60, 0, 0);
                    }
                    
                    if (slotKey === 'night') {
                        slotStart.setUTCHours(1, 0, 0, 0);
                        slotEnd.setUTCHours(6, 0, 0, 0);
                    }
                    
                    const overlapStart = Math.max(p.start.getTime(), slotStart.getTime());
                    const overlapEnd = Math.min(p.stop.getTime(), slotEnd.getTime());
                    
                    if (overlapEnd > overlapStart) {
                        const overlapSeconds = (overlapEnd - overlapStart) / 1000;
                        coveredSeconds += overlapSeconds;
                        
                        if (!formatCounts[p.title]) {
                            formatCounts[p.title] = 0;
                        }
                        formatCounts[p.title] += overlapSeconds;
                    }
                });
                
                // Find dominant format
                let dominantFormat = '-';
                let maxSeconds = 0;
                Object.entries(formatCounts).forEach(([format, seconds]) => {
                    if (seconds > maxSeconds) {
                        maxSeconds = seconds;
                        dominantFormat = format;
                    }
                });
                
                // Update UI
                const coverage = Math.min(100, (coveredSeconds / totalSlotSeconds) * 100);
                const statsDiv = document.getElementById(`${slotKey}Stats`);
                if (statsDiv) {
                    statsDiv.innerHTML = `
                        <p class="text-sm text-gray-700">Copertura: <span class="font-semibold">${coverage.toFixed(1)}%</span></p>
                        <p class="text-sm text-gray-700">Format dominante: <span class="font-semibold">${dominantFormat}</span></p>
                        <div class="mt-2 h-2 bg-gray-200 rounded-full overflow-hidden">
                            <div id="${slotKey}Coverage" class="h-full ${getSlotColorClass(slotKey)} transition-all duration-500" style="width: ${coverage}%"></div>
                        </div>
                    `;
                }
            });
        }
        
        function getSlotColorClass(slotKey) {
            const colorMap = {
                morning: 'bg-blue-500',
                afternoon: 'bg-green-500',
                evening: 'bg-purple-500',
                primeTime: 'bg-gradient-to-r from-amber-500 to-orange-500',
                lateEvening: 'bg-indigo-500',
                night: 'bg-gray-600'
            };
            return colorMap[slotKey] || 'bg-gray-400';
        }

        // Draw treemap
        function drawTreemap(programs) {
            const container = document.getElementById('treemapContainer');
            const containerRect = container.getBoundingClientRect();
            const size = Math.min(containerRect.width, 800);
            
            // Clear existing
            container.innerHTML = '<div class="fill-indicator" id="fillIndicator"><span id="fillPercent">0%</span> riempito</div>';
            
            // Aggregate programs by format
            const formatData = {};
            programs.forEach(p => {
                if (!formatData[p.title]) {
                    formatData[p.title] = {
                        title: p.title,
                        duration: 0,
                        programs: [],
                        icon: p.icon || '',
                        category: p.category || ''
                    };
                }
                formatData[p.title].duration += p.duration;
                formatData[p.title].programs.push(p);
            });
            
            // Convert to array and sort by duration
            const formats = Object.values(formatData).sort((a, b) => b.duration - a.duration);
            
            // Calculate total duration
            const totalDuration = formats.reduce((sum, f) => sum + f.duration, 0);
            
            // Apply treemap algorithm
            const nodes = formats.map(f => ({
                value: f.duration,
                data: f
            }));
            
            const root = {
                x: 0,
                y: 0,
                width: size,
                height: size
            };
            
            let layoutNodes;
            if (currentLayout === 'squarify') {
                layoutNodes = squarify(nodes, root);
            } else if (currentLayout === 'binary') {
                layoutNodes = binary(nodes, root);
            } else {
                layoutNodes = sliceDice(nodes, root);
            }
            
            // Create elements
            layoutNodes.forEach((node, index) => {
                const format = node.data;
                const div = document.createElement('div');
                div.className = 'treemap-program new';
                div.style.left = node.x + 'px';
                div.style.top = node.y + 'px';
                div.style.width = node.width + 'px';
                div.style.height = node.height + 'px';
                div.style.backgroundColor = formatColors[format.title];
                
                // Add icon if available
                if (format.icon) {
                    const img = document.createElement('img');
                    img.src = format.icon;
                    img.className = 'treemap-icon';
                    img.onerror = function() { this.style.display = 'none'; };
                    div.appendChild(img);
                }
                
                // Add label
                const label = document.createElement('div');
                label.className = 'treemap-label';
                label.innerHTML = `
                    <div>${format.title}</div>
                    <div style="font-size: 0.8em; opacity: 0.8;">${formatDuration(format.duration)}</div>
                `;
                div.appendChild(label);
                
                // Add events
                div.addEventListener('click', () => showFormatDetails(format));
                div.addEventListener('mouseenter', (e) => showProgramPreview(format, e));
                div.addEventListener('mouseleave', hideProgramPreview);
                
                container.appendChild(div);
            });
            
            // Update fill indicator
            const fillPercent = (totalDuration / totalDaySeconds) * 100;
            const fillIndicator = document.getElementById('fillIndicator');
            const fillPercentSpan = document.getElementById('fillPercent');
            
            fillPercentSpan.textContent = fillPercent.toFixed(1) + '%';
            
            if (fillPercent >= 95) {
                fillIndicator.classList.add('complete');
                fillIndicator.classList.remove('warning', 'error');
            } else if (fillPercent >= 80) {
                fillIndicator.classList.add('warning');
                fillIndicator.classList.remove('complete', 'error');
            } else {
                fillIndicator.classList.add('error');
                fillIndicator.classList.remove('complete', 'warning');
            }
        }
        
        // Treemap layout algorithms
        function squarify(nodes, container) {
            const area = container.width * container.height;
            const totalValue = nodes.reduce((sum, n) => sum + n.value, 0);
            
            nodes.forEach(node => {
                node.area = (node.value / totalValue) * area;
            });
            
            const layoutNodes = [];
            let x = container.x;
            let y = container.y;
            let width = container.width;
            let height = container.height;
            
            nodes.forEach((node, i) => {
                const aspect = width / height;
                const nodeArea = node.area;
                
                let nodeWidth, nodeHeight;
                if (aspect > 1) {
                    nodeWidth = Math.sqrt(nodeArea * aspect);
                    nodeHeight = nodeArea / nodeWidth;
                } else {
                    nodeHeight = Math.sqrt(nodeArea / aspect);
                    nodeWidth = nodeArea / nodeHeight;
                }
                
                if (x + nodeWidth > container.x + container.width) {
                    x = container.x;
                    y += nodeHeight;
                }
                
                layoutNodes.push({
                    x: x,
                    y: y,
                    width: Math.min(nodeWidth, container.x + container.width - x),
                    height: Math.min(nodeHeight, container.y + container.height - y),
                    data: node.data
                });
                
                x += nodeWidth;
            });
            
            return layoutNodes;
        }
        
        function binary(nodes, container) {
            const layoutNodes = [];
            
            function layout(nodes, x, y, width, height, vertical) {
                if (nodes.length === 0) return;
                if (nodes.length === 1) {
                    layoutNodes.push({
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        data: nodes[0].data
                    });
                    return;
                }
                
                const mid = Math.floor(nodes.length / 2);
                const leftNodes = nodes.slice(0, mid);
                const rightNodes = nodes.slice(mid);
                
                const leftValue = leftNodes.reduce((sum, n) => sum + n.value, 0);
                const rightValue = rightNodes.reduce((sum, n) => sum + n.value, 0);
                const totalValue = leftValue + rightValue;
                
                if (vertical) {
                    const leftHeight = height * (leftValue / totalValue);
                    layout(leftNodes, x, y, width, leftHeight, !vertical);
                    layout(rightNodes, x, y + leftHeight, width, height - leftHeight, !vertical);
                } else {
                    const leftWidth = width * (leftValue / totalValue);
                    layout(leftNodes, x, y, leftWidth, height, !vertical);
                    layout(rightNodes, x + leftWidth, y, width - leftWidth, height, !vertical);
                }
            }
            
            layout(nodes, container.x, container.y, container.width, container.height, true);
            return layoutNodes;
        }
        
        function sliceDice(nodes, container) {
            const layoutNodes = [];
            const totalValue = nodes.reduce((sum, n) => sum + n.value, 0);
            
            let currentX = container.x;
            let currentY = container.y;
            const vertical = container.width < container.height;
            
            nodes.forEach(node => {
                const ratio = node.value / totalValue;
                
                if (vertical) {
                    const nodeHeight = container.height * ratio;
                    layoutNodes.push({
                        x: currentX,
                        y: currentY,
                        width: container.width,
                        height: nodeHeight,
                        data: node.data
                    });
                    currentY += nodeHeight;
                } else {
                    const nodeWidth = container.width * ratio;
                    layoutNodes.push({
                        x: currentX,
                        y: currentY,
                        width: nodeWidth,
                        height: container.height,
                        data: node.data
                    });
                    currentX += nodeWidth;
                }
            });
            
            return layoutNodes;
        }
        
        // Set layout
        function setLayout(layout) {
            currentLayout = layout;
            document.querySelectorAll('.layout-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-layout') === layout) {
                    btn.classList.add('active');
                }
            });
            
            // Redraw with new layout
            if (currentPrograms.length > 0) {
                loadPrograms();
            }
        }
        
        // Show format details
        function showFormatDetails(format) {
            const detailsDiv = document.getElementById('programDetails');
            detailsDiv.style.display = 'block';
            
            document.getElementById('detailTitle').textContent = format.title;
            document.getElementById('detailDuration').textContent = formatDuration(format.duration);
            document.getElementById('detailCategory').textContent = format.category || '-';
            
            const timeRange = format.programs.length > 0 
                ? `${formatTimeUTC(format.programs[0].start)} - ${formatTimeUTC(format.programs[format.programs.length - 1].stop)}`
                : '-';
            document.getElementById('detailTime').textContent = timeRange;
            
            const descriptions = [...new Set(format.programs.map(p => p.desc).filter(d => d))];
            document.getElementById('detailDescription').textContent = descriptions.join(' | ') || '-';
            
            const iconDiv = document.getElementById('detailIcon');
            const iconUrl = document.getElementById('detailIconUrl');
            
            if (format.icon) {
                iconDiv.style.backgroundImage = `url(${format.icon})`;
                iconUrl.textContent = format.icon;
            } else {
                iconDiv.style.backgroundImage = '';
                iconUrl.textContent = 'Nessuna icona';
            }
            
            // Scroll to details
            detailsDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // Show program preview
        function showProgramPreview(format, event) {
            const preview = document.getElementById('programPreview');
            const rect = event.target.getBoundingClientRect();
            
            // Update content
            document.getElementById('previewTitle').textContent = format.title;
            document.getElementById('previewDuration').textContent = formatDuration(format.duration);
            document.getElementById('previewCategory').textContent = format.category || 'Non specificata';
            document.getElementById('previewPosition').textContent = `${format.programs.length} programmi`;
            
            const percentage = ((format.duration / totalDaySeconds) * 100).toFixed(1);
            document.getElementById('previewArea').textContent = `${percentage}% del giorno`;
            
            const desc = format.programs[0]?.desc || '';
            document.getElementById('previewDesc').textContent = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;
            
            // Set icon
            const iconDiv = document.getElementById('previewIcon');
            if (format.icon) {
                iconDiv.style.backgroundImage = `url(${format.icon})`;
                iconDiv.style.display = 'block';
            } else {
                iconDiv.style.display = 'none';
            }
            
            // Calculate time range
            if (format.programs.length > 0) {
                const timeRange = `${formatTimeUTC(format.programs[0].start)} - ${formatTimeUTC(format.programs[format.programs.length - 1].stop)}`;
                document.getElementById('previewTime').textContent = timeRange;
            }
            
            // Position preview
            let left = rect.right + 10;
            let top = rect.top;
            
            // Adjust if would go off screen
            if (left + 350 > window.innerWidth) {
                left = rect.left - 360;
            }
            
            if (top + 300 > window.innerHeight) {
                top = window.innerHeight - 310;
            }
            
            preview.style.left = left + 'px';
            preview.style.top = top + 'px';
            
            // Show with animation
            preview.classList.add('show');
        }
        
        function hideProgramPreview() {
            const preview = document.getElementById('programPreview');
            preview.classList.remove('show');
        }
        
        // Update program table
        function updateProgramTable(programs) {
            const tbody = document.getElementById('programTable');
            tbody.innerHTML = '';
            
            programs.forEach((program, index) => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                
                row.innerHTML = `
                    <td class="px-4 py-2">${formatTimeUTC(program.start)}</td>
                    <td class="px-4 py-2">${formatTimeUTC(program.stop)}</td>
                    <td class="px-4 py-2">${formatDuration(program.duration)}</td>
                    <td class="px-4 py-2 font-medium">${program.title}</td>
                    <td class="px-4 py-2">${program.category || '-'}</td>
                    <td class="px-4 py-2">
                        <button onclick="editProgram(${index})" class="text-blue-600 hover:text-blue-800 mr-2">
                            <i data-lucide="edit-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="deleteProgram(${index})" class="text-red-600 hover:text-red-800">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Re-initialize icons
            lucide.createIcons();
        }
        
        // Update statistics
        function updateStatistics(programs) {
            // Calculate coverage
            let totalCoveredSeconds = 0;
            const gaps = [];
            
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                
                totalCoveredSeconds += current.duration;
                
                // Check for gap
                const gapSeconds = (next.start - current.stop) / 1000;
                if (gapSeconds > 60) { // Gap > 1 minute
                    gaps.push({
                        start: current.stop,
                        end: next.start,
                        duration: gapSeconds
                    });
                }
            }
            
            if (programs.length > 0) {
                totalCoveredSeconds += programs[programs.length - 1].duration;
            }
            
            // Update coverage
            const coveragePercent = (totalCoveredSeconds / totalDaySeconds) * 100;
            document.getElementById('coveragePercent').textContent = coveragePercent.toFixed(1) + '%';
            document.getElementById('coverageTime').textContent = formatDuration(totalCoveredSeconds);
            
            // Update coverage ring
            const ring = document.getElementById('coverageRing');
            const circumference = 2 * Math.PI * 20;
            const offset = circumference - (coveragePercent / 100) * circumference;
            ring.style.strokeDashoffset = offset;
            
            // Update other stats
            document.getElementById('gapCount').textContent = gaps.length;
            document.getElementById('formatCount').textContent = Object.keys(formatColors).length;
            
            const avgDuration = programs.length > 0 
                ? Math.round(totalCoveredSeconds / programs.length / 60)
                : 0;
            document.getElementById('avgDuration').textContent = avgDuration + 'm';
        }
        
        // Check for problems
        function checkProblems(programs) {
            const problems = [];
            
            // Check for gaps
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                const gapSeconds = (next.start - current.stop) / 1000;
                
                if (gapSeconds > 300) { // Gap > 5 minutes
                    problems.push({
                        type: 'gap',
                        severity: gapSeconds > 1800 ? 'error' : 'warning',
                        message: `Gap di ${formatDuration(gapSeconds)} tra "${current.title}" e "${next.title}" (${formatTimeUTC(current.stop)})`
                    });
                }
            }
            
            // Check for overlaps
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                
                if (current.stop > next.start) {
                    const overlapSeconds = (current.stop - next.start) / 1000;
                    problems.push({
                        type: 'overlap',
                        severity: 'error',
                        message: `Sovrapposizione di ${formatDuration(overlapSeconds)} tra "${current.title}" e "${next.title}"`
                    });
                }
            }
            
            // Check for very short programs
            programs.forEach(p => {
                if (p.duration < 300) { // Less than 5 minutes
                    problems.push({
                        type: 'short',
                        severity: 'warning',
                        message: `"${p.title}" dura solo ${formatDuration(p.duration)}`
                    });
                }
            });
            
            // Display problems
            const reportDiv = document.getElementById('problemsReport');
            if (problems.length === 0) {
                reportDiv.innerHTML = '<p class="text-green-600">✓ Nessun problema rilevato</p>';
            } else {
                reportDiv.innerHTML = problems.map(p => {
                    const icon = p.severity === 'error' ? '❌' : '⚠️';
                    const color = p.severity === 'error' ? 'text-red-600' : 'text-yellow-600';
                    return `<p class="${color}">${icon} ${p.message}</p>`;
                }).join('');
            }
        }
        
        // Update format legend
        function updateFormatLegend(programs) {
            const legendDiv = document.getElementById('formatLegend');
            legendDiv.innerHTML = '';
            
            // Calculate format statistics
            const formatStats = {};
            programs.forEach(p => {
                if (!formatStats[p.title]) {
                    formatStats[p.title] = {
                        count: 0,
                        duration: 0
                    };
                }
                formatStats[p.title].count++;
                formatStats[p.title].duration += p.duration;
            });
            
            // Sort by duration
            const sortedFormats = Object.entries(formatStats)
                .sort((a, b) => b[1].duration - a[1].duration);
            
            sortedFormats.forEach(([title, stats]) => {
                const div = document.createElement('div');
                div.className = 'format-item';
                
                const color = document.createElement('div');
                color.className = 'format-color';
                color.style.backgroundColor = formatColors[title];
                
                const label = document.createElement('span');
                label.textContent = `${title} (${stats.count}x, ${formatDuration(stats.duration)})`;
                
                div.appendChild(color);
                div.appendChild(label);
                legendDiv.appendChild(div);
            });
        }
        
        // Utility functions
        function formatTimeUTC(date) {
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        function formatDateUTC(date) {
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                timeZone: 'UTC'
            };
            return date.toLocaleDateString('it-IT', options);
        }
        
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            return `${minutes}m`;
        }
        
        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type} px-6 py-4 rounded-lg flex items-center gap-3`;
            
            const icon = type === 'success' ? 'check-circle' : 
                         type === 'error' ? 'alert-circle' : 'info';
            
            toast.innerHTML = `
                <i data-lucide="${icon}" class="w-5 h-5"></i>
                <span>${message}</span>
            `;
            
            document.getElementById('toastContainer').appendChild(toast);
            
            // Re-initialize icons
            lucide.createIcons();
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            showToast('Dark mode ' + (document.body.classList.contains('dark') ? 'attivato' : 'disattivato'));
        }
        
        // Show info
        function showInfo() {
            alert(`XMLTV Viewer v${APP_VERSION}\n\n` +
                  'Visualizzatore e editor avanzato per file XMLTV con:\n' +
                  '- Treemap aggregato per format\n' +
                  '- Analisi fasce orarie (6 fasce)\n' +
                  '- Editor programmi inline\n' +
                  '- Export/import XMLTV\n\n' +
                  'Modalità: UTC (tutti gli orari)');
        }
        
        // Edit program
        function editProgram(index) {
            showToast('Funzione di modifica in sviluppo', 'info');
        }
        
        // Delete program
        function deleteProgram(index) {
            if (confirm('Eliminare questo programma?')) {
                currentPrograms.splice(index, 1);
                loadPrograms();
                showToast('Programma eliminato', 'success');
            }
        }
        
        // Add program
        function addProgram() {
            showToast('Funzione di aggiunta in sviluppo', 'info');
        }
        
        // Show actualization dialog
        function showActualizationDialog() {
            const dialog = document.getElementById('actualizationDialog');
            const dateInput = document.getElementById('newStartDate');
            
            // Set default to today
            const today = new Date();
            dateInput.value = today.toISOString().split('T')[0];
            
            dialog.classList.remove('hidden');
            dialog.classList.add('flex');
        }
        
        // Close actualization dialog
        function closeActualizationDialog() {
            const dialog = document.getElementById('actualizationDialog');
            dialog.classList.add('hidden');
            dialog.classList.remove('flex');
        }
        
        // Actualize schedule
        function actualizeSchedule() {
            const newDateStr = document.getElementById('newStartDate').value;
            if (!newDateStr) {
                showToast('Seleziona una data', 'error');
                return;
            }
            
            const newDate = new Date(newDateStr + 'T00:00:00Z');
            const oldDate = new Date(scheduleDate);
            const daysDiff = Math.round((newDate - oldDate) / (1000 * 60 * 60 * 24));
            
            // Update all program dates
            currentPrograms.forEach(program => {
                program.start = new Date(program.start.getTime() + (daysDiff * 24 * 60 * 60 * 1000));
                program.stop = new Date(program.stop.getTime() + (daysDiff * 24 * 60 * 60 * 1000));
            });
            
            // Update schedule date
            scheduleDate = newDate;
            document.getElementById('scheduleDate').textContent = formatDateUTC(scheduleDate);
            
            // Reload programs
            loadPrograms();
            
            closeActualizationDialog();
            showToast('Date attualizzate con successo', 'success');
        }
        
        // Export XMLTV
        function exportXMLTV() {
            if (!xmlDoc || currentPrograms.length === 0) {
                showToast('Nessun dato da esportare', 'error');
                return;
            }
            
            // Create new XML document
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<tv>\n';
            
            // Add channel
            xml += `  <channel id="${currentChannelId}">\n`;
            xml += `    <display-name lang="it">${currentChannelName}</display-name>\n`;
            xml += '  </channel>\n\n';
            
            // Add programs
            currentPrograms.forEach(program => {
                const startStr = formatXMLTVDate(program.start);
                const stopStr = formatXMLTVDate(program.stop);
                
                xml += `  <programme start="${startStr}" stop="${stopStr}" channel="${currentChannelId}">\n`;
                xml += `    <title lang="it">${escapeXml(program.title)}</title>\n`;
                
                if (program.desc) {
                    xml += `    <desc lang="it">${escapeXml(program.desc)}</desc>\n`;
                }
                
                if (program.category) {
                    xml += `    <category lang="it">${escapeXml(program.category)}</category>\n`;
                }
                
                if (program.rating && program.rating !== '0') {
                    xml += '    <rating>\n';
                    xml += `      <value>${program.rating}</value>\n`;
                    xml += '    </rating>\n';
                }
                
                if (program.icon) {
                    xml += `    <icon src="${escapeXml(program.icon)}" />\n`;
                }
                
                xml += '  </programme>\n';
            });
            
            xml += '</tv>';
            
            // Download file
            const blob = new Blob([xml], { type: 'text/xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentChannelId}_${scheduleDate.toISOString().split('T')[0]}.xml`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('File XMLTV esportato', 'success');
        }
        
        // Escape XML special characters
        function escapeXml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
    </script>
</body>
</html>
