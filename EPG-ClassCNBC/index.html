<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convertitore EPG Multi-Canale Excel a XMLTV</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .channel-selector {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .channel-btn {
            background: #e9ecef;
            color: #495057;
            padding: 15px 30px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        .channel-btn:hover {
            background: #dee2e6;
        }
        .channel-btn.active {
            background: #667eea;
            color: white;
            border-color: #5a6fd8;
        }
        .channel-info {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            display: none;
        }
        .channel-info.active {
            display: block;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            background: #fafafa;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        .upload-area.dragover {
            border-color: #667eea;
            background: #e8f0fe;
        }
        input[type="file"] {
            display: none;
        }
        .btn {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        .btn:hover {
            background: #5a6fd8;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .settings {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .settings h3 {
            margin-top: 0;
            color: #333;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .checkbox-group {
            margin: 20px 0;
        }
        .checkbox-group label {
            display: inline-block;
            margin-left: 8px;
            font-weight: normal;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }
        .download-link {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 5px;
            margin: 10px 0;
            transition: background 0.3s ease;
        }
        .download-link:hover {
            background: #1e7e34;
            color: white;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .two-columns {
                grid-template-columns: 1fr;
            }
        }
        .icon-manager {
            background: #f0f4ff;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
        .icon-manager.active {
            display: block;
        }
        .icon-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .icon-item {
            display: grid;
            grid-template-columns: 200px 1fr auto;
            gap: 10px;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        .icon-item:last-child {
            border-bottom: none;
        }
        .icon-preview {
            width: 40px;
            height: 23px;
            background-size: cover;
            background-position: center;
            border: 1px solid #ccc;
            display: inline-block;
            margin-left: 10px;
        }
        .add-format-section {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .icon-actions {
            display: flex;
            gap: 10px;
        }
        .btn-small {
            padding: 5px 10px;
            font-size: 14px;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-success:hover {
            background: #218838;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Convertitore EPG Multi-Canale Excel ‚Üí XMLTV</h1>
        <div style="text-align: center; margin-top: -10px; margin-bottom: 20px; color: #666; font-size: 14px;">
            Versione 2.2.1 - Ultimo aggiornamento: 05/06/2025
        </div>
        
        <div class="channel-selector">
            <h3>Seleziona il canale:</h3>
            <button class="channel-btn active" onclick="selectChannel('classcnbc')" id="btnClassCNBC">
                üì∫ Class CNBC
            </button>
            <button class="channel-btn" onclick="selectChannel('tvmoda')" id="btnTVModa">
                üëó Class TV Moda
            </button>
        </div>

        <div class="channel-info active" id="infoClassCNBC">
            <h4>üì∫ Class CNBC</h4>
            <p>Formato Excel: File unico con cambio data su righe singole</p>
            <p>Struttura: Ora | Titolo | ID | ... | Categoria | Rating | Descrizioni</p>
        </div>

        <div class="channel-info" id="infoTVModa">
            <h4>üëó Class TV Moda</h4>
            <p>Formato Excel: Un foglio per ogni giorno della settimana</p>
            <p>Struttura: Data/Ora | Titolo | Durata | Descrizione</p>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>üìÅ Trascina qui il file Excel o clicca per selezionarlo</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">Seleziona File Excel</button>
            <input type="file" id="fileInput" accept=".xlsx,.xls" />
        </div>

        <div class="settings">
            <h3>‚öôÔ∏è Impostazioni</h3>
            
            <div class="two-columns">
                <div>
                    <div class="form-group">
                        <label for="channelId">ID Canale:</label>
                        <input type="text" id="channelId" value="ClassCNBC" />
                    </div>
                    
                    <div class="form-group">
                        <label for="channelName">Nome Canale:</label>
                        <input type="text" id="channelName" value="Class CNBC" />
                    </div>
                    
                    <div class="form-group">
                        <label for="iconUrl">URL Icona/Logo (default canale):</label>
                        <input type="text" id="iconUrl" value="https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Class+CNBC" />
                        <small style="display: block; color: #666; margin-top: 5px;">
                            Nota: Ogni format avr√† la sua icona specifica automaticamente
                        </small>
                    </div>
                </div>
                
                <div>
                    <div class="form-group">
                        <label for="timezone">Timezone:</label>
                        <select id="timezone">
                            <option value="+01:00">+01:00 (Italia)</option>
                            <option value="+00:00">+00:00 (UTC)</option>
                            <option value="+02:00">+02:00</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="dateRange">Periodo da convertire:</label>
                        <select id="dateRange">
                            <option value="all">Tutti i giorni disponibili</option>
                            <option value="today">Solo oggi</option>
                            <option value="tomorrow" selected>Solo domani</option>
                            <option value="week">Prossimi 7 giorni</option>
                        </select>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="fillGaps" checked>
                        <label for="fillGaps">Riempi automaticamente i gap temporali</label>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-small" onclick="toggleIconManager()">
                    üé® Gestisci Icone Format
                </button>
            </div>
        </div>

        <div class="icon-manager" id="iconManager">
            <h3>üé® Gestione Icone Format</h3>
            <p>Modifica le associazioni format ‚Üí icona per il canale selezionato</p>
            
            <div class="icon-list" id="iconList">
                <!-- Popolato dinamicamente -->
            </div>
            
            <div class="add-format-section">
                <h4>‚ûï Aggiungi Nuovo Format</h4>
                <div style="display: grid; grid-template-columns: 1fr 2fr auto; gap: 10px;">
                    <input type="text" id="newFormatName" placeholder="Nome format" />
                    <input type="text" id="newFormatIcon" placeholder="URL icona" />
                    <button class="btn btn-success btn-small" onclick="addNewFormat()">Aggiungi</button>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-warning btn-small" onclick="scanForMissingFormats()" 
                        style="background: #ffc107; color: #000;">
                    üîç Verifica Format Mancanti
                </button>
                <hr style="margin: 15px 0;">
                <div style="background: #e8f0fe; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <label style="font-weight: normal;">
                        <input type="checkbox" id="enablePersistence" onchange="togglePersistence()">
                        Abilita salvataggio automatico nel browser (localStorage)
                    </label>
                </div>
                <button class="btn btn-small" onclick="exportIconMapping()">üíæ Esporta Mappatura</button>
                <button class="btn btn-small" onclick="importIconMapping()">üìÇ Importa Mappatura</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleImport(event)" />
            </div>
        </div>

        <div class="icon-manager" id="missingFormatsManager" style="background: #fff3cd; border-color: #ffeaa7;">
            <h3>‚ö†Ô∏è Format Mancanti nel Dizionario</h3>
            <p>I seguenti format sono stati trovati nel file ma non hanno un'icona associata:</p>
            
            <div class="icon-list" id="missingFormatsList">
                <!-- Popolato dinamicamente -->
            </div>
            
            <div style="text-align: center; margin-top: 15px;">
                <button class="btn btn-success" onclick="saveMissingFormats()">‚úÖ Aggiungi al Dizionario</button>
                <button class="btn btn-small" onclick="closeMissingFormats()">‚ùå Chiudi</button>
            </div>
        </div>

        <button class="btn" id="convertBtn" onclick="convertFile()" disabled>üöÄ Converti in XMLTV</button>

        <div id="status"></div>
        <div id="log" class="log" style="display: none;"></div>
        <div id="downloadSection" style="display: none;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        let fileData = null;
        let xmltvContent = '';
        let currentChannel = 'classcnbc';
        let workbook = null;

        // Configurazioni predefinite per canale
        const channelConfigs = {
            classcnbc: {
                id: 'ClassCNBC',
                name: 'Class CNBC',
                icon: 'https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Class+CNBC'
            },
            tvmoda: {
                id: 'ClassTVModa',
                name: 'Class TV Moda',
                icon: 'https://via.placeholder.com/1920x1080/FF1493/FFFFFF?text=Class+TV+Moda'
            }
        };

        // Mappatura icone per format - TV Moda
        const tvModaFormatIcons = {
            "(UN)ACCESSING BACKSTAGE": "https://via.placeholder.com/1920x1080/8B008B/FFFFFF?text=Backstage",
            "CATWALKS": "https://via.placeholder.com/1920x1080/FF1493/FFFFFF?text=Catwalks",
            "CLASS TV MODA STORIES": "https://via.placeholder.com/1920x1080/DA70D6/FFFFFF?text=TV+Moda+Stories",
            "DESIGN MAP": "https://via.placeholder.com/1920x1080/9370DB/FFFFFF?text=Design+Map",
            "DISTRICTS": "https://via.placeholder.com/1920x1080/BA55D3/FFFFFF?text=Districts",
            "FASHION NEWS": "https://via.placeholder.com/1920x1080/FF69B4/FFFFFF?text=Fashion+News",
            "FASHION&BEYOND": "https://via.placeholder.com/1920x1080/DDA0DD/FFFFFF?text=Fashion+Beyond",
            "FRONT ROW": "https://via.placeholder.com/1920x1080/EE82EE/FFFFFF?text=Front+Row",
            "GREEN REVOLUTION FORWARD": "https://via.placeholder.com/1920x1080/32CD32/FFFFFF?text=Green+Revolution",
            "SOUND OF FASHION": "https://via.placeholder.com/1920x1080/FF6347/FFFFFF?text=Sound+of+Fashion",
            "SPOTLIGHT": "https://via.placeholder.com/1920x1080/FFD700/FFFFFF?text=Spotlight",
            "VOICES": "https://via.placeholder.com/1920x1080/4169E1/FFFFFF?text=Voices",
            "WHAT WOMEN WEAR": "https://via.placeholder.com/1920x1080/FF1493/FFFFFF?text=What+Women+Wear"
        };

        // Mappatura icone per format - Class CNBC
        // NOTA: Per rendere permanenti le modifiche, esporta il JSON e sostituisci questo oggetto
        const classCNBCFormatIcons = {
            "Business Class": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Business+Class",
            "Mercati in 10 minuti": "https://via.placeholder.com/1920x1080/0066CC/FFFFFF?text=Mercati+10min",
            "Class Meteo": "https://via.placeholder.com/1920x1080/87CEEB/FFFFFF?text=Class+Meteo",
            "Trading Room": "https://via.placeholder.com/1920x1080/FF4500/FFFFFF?text=Trading+Room",
            "Tradingroom": "https://via.placeholder.com/1920x1080/FF4500/FFFFFF?text=Trading+Room",
            "Borse Oggi": "https://via.placeholder.com/1920x1080/32CD32/FFFFFF?text=Borse+Oggi",
            "Apertura Mercati": "https://via.placeholder.com/1920x1080/FFD700/FFFFFF?text=Apertura+Mercati",
            "Market Driver": "https://via.placeholder.com/1920x1080/4169E1/FFFFFF?text=Market+Driver",
            "Wall Street": "https://via.placeholder.com/1920x1080/FF6347/FFFFFF?text=Wall+Street",
            "Chiusura Mercati": "https://via.placeholder.com/1920x1080/DC143C/FFFFFF?text=Chiusura+Mercati",
            "Business Talk": "https://via.placeholder.com/1920x1080/008080/FFFFFF?text=Business+Talk",
            "Class Life": "https://via.placeholder.com/1920x1080/9370DB/FFFFFF?text=Class+Life",
            "Report": "https://via.placeholder.com/1920x1080/2F4F4F/FFFFFF?text=Report",
            "Documentario": "https://via.placeholder.com/1920x1080/708090/FFFFFF?text=Documentario",
            "Gli speciali settimanali di Class Cnbc": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Gli+speciali+settimanali+di+Class+Cnbc",
            "4cLegal Academy Pt 5": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=4cLegal+Academy+Pt+5",
            "Caffe' Affari": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Caffe+Affari",
            "Analisi Tecnica": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Analisi+Tecnica",
            "Linea Mercati": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Linea+Mercati",
            "Growth Italia": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Growth+Italia",
            "Gli speciali di Class Cnbc": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Gli+speciali+di+Class+Cnbc",
            "Trading Nation": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Trading+Nation",
            "Market Movers": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Market+Movers",
            "Linea Mercati Wall Street": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Linea+Mercati+Wall+Street",
            "Linea Mercati Notte": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Linea+Mercati+Notte",
            "La giornata di Class Cnbc": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=La+giornata+di+Class+Cnbc",
            "4cLegal Academy Pt 6": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=4cLegal+Academy+Pt+6",
            "Fabi risponde": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Fabi+risponde",
            "Speciale Mondi da scoprire Pt 4": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Speciale+Mondi+da+scoprire+Pt+4",
            "BCE - annuncio tassi": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=BCE+-+annuncio+tassi",
            "BCE - conferenza stampa": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=BCE+-+conferenza+stampa",
            "The Floor": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=The+Floor",
            "5 Giorni Sui Mercati": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=5+Giorni+Sui+Mercati",
            "4cLegal Academy Pt 7": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=4cLegal+Academy+Pt+7",
            "Gli speciali di ClassCnbc": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Gli+speciali+di+ClassCnbc",
            "4cLegal Academy Pt 8": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=4cLegal+Academy+Pt+8",
            "Speciale FED": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=Speciale+FED",
            "4cLegal Academy Pt 9": "https://via.placeholder.com/1920x1080/003366/FFFFFF?text=4cLegal+Academy+Pt+9"
        };
        
        // ISTRUZIONI PER RENDERE PERMANENTI LE MODIFICHE:
        // 1. Fai le tue modifiche nell'interfaccia
        // 2. Esporta il JSON
        // 3. Apri il JSON e copia il contenuto di "formatIcons"
        // 4. Sostituisci l'oggetto sopra con il tuo contenuto
        // 5. Salva il file HTML

        // Versione software
        const SOFTWARE_VERSION = "2.2.1";
        const LAST_UPDATE = "05/06/2025";
        
        // Array per memorizzare i format trovati nel file corrente
        let detectedFormats = new Set();

        // Funzione per ottenere l'icona corretta in base al format (case-insensitive)
        function getIconForFormat(format, channel) {
            if (!format) return channelConfigs[channel].icon;
            
            const formatIcons = channel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            
            // Normalizza il format per la ricerca case-insensitive
            const normalizedFormat = format.trim().toUpperCase();
            
            // Cerca la chiave corrispondente (case-insensitive)
            for (const [key, value] of Object.entries(formatIcons)) {
                if (key.toUpperCase() === normalizedFormat) {
                    return value;
                }
            }
            
            // Se non trovato, ritorna l'icona default del canale
            return channelConfigs[channel].icon;
        }

        // Mappatura categorie
        const categoryMapping = {
            'Informazione': 'News',
            'Economia': 'Business', 
            'Intrattenimento': 'Entertainment',
            'Sport': 'Sports',
            'Musica': 'Music',
            'Documentario': 'Documentary',
            'Cultura': 'Arts/Culture',
            'Cucina': 'Cooking',
            'Travel': 'Travel',
            'Talk': 'Talk Show',
            'Reality': 'Reality',
            'Film': 'Movie',
            'Fashion': 'Fashion',
            'Lifestyle': 'Lifestyle'
        };

        // Mappatura rating
        const ratingMapping = {
            'U': '0',
            'T': '6',
            'VM14': '14',
            'VM18': '18',
            '6': '6',
            '12': '12',
            '14': '14',
            '16': '16',
            '18': '18'
        };

        function selectChannel(channel) {
            currentChannel = channel;
            
            // Aggiorna UI
            document.querySelectorAll('.channel-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.channel-info').forEach(info => info.classList.remove('active'));
            
            if (channel === 'classcnbc') {
                document.getElementById('btnClassCNBC').classList.add('active');
                document.getElementById('infoClassCNBC').classList.add('active');
            } else {
                document.getElementById('btnTVModa').classList.add('active');
                document.getElementById('infoTVModa').classList.add('active');
            }
            
            // Aggiorna configurazioni predefinite
            const config = channelConfigs[channel];
            document.getElementById('channelId').value = config.id;
            document.getElementById('channelName').value = config.name;
            document.getElementById('iconUrl').value = config.icon;
            
            addLog(`Canale selezionato: ${config.name}`);
        }

        // Setup file upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const downloadSection = document.getElementById('downloadSection');

        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function showStatus(message, type = 'info') {
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function addLog(message) {
            logDiv.style.display = 'block';
            logDiv.innerHTML += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function handleFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/i)) {
                showStatus('‚ö†Ô∏è Seleziona un file Excel (.xlsx o .xls)', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    workbook = XLSX.read(e.target.result, { 
                        type: 'binary',
                        cellDates: true,
                        cellNF: false,
                        cellText: false
                    });
                    
                    // Reset format rilevati
                    detectedFormats.clear();
                    
                    // Analizza il tipo di file e rileva i format
                    if (currentChannel === 'tvmoda') {
                        // TVModa ha fogli per giorni della settimana
                        const expectedSheets = ['SABATO', 'DOMENICA', 'LUNEDI', 'MARTEDI', 'MERCOLEDI', 'GIOVEDI', 'VENERDI'];
                        const hasWeekdaySheets = expectedSheets.some(sheet => workbook.SheetNames.includes(sheet));
                        
                        if (!hasWeekdaySheets) {
                            showStatus('‚ö†Ô∏è File non compatibile con TV Moda. Assicurati di aver selezionato il canale corretto.', 'error');
                            return;
                        }
                        
                        // Scansiona tutti i format nel file
                        for (const sheetName of workbook.SheetNames) {
                            if (expectedSheets.includes(sheetName)) {
                                const worksheet = workbook.Sheets[sheetName];
                                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
                                
                                for (let i = 3; i < data.length; i++) {
                                    const row = data[i];
                                    if (row && row[1] && typeof row[1] === 'string') {
                                        detectedFormats.add(row[1].trim());
                                    }
                                }
                            }
                        }
                        
                        showStatus(`‚úÖ File TV Moda caricato: ${file.name} (${workbook.SheetNames.length} fogli, ${detectedFormats.size} format unici trovati)`, 'success');
                        addLog(`File TV Moda caricato con fogli: ${workbook.SheetNames.join(', ')}`);
                        addLog(`Format unici trovati: ${detectedFormats.size}`);
                    } else {
                        // ClassCNBC ha un singolo foglio
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        fileData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
                        
                        // Scansiona i format
                        for (let i = 1; i < fileData.length; i++) {
                            const row = fileData[i];
                            if (row && row[1] && typeof row[1] === 'string' && row.length > 10) {
                                detectedFormats.add(row[1].trim());
                            }
                        }
                        
                        showStatus(`‚úÖ File Class CNBC caricato: ${file.name} (${fileData.length} righe, ${detectedFormats.size} format unici trovati)`, 'success');
                        addLog(`File Class CNBC caricato: ${sheetName} con ${fileData.length} righe`);
                        addLog(`Format unici trovati: ${detectedFormats.size}`);
                    }
                    
                    convertBtn.disabled = false;
                    
                } catch (error) {
                    showStatus('‚ùå Errore nel leggere il file Excel', 'error');
                    addLog(`Errore: ${error.message}`);
                }
            };
            reader.readAsBinaryString(file);
        }

        function convertFile() {
            if (!workbook && !fileData) {
                showStatus('‚ùå Carica prima un file Excel', 'error');
                return;
            }

            // Leggi i parametri dall'interfaccia
            const channelId = document.getElementById('channelId').value.trim();
            const channelName = document.getElementById('channelName').value.trim();
            const timezone = document.getElementById('timezone').value;
            const dateRange = document.getElementById('dateRange').value;
            const fillGaps = document.getElementById('fillGaps').checked;
            const iconUrl = document.getElementById('iconUrl').value.trim();

            addLog('\nüîß CONFIGURAZIONE:');
            addLog(`- Tipo canale: ${currentChannel}`);
            addLog(`- Canale ID: ${channelId}`);
            addLog(`- Nome Canale: ${channelName}`);
            addLog(`- Timezone: ${timezone}`);
            addLog(`- Periodo: ${dateRange}`);
            addLog(`- Gap filling: ${fillGaps ? 'ATTIVO' : 'DISATTIVO'}`);
            addLog('\nInizio conversione...');
            
            try {
                if (currentChannel === 'tvmoda') {
                    xmltvContent = generateXMLTVForTVModa(
                        workbook,
                        channelId,
                        channelName,
                        timezone,
                        iconUrl,
                        dateRange,
                        fillGaps
                    );
                } else {
                    // Genera data base (oggi)
                    const today = new Date();
                    const baseDate = today.getFullYear() + '-' + 
                        String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                        String(today.getDate()).padStart(2, '0');

                    xmltvContent = generateXMLTVForClassCNBC(
                        fileData, 
                        channelId, 
                        channelName, 
                        baseDate, 
                        timezone, 
                        iconUrl, 
                        dateRange, 
                        fillGaps
                    );
                }
                
                showStatus('‚úÖ Conversione completata!', 'success');
                showDownload();
                
            } catch (error) {
                showStatus('‚ùå Errore durante la conversione', 'error');
                addLog(`Errore: ${error.message}`);
                console.error(error);
            }
        }

        function generateXMLTVForTVModa(workbook, channelId, channelName, timezone, iconUrl, dateRange, fillGaps) {
            addLog('Generazione XMLTV per TV Moda...');
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<tv date="${new Date().toISOString().split('T')[0]}">\n`;
            
            // Info canale
            xml += `  <channel id="${channelId}">\n`;
            xml += `    <display-name lang="it">${channelName}</display-name>\n`;
            xml += `  </channel>\n\n`;
            
            // Array per tutti i programmi
            let allPrograms = [];
            
            // Mappa giorni settimana
            const weekdayMap = {
                'DOMENICA': 0,
                'LUNEDI': 1,
                'MARTEDI': 2,
                'MERCOLEDI': 3,
                'GIOVEDI': 4,
                'VENERDI': 5,
                'SABATO': 6
            };
            
            // Calcola date target
            const today = new Date();
            const targetDates = [];
            
            if (dateRange === 'today') {
                targetDates.push(today);
            } else if (dateRange === 'tomorrow') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                targetDates.push(tomorrow);
            } else if (dateRange === 'week') {
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() + i);
                    targetDates.push(date);
                }
            } else {
                // 'all' - processa tutti i fogli disponibili per le prossime settimane
                for (let weekOffset = 0; weekOffset < 4; weekOffset++) { // 4 settimane
                    for (const sheetName of Object.keys(weekdayMap)) {
                        if (workbook.Sheets[sheetName]) {
                            const targetWeekday = weekdayMap[sheetName];
                            const date = new Date(today);
                            // Trova il prossimo giorno della settimana
                            const daysUntilTarget = (targetWeekday - today.getDay() + 7) % 7;
                            date.setDate(today.getDate() + daysUntilTarget + (weekOffset * 7));
                            targetDates.push(date);
                        }
                    }
                }
            }
            
            addLog(`Date target: ${targetDates.map(d => d.toLocaleDateString('it-IT')).join(', ')}`);
            
            // Processa ogni foglio rilevante
            for (const targetDate of targetDates) {
                const targetWeekday = targetDate.getDay();
                const sheetName = Object.keys(weekdayMap).find(key => weekdayMap[key] === targetWeekday);
                
                if (!sheetName || !workbook.Sheets[sheetName]) {
                    addLog(`Foglio ${sheetName} non trovato per ${targetDate.toLocaleDateString('it-IT')}`);
                    continue;
                }
                
                addLog(`\nProcesso ${sheetName} per ${targetDate.toLocaleDateString('it-IT')}...`);
                
                const worksheet = workbook.Sheets[sheetName];
                // IMPORTANTE: Uso raw: true per mantenere i Date objects
                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
                
                let programsInDay = 0;
                
                // Salta le prime righe di intestazione
                for (let i = 3; i < data.length; i++) {
                    const row = data[i];
                    if (!row || row.length < 4) continue;
                    
                    const startTime = row[0];
                    const title = row[1];
                    const duration = row[2];
                    const description = row[3];
                    
                    if (!title || !startTime) continue;
                    
                    // Estrai ora di inizio
                    let programTime;
                    if (startTime instanceof Date || Object.prototype.toString.call(startTime) === '[object Date]') {
                        programTime = new Date(targetDate);
                        programTime.setHours(startTime.getHours(), startTime.getMinutes(), startTime.getSeconds() || 0, 0);
                        
                        if (programsInDay < 5) {
                            addLog(`  Programma: "${title}" alle ${programTime.getHours()}:${String(programTime.getMinutes()).padStart(2, '0')}`);
                        }
                    } else if (typeof startTime === 'string') {
                        // Prova a parsare stringhe come "6/6/25 00:00"
                        try {
                            const tempDate = new Date(startTime);
                            if (!isNaN(tempDate.getTime())) {
                                programTime = new Date(targetDate);
                                programTime.setHours(tempDate.getHours(), tempDate.getMinutes(), 0, 0);
                            } else {
                                addLog(`  Errore parsing ora (string) per "${title}": ${startTime}`);
                                continue;
                            }
                        } catch (e) {
                            addLog(`  Errore parsing ora per "${title}": ${e.message}`);
                            continue;
                        }
                    } else {
                        addLog(`  Tipo ora non riconosciuto per "${title}": ${typeof startTime}`);
                        continue;
                    }
                    
                    // Calcola durata
                    let durationMinutes = 30; // default
                    if (duration) {
                        if (duration instanceof Date || Object.prototype.toString.call(duration) === '[object Date]') {
                            durationMinutes = duration.getHours() * 60 + duration.getMinutes();
                        } else if (typeof duration === 'string') {
                            // Prova diversi formati: "0:10:00", "00:10", "10"
                            const colonMatch = duration.match(/(\d+):(\d+)(?::(\d+))?/);
                            if (colonMatch) {
                                const hours = parseInt(colonMatch[1]) || 0;
                                const minutes = parseInt(colonMatch[2]) || 0;
                                durationMinutes = hours * 60 + minutes;
                            } else if (/^\d+$/.test(duration)) {
                                durationMinutes = parseInt(duration);
                            }
                        }
                    }
                    
                    allPrograms.push({
                        startTime: programTime,
                        title: title,
                        description: description || '',
                        duration: durationMinutes * 60, // in secondi
                        category: 'Fashion', // Categoria default per TV Moda
                        format: title // Il titolo √à il format per TV Moda
                    });
                    
                    programsInDay++;
                }
                
                addLog(`  Trovati ${programsInDay} programmi in ${sheetName}`);
            }
            
            
            addLog(`\nRaccolti ${allPrograms.length} programmi totali`);
            
            // Ordina per data/ora
            allPrograms.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
            
            // Applica gap filling se richiesto
            if (fillGaps && allPrograms.length > 1) {
                addLog('\nApplico gap filling...');
                let gapsFilledCount = 0;
                for (let i = 0; i < allPrograms.length - 1; i++) {
                    const current = allPrograms[i];
                    const next = allPrograms[i + 1];
                    
                    // Solo se sono nello stesso giorno
                    if (current.startTime.toDateString() === next.startTime.toDateString()) {
                        const gap = (next.startTime - current.startTime) / 1000; // in secondi
                        if (gap > current.duration) {
                            current.duration = gap;
                            gapsFilledCount++;
                        }
                    }
                }
                addLog(`Gap riempiti: ${gapsFilledCount}`);
            }
            
            // Genera XML
            for (const program of allPrograms) {
                const endTime = new Date(program.startTime.getTime() + program.duration * 1000);
                
                const formatXMLTVDate = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const seconds = String(date.getSeconds()).padStart(2, '0');
                    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${timezone}`;
                };
                
                xml += `  <programme start="${formatXMLTVDate(program.startTime)}" stop="${formatXMLTVDate(endTime)}" channel="${channelId}">\n`;
                xml += `    <title lang="it">${escapeXml(program.title)}</title>\n`;
                
                if (program.description && program.description.trim() !== '') {
                    xml += `    <desc lang="it">${escapeXml(program.description)}</desc>\n`;
                }
                
                xml += `    <length units="seconds">${program.duration}</length>\n`;
                xml += `    <rating system="Italy Parental Rating">\n`;
                xml += `      <value>0</value>\n`;
                xml += `    </rating>\n`;
                xml += `    <category lang="it">${program.category}</category>\n`;
                
                // Usa l'icona specifica per il format
                const formatIcon = getIconForFormat(program.format, 'tvmoda');
                xml += `    <icon src="${escapeXml(formatIcon)}" width="1920" height="1080"></icon>\n`;
                xml += `  </programme>\n\n`;
            }
            
            xml += '</tv>';
            
            addLog(`\nGenerati ${allPrograms.length} programmi XML`);
            addLog(`Lunghezza XML: ${xml.length} caratteri`);
            
            return xml;
        }

        function generateXMLTVForClassCNBC(data, channelId, channelName, baseDate, timezone, iconUrl, dateRange, fillGaps) {
            addLog('Generazione XMLTV per Class CNBC...');
            
            // Calcola le date target in base alla selezione
            const today = new Date();
            const targetDates = [];
            
            if (dateRange === 'today') {
                const todayStr = today.getFullYear() + '-' + 
                    String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                    String(today.getDate()).padStart(2, '0');
                targetDates.push(todayStr);
            } else if (dateRange === 'tomorrow') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                const tomorrowStr = tomorrow.getFullYear() + '-' + 
                    String(tomorrow.getMonth() + 1).padStart(2, '0') + '-' + 
                    String(tomorrow.getDate()).padStart(2, '0');
                targetDates.push(tomorrowStr);
            } else if (dateRange === 'week') {
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() + i);
                    const dateStr = date.getFullYear() + '-' + 
                        String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                        String(date.getDate()).padStart(2, '0');
                    targetDates.push(dateStr);
                }
            }
            
            addLog(`Date target: ${targetDates.length > 0 ? targetDates.join(', ') : 'TUTTE'}`);
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<tv date="${new Date().toISOString().split('T')[0]}">\n`;
            
            // Info canale
            xml += `  <channel id="${channelId}">\n`;
            xml += `    <display-name lang="it">${channelName}</display-name>\n`;
            xml += `  </channel>\n\n`;
            
            let programCount = 0;
            let currentDate = new Date(baseDate);
            let allPrograms = [];
            
            // FASE 1: Raccolta di tutti i programmi
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                
                if (!row || row.length === 0) continue;
                
                // Cambio di giorno
                if (row.length === 1 && row[0]) {
                    try {
                        let dateToCheck = row[0];
                        if (typeof dateToCheck === 'string') {
                            dateToCheck = new Date(dateToCheck);
                        }
                        
                        if (dateToCheck instanceof Date && !isNaN(dateToCheck.getTime())) {
                            currentDate = new Date(dateToCheck);
                            addLog(`Cambio giorno: ${currentDate.toDateString()}`);
                        }
                    } catch (e) {
                        // Ignora errori di parsing
                    }
                    continue;
                }
                
                // Skip righe che non sono programmi
                if (row.length < 10) continue;
                
                // Parse dati programma
                const timeObj = row[0];
                const title = row[1];
                const programId = row[2];
                const category = row[6] || row[7];
                const rating = row[13];
                const shortDesc = row[15];
                const longDesc = row[16];
                
                if (!title || !programId) continue;
                
                // Estrai l'ora
                let programTime;
                try {
                    let timeToUse = timeObj;
                    if (typeof timeObj === 'string') {
                        timeToUse = new Date(timeObj);
                    }
                    
                    if (timeToUse instanceof Date && !isNaN(timeToUse.getTime())) {
                        programTime = new Date(currentDate);
                        programTime.setHours(timeToUse.getHours(), timeToUse.getMinutes(), timeToUse.getSeconds(), 0);
                    } else {
                        continue;
                    }
                } catch (e) {
                    continue;
                }
                
                // FILTRO: Se ci sono date target, filtra
                if (targetDates.length > 0) {
                    const programDateStr = programTime.getFullYear() + '-' + 
                        String(programTime.getMonth() + 1).padStart(2, '0') + '-' + 
                        String(programTime.getDate()).padStart(2, '0');
                    
                    if (!targetDates.includes(programDateStr)) {
                        continue;
                    }
                }
                
                // Aggiungi il programma all'array
                allPrograms.push({
                    startTime: programTime,
                    title: title,
                    programId: programId,
                    category: category,
                    rating: rating,
                    shortDesc: shortDesc,
                    longDesc: longDesc,
                    format: title // Per ClassCNBC il titolo √® anche il format
                });
                
                programCount++;
            }
            
            addLog(`\nRaccolti ${allPrograms.length} programmi`);
            
            // ORDINAMENTO
            allPrograms.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
            
            // FASE 2: Calcolo durate con gap filling
            if (fillGaps && allPrograms.length > 1) {
                addLog('\nApplico gap filling...');
                
                for (let i = 0; i < allPrograms.length; i++) {
                    const currentProgram = allPrograms[i];
                    let endTime;
                    
                    if (i + 1 < allPrograms.length) {
                        const nextProgram = allPrograms[i + 1];
                        const currentDay = currentProgram.startTime.toDateString();
                        const nextDay = nextProgram.startTime.toDateString();
                        
                        if (currentDay === nextDay) {
                            endTime = new Date(nextProgram.startTime);
                        } else {
                            endTime = new Date(currentProgram.startTime);
                            endTime.setMinutes(endTime.getMinutes() + 30);
                        }
                    } else {
                        endTime = new Date(currentProgram.startTime);
                        endTime.setMinutes(endTime.getMinutes() + 30);
                    }
                    
                    currentProgram.endTime = endTime;
                    currentProgram.duration = Math.max(60, Math.floor((endTime - currentProgram.startTime) / 1000));
                }
            } else {
                for (let i = 0; i < allPrograms.length; i++) {
                    const currentProgram = allPrograms[i];
                    const endTime = new Date(currentProgram.startTime);
                    endTime.setMinutes(endTime.getMinutes() + 30);
                    currentProgram.endTime = endTime;
                    currentProgram.duration = 30 * 60;
                }
            }
            
            // FASE 3: Generazione XML
            for (let i = 0; i < allPrograms.length; i++) {
                const program = allPrograms[i];
                
                const formatXMLTVDate = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const seconds = String(date.getSeconds()).padStart(2, '0');
                    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${timezone}`;
                };
                
                const startFormatted = formatXMLTVDate(program.startTime);
                const endFormatted = formatXMLTVDate(program.endTime);
                
                xml += `  <programme start="${startFormatted}" stop="${endFormatted}" channel="${channelId}">\n`;
                xml += `    <episode-num system="assetID">${escapeXml(program.programId)}</episode-num>\n`;
                xml += `    <title lang="it">${escapeXml(program.title)}</title>\n`;
                
                if (program.longDesc && program.longDesc !== program.title && program.longDesc.trim() !== '') {
                    xml += `    <desc lang="it">${escapeXml(program.longDesc)}</desc>\n`;
                } else if (program.shortDesc && program.shortDesc !== program.title && program.shortDesc.trim() !== '') {
                    xml += `    <desc lang="it">${escapeXml(program.shortDesc)}</desc>\n`;
                }
                
                xml += `    <length units="seconds">${program.duration}</length>\n`;
                
                if (program.rating && program.rating !== 'U' && program.rating.trim() !== '') {
                    const mappedRating = ratingMapping[program.rating] || '0';
                    xml += `    <rating system="Italy Parental Rating">\n`;
                    xml += `      <value>${mappedRating}</value>\n`;
                    xml += `    </rating>\n`;
                } else {
                    xml += `    <rating system="Italy Parental Rating">\n`;
                    xml += `      <value>0</value>\n`;
                    xml += `    </rating>\n`;
                }
                
                if (program.category && program.category.trim() !== '') {
                    const mappedCategory = categoryMapping[program.category] || program.category;
                    xml += `    <category lang="it">${escapeXml(mappedCategory)}</category>\n`;
                }
                
                // Usa l'icona specifica per il format
                const formatIcon = getIconForFormat(program.format, 'classcnbc');
                xml += `    <icon src="${escapeXml(formatIcon)}" width="1920" height="1080"></icon>\n`;
                xml += `  </programme>\n\n`;
            }
            
            xml += '</tv>';
            
            addLog(`\nGenerati ${allPrograms.length} programmi XML`);
            addLog(`Lunghezza XML: ${xml.length} caratteri`);
            
            return xml;
        }

        function escapeXml(text) {
            if (!text) return '';
            return text.toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function showDownload() {
            if (!xmltvContent || xmltvContent.length < 100) {
                addLog('ERRORE: Contenuto XML troppo piccolo o vuoto');
                return;
            }
            
            try {
                const blob = new Blob([xmltvContent], { type: 'application/xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const channelId = document.getElementById('channelId').value.trim().toLowerCase();
                const dateRange = document.getElementById('dateRange').value;
                const dateStr = new Date().toISOString().split('T')[0];
                const filename = `${channelId}_epg_${dateRange}_${dateStr}.xml`;
                
                downloadSection.innerHTML = `
                    <h3>üì• Download File</h3>
                    <a href="${url}" download="${filename}" class="download-link">üíæ Scarica XMLTV (${(blob.size / 1024).toFixed(1)} KB)</a>
                    <p style="color: #666; font-size: 14px;">
                        File generato con successo<br>
                        Canale: ${document.getElementById('channelName').value}<br>
                        Periodo: ${document.getElementById('dateRange').selectedOptions[0].text}
                    </p>
                `;
                downloadSection.style.display = 'block';
                addLog(`File pronto: ${filename} (${blob.size} bytes)`);
            } catch (error) {
                addLog(`Errore creazione download: ${error.message}`);
                showStatus('‚ùå Errore nella creazione del file', 'error');
            }
        }

        // Flag per abilitare/disabilitare la persistenza
        let persistenceEnabled = false;

        // Funzioni per la persistenza opzionale
        function togglePersistence() {
            persistenceEnabled = document.getElementById('enablePersistence').checked;
            
            if (persistenceEnabled) {
                // Salva lo stato corrente
                saveMappingsToLocalStorage();
                showStatus('‚úÖ Salvataggio automatico attivato', 'success');
                addLog('Persistenza localStorage abilitata');
            } else {
                // Opzionale: rimuovi dal localStorage
                if (confirm('Vuoi rimuovere anche i dati salvati nel browser?')) {
                    localStorage.removeItem('epgConverter_tvModaFormatIcons');
                    localStorage.removeItem('epgConverter_classCNBCFormatIcons');
                    localStorage.removeItem('epgConverter_persistenceEnabled');
                    showStatus('‚úÖ Salvataggio automatico disattivato e dati rimossi', 'success');
                } else {
                    showStatus('‚úÖ Salvataggio automatico disattivato', 'success');
                }
                addLog('Persistenza localStorage disabilitata');
            }
            
            // Salva la preferenza
            localStorage.setItem('epgConverter_persistenceEnabled', persistenceEnabled);
        }

        function saveMappingsToLocalStorage() {
            if (!persistenceEnabled) return;
            
            try {
                localStorage.setItem('epgConverter_tvModaFormatIcons', JSON.stringify(tvModaFormatIcons));
                localStorage.setItem('epgConverter_classCNBCFormatIcons', JSON.stringify(classCNBCFormatIcons));
                return true;
            } catch (e) {
                console.error('Errore salvataggio localStorage:', e);
                return false;
            }
        }

        function loadMappingsFromLocalStorage() {
            try {
                // Controlla se la persistenza era abilitata
                const wasPersistenceEnabled = localStorage.getItem('epgConverter_persistenceEnabled') === 'true';
                
                if (wasPersistenceEnabled) {
                    const savedTvModa = localStorage.getItem('epgConverter_tvModaFormatIcons');
                    const savedClassCNBC = localStorage.getItem('epgConverter_classCNBCFormatIcons');
                    
                    if (savedTvModa) {
                        Object.assign(tvModaFormatIcons, JSON.parse(savedTvModa));
                        addLog('Caricate mappature TV Moda da localStorage');
                    }
                    if (savedClassCNBC) {
                        Object.assign(classCNBCFormatIcons, JSON.parse(savedClassCNBC));
                        addLog('Caricate mappature Class CNBC da localStorage');
                    }
                    
                    // Ripristina lo stato della checkbox
                    document.getElementById('enablePersistence').checked = true;
                    persistenceEnabled = true;
                }
            } catch (e) {
                console.error('Errore caricamento localStorage:', e);
            }
        }

        // Modifica le funzioni esistenti per salvare automaticamente se abilitato
        const originalUpdateFormatIcon = updateFormatIcon;
        function updateFormatIcon(format, newUrl) {
            originalUpdateFormatIcon(format, newUrl);
            saveMappingsToLocalStorage();
        }

        const originalAddNewFormat = addNewFormat;
        function addNewFormat() {
            originalAddNewFormat();
            saveMappingsToLocalStorage();
        }

        const originalRemoveFormat = removeFormat;
        function removeFormat(format) {
            originalRemoveFormat(format);
            saveMappingsToLocalStorage();
        }

        const originalSaveMissingFormats = saveMissingFormats;
        function saveMissingFormats() {
            originalSaveMissingFormats();
            saveMappingsToLocalStorage();
        }
        function scanForMissingFormats() {
            if (!workbook && !fileData) {
                showStatus('‚ö†Ô∏è Carica prima un file Excel per verificare i format', 'error');
                return;
            }

            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            const missingFormats = [];

            // Trova i format non presenti nel dizionario
            for (const format of detectedFormats) {
                let found = false;
                // Ricerca case-insensitive
                for (const key of Object.keys(formatIcons)) {
                    if (key.toUpperCase() === format.toUpperCase()) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    missingFormats.push(format);
                }
            }

            if (missingFormats.length === 0) {
                showStatus('‚úÖ Tutti i format nel file hanno un\'icona associata!', 'success');
                addLog('Nessun format mancante rilevato');
                return;
            }

            // Mostra la maschera per i format mancanti
            showMissingFormatsDialog(missingFormats);
        }

        function showMissingFormatsDialog(missingFormats) {
            const dialog = document.getElementById('missingFormatsManager');
            const list = document.getElementById('missingFormatsList');
            
            list.innerHTML = '';
            
            missingFormats.forEach((format, index) => {
                const defaultUrl = `https://via.placeholder.com/1920x1080/${currentChannel === 'tvmoda' ? 'FF1493' : '003366'}/FFFFFF?text=${encodeURIComponent(format.replace(/\s+/g, '+'))}`;
                
                const item = document.createElement('div');
                item.className = 'icon-item';
                item.innerHTML = `
                    <div>
                        <strong>${format}</strong>
                        <div class="icon-preview" style="background-image: url('${defaultUrl}')"></div>
                    </div>
                    <input type="text" 
                           id="missingFormat_${index}" 
                           value="${defaultUrl}" 
                           style="padding: 5px; font-size: 12px;" 
                           placeholder="Inserisci URL icona" 
                           data-format="${format}" />
                    <div class="icon-actions">
                        <button class="btn btn-success btn-small" onclick="testMissingIconUrl(${index})">üëÅÔ∏è Test</button>
                    </div>
                `;
                list.appendChild(item);
            });
            
            dialog.classList.add('active');
            addLog(`Trovati ${missingFormats.length} format mancanti nel dizionario`);
            showStatus(`‚ö†Ô∏è ${missingFormats.length} format non hanno un'icona associata`, 'info');
        }

        function testMissingIconUrl(index) {
            const input = document.getElementById(`missingFormat_${index}`);
            if (input && input.value) {
                window.open(input.value, '_blank');
            }
        }

        function saveMissingFormats() {
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            const inputs = document.querySelectorAll('#missingFormatsList input[type="text"]');
            let addedCount = 0;
            
            inputs.forEach(input => {
                const format = input.getAttribute('data-format');
                const url = input.value.trim();
                if (format && url) {
                    formatIcons[format] = url;
                    addedCount++;
                }
            });
            
            if (addedCount > 0) {
                updateIconList();
                closeMissingFormats();
                showStatus(`‚úÖ Aggiunti ${addedCount} format al dizionario`, 'success');
                addLog(`Aggiunti ${addedCount} nuovi format al dizionario ${currentChannel}`);
            }
        }

        function closeMissingFormats() {
            const dialog = document.getElementById('missingFormatsManager');
            dialog.classList.remove('active');
        }

        // Funzioni per la gestione delle icone
        function toggleIconManager() {
            const manager = document.getElementById('iconManager');
            manager.classList.toggle('active');
            if (manager.classList.contains('active')) {
                updateIconList();
            }
        }

        function updateIconList() {
            const iconList = document.getElementById('iconList');
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            
            iconList.innerHTML = '';
            
            Object.entries(formatIcons).forEach(([format, url]) => {
                const item = document.createElement('div');
                item.className = 'icon-item';
                item.innerHTML = `
                    <div>
                        <strong>${format}</strong>
                        <div class="icon-preview" style="background-image: url('${url}')"></div>
                    </div>
                    <input type="text" value="${url}" onchange="updateFormatIcon('${format}', this.value)" 
                           style="padding: 5px; font-size: 12px;" 
                           placeholder="Inserisci URL icona" />
                    <div class="icon-actions">
                        <button class="btn btn-success btn-small" onclick="testIconUrl('${format}')">üëÅÔ∏è Test</button>
                        <button class="btn btn-danger btn-small" onclick="removeFormat('${format}')">üóëÔ∏è</button>
                    </div>
                `;
                iconList.appendChild(item);
            });
        }

        function updateFormatIcon(format, newUrl) {
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            formatIcons[format] = newUrl;
            
            // Aggiorna l'anteprima immediatamente
            const iconList = document.getElementById('iconList');
            const items = iconList.getElementsByClassName('icon-item');
            for (let item of items) {
                const formatName = item.querySelector('strong').textContent;
                if (formatName === format) {
                    const preview = item.querySelector('.icon-preview');
                    preview.style.backgroundImage = `url('${newUrl}')`;
                    break;
                }
            }
            
            addLog(`Icona aggiornata per format "${format}"`);
        }

        function testIconUrl(format) {
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            const url = formatIcons[format];
            
            if (url) {
                window.open(url, '_blank');
            }
        }

        function removeFormat(format) {
            if (confirm(`Rimuovere il format "${format}"?`)) {
                const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
                delete formatIcons[format];
                updateIconList();
                addLog(`Format "${format}" rimosso`);
            }
        }

        function addNewFormat() {
            const nameInput = document.getElementById('newFormatName');
            const iconInput = document.getElementById('newFormatIcon');
            
            const name = nameInput.value.trim();
            const icon = iconInput.value.trim();
            
            if (!name || !icon) {
                alert('Inserisci sia il nome del format che l\'URL dell\'icona');
                return;
            }
            
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            formatIcons[name] = icon;
            
            nameInput.value = '';
            iconInput.value = '';
            
            updateIconList();
            addLog(`Nuovo format aggiunto: "${name}"`);
        }

        function exportIconMapping() {
            const formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
            const data = {
                channel: currentChannel,
                channelName: channelConfigs[currentChannel].name,
                formatIcons: formatIcons,
                defaultIcon: channelConfigs[currentChannel].icon,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `format-icons-${currentChannel}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            addLog(`Mappatura icone esportata per ${channelConfigs[currentChannel].name}`);
        }

        function importIconMapping() {
            document.getElementById('importFile').click();
        }

        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.formatIcons) {
                        // Verifica quale canale stiamo importando
                        const importChannel = data.channel || currentChannel;
                        let formatIcons;
                        let targetChannelName;
                        
                        if (importChannel === 'tvmoda') {
                            formatIcons = tvModaFormatIcons;
                            targetChannelName = 'TV Moda';
                        } else if (importChannel === 'classcnbc') {
                            formatIcons = classCNBCFormatIcons;
                            targetChannelName = 'Class CNBC';
                        } else {
                            // Se non specificato, usa il canale corrente
                            formatIcons = currentChannel === 'tvmoda' ? tvModaFormatIcons : classCNBCFormatIcons;
                            targetChannelName = currentChannel === 'tvmoda' ? 'TV Moda' : 'Class CNBC';
                        }
                        
                        // Salva una copia del dizionario precedente per confronto
                        const oldIcons = {...formatIcons};
                        const beforeCount = Object.keys(oldIcons).length;
                        
                        // Conta le differenze
                        let newFormats = 0;
                        let modifiedFormats = 0;
                        let removedFormats = 0;
                        
                        // Controlla format modificati e nuovi
                        for (const [format, url] of Object.entries(data.formatIcons)) {
                            if (oldIcons[format]) {
                                if (oldIcons[format] !== url) {
                                    modifiedFormats++;
                                    addLog(`üîÑ Modificato: "${format}"`);
                                }
                            } else {
                                newFormats++;
                                addLog(`‚ûï Nuovo: "${format}"`);
                            }
                        }
                        
                        // Controlla format rimossi
                        for (const format of Object.keys(oldIcons)) {
                            if (!data.formatIcons[format]) {
                                removedFormats++;
                                addLog(`‚ûñ Rimosso: "${format}"`);
                            }
                        }
                        
                        // SOSTITUISCI COMPLETAMENTE il dizionario
                        Object.keys(formatIcons).forEach(key => delete formatIcons[key]);
                        Object.assign(formatIcons, data.formatIcons);
                        
                        const afterCount = Object.keys(formatIcons).length;
                        
                        updateIconList();
                        
                        // Messaggio dettagliato
                        let statusMessage = `‚úÖ Import ${targetChannelName}: ${afterCount} format totali`;
                        if (newFormats > 0) statusMessage += ` (+${newFormats} nuovi)`;
                        if (modifiedFormats > 0) statusMessage += ` (${modifiedFormats} modificati)`;
                        if (removedFormats > 0) statusMessage += ` (-${removedFormats} rimossi)`;
                        
                        showStatus(statusMessage, 'success');
                        addLog(`\nüì• RIEPILOGO IMPORT:`);
                        addLog(`- Canale: ${targetChannelName}`);
                        addLog(`- Format totali: ${afterCount}`);
                        addLog(`- Nuovi: ${newFormats}`);
                        addLog(`- Modificati: ${modifiedFormats}`);
                        addLog(`- Rimossi: ${removedFormats}`);
                        
                        // Se abbiamo importato per un canale diverso da quello corrente, avvisa
                        if (importChannel !== currentChannel) {
                            addLog(`‚ö†Ô∏è Nota: Importati format per ${importChannel} mentre il canale corrente √® ${currentChannel}`);
                        }
                    } else {
                        alert('File non valido: manca la sezione formatIcons');
                    }
                } catch (error) {
                    alert('Errore nel leggere il file: ' + error.message);
                    addLog(`Errore importazione: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Reset input file per permettere di reimportare lo stesso file
            event.target.value = '';
        }

        // Log iniziale
        addLog('üöÄ Convertitore EPG Multi-Canale pronto all\'uso');
        addLog(`üìå Versione ${SOFTWARE_VERSION} (${LAST_UPDATE})`);
        addLog('Seleziona il canale appropriato prima di caricare il file Excel');
        
        // Carica mappature salvate se la persistenza √® abilitata
        loadMappingsFromLocalStorage();
    </script>
</body>
</html>
