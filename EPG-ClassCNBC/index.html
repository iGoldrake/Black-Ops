<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convertitore EPG Multi-Canale Excel a XMLTV</title>
    <style>
        /* Core Styles */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Channel Selector */
        .channel-selector {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .channel-btn {
            background: #e9ecef;
            color: #495057;
            padding: 15px 30px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            margin: 0 10px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        
        .channel-btn.classcnbc-btn {
            background: #003366;
            color: white;
        }
        
        .channel-btn.classcnbc-btn.active {
            background: #004488;
            border-color: #0066cc;
        }
        
        .channel-btn.tvmoda-btn {
            background: #FF1493;
            color: white;
        }
        
        .channel-btn.tvmoda-btn.active {
            background: #FF69B4;
            border-color: #FF1493;
        }
        
        .channel-info {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            display: none;
        }
        
        .channel-info.active {
            display: block;
        }
        
        /* Upload Area */
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            background: #fafafa;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #e8f0fe;
        }
        
        /* Buttons */
        .btn {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        
        .btn:hover {
            background: #5a6fd8;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-small {
            padding: 5px 10px;
            font-size: 14px;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #000;
        }
        
        /* Settings */
        .settings {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        input[type="text"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .checkbox-group {
            margin: 20px 0;
        }
        
        .checkbox-group label {
            display: inline-block;
            margin-left: 8px;
            font-weight: normal;
        }
        
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        
        /* Grid Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .two-columns {
                grid-template-columns: 1fr;
            }
        }
        
        /* Status & Log */
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }
        
        /* Download */
        .download-link {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 5px;
            margin: 10px 0;
            transition: background 0.3s ease;
        }
        
        .download-link:hover {
            background: #1e7e34;
            color: white;
        }
        
        /* Icon Manager */
        .icon-manager {
            background: #f0f4ff;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
        
        .icon-manager.active {
            display: block;
        }
        
        .icon-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 15px 0;
        }
        
        .icon-item {
            display: grid;
            grid-template-columns: 200px 1fr auto;
            gap: 10px;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .icon-item:last-child {
            border-bottom: none;
        }
        
        .icon-preview {
            width: 40px;
            height: 23px;
            background-size: cover;
            background-position: center;
            border: 1px solid #ccc;
            display: inline-block;
            margin-left: 10px;
        }
        
        .add-format-section {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        .icon-actions {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Convertitore EPG Multi-Canale Excel ‚Üí XMLTV</h1>
        <div style="text-align:center;margin-top:-10px;margin-bottom:20px;color:#666;font-size:14px;">
            Versione 2.5.3 - Ultimo aggiornamento: 08/06/2025
        </div>
        
        <div class="channel-selector">
            <h3>Seleziona il canale:</h3>
            <button class="channel-btn classcnbc-btn active" onclick="app.selectChannel('classcnbc')" id="btnClassCNBC">
                <span class="logo-text">CLASS CNBC</span>
            </button>
            <button class="channel-btn tvmoda-btn" onclick="app.selectChannel('tvmoda')" id="btnTVModa">
                <span class="logo-text">CLASS TV MODA</span>
            </button>
        </div>

        <div class="channel-info active" id="infoClassCNBC">
            <h4>üì∫ Class CNBC</h4>
            <p>Formato Excel: File unico con cambio data su righe singole</p>
            <p>Struttura: Ora | Titolo | ID | ... | Categoria | Rating | Descrizioni</p>
        </div>

        <div class="channel-info" id="infoTVModa">
            <h4>üëó Class TV Moda</h4>
            <p>Formato Excel: Un foglio per ogni giorno della settimana</p>
            <p>Struttura: Data/Ora | Titolo | Durata | Descrizione</p>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>üìÅ Trascina qui il file Excel o clicca per selezionarlo</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">Seleziona File Excel</button>
            <input type="file" id="fileInput" accept=".xlsx,.xls" />
        </div>

        <div class="settings">
            <h3>‚öôÔ∏è Impostazioni</h3>
            <div class="two-columns">
                <div>
                    <div class="form-group">
                        <label for="channelId">ID Canale:</label>
                        <input type="text" id="channelId" value="ClassCNBC" />
                    </div>
                    <div class="form-group">
                        <label for="channelName">Nome Canale:</label>
                        <input type="text" id="channelName" value="Class CNBC" />
                    </div>
                    <div class="form-group">
                        <label for="iconUrl">URL Icona Base del Canale:</label>
                        <input type="text" id="iconUrl" value="https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassCNBC_IT_samsung/Images/" readonly style="background:#f0f0f0;" />
                        <small style="display:block;color:#666;margin-top:5px;">
                            URL base per le icone. Ogni format avr√† il suo file specifico (default: default.jpg)
                        </small>
                    </div>
                </div>
                <div>
                    <div class="form-group">
                        <label for="timezone">Timezone di input (conversione automatica in UTC):</label>
                        <select id="timezone">
                            <option value="1">+01:00 (Italia/CET)</option>
                            <option value="0">+00:00 (UTC/GMT)</option>
                            <option value="2">+02:00 (Italia Estate/CEST)</option>
                        </select>
                        <small style="display:block;color:#666;margin-top:5px;">
                            Gli orari nel file Excel verranno convertiti da questa timezone a UTC
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="dateRange">Periodo da convertire:</label>
                        <select id="dateRange">
                            <option value="all">Tutti i giorni disponibili</option>
                            <option value="today">Solo oggi</option>
                            <option value="tomorrow" selected>Solo domani</option>
                            <option value="week">Prossimi 7 giorni</option>
                        </select>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="fillGaps" checked>
                        <label for="fillGaps">Riempi automaticamente i gap temporali</label>
                    </div>
                </div>
            </div>
            <div style="text-align:center;margin-top:20px;">
                <button class="btn btn-small" onclick="app.toggleIconManager()">üé® Gestisci Icone Format</button>
            </div>
        </div>

        <div class="icon-manager" id="iconManager">
            <h3>üé® Gestione Icone Format</h3>
            <p>Modifica le associazioni format ‚Üí icona per il canale selezionato</p>
            <div class="icon-list" id="iconList"></div>
            <div class="add-format-section">
                <h4>‚ûï Aggiungi Nuovo Format</h4>
                <div style="display:grid;grid-template-columns:1fr 2fr auto;gap:10px;">
                    <input type="text" id="newFormatName" placeholder="Nome format" />
                    <input type="text" id="newFormatIcon" placeholder="nome-file.jpg (default: default.jpg)" />
                    <button class="btn btn-success btn-small" onclick="app.addNewFormat()">Aggiungi</button>
                </div>
            </div>
            <div style="text-align:center;margin-top:15px;">
                <button class="btn btn-warning btn-small" onclick="app.scanForMissingFormats()">üîç Verifica Format Mancanti</button>
                <hr style="margin:15px 0;">
                <button class="btn btn-small" onclick="app.exportIconMapping()">üíæ Esporta Mappatura</button>
                <button class="btn btn-small" onclick="app.importIconMapping()">üìÇ Importa Mappatura</button>
                <input type="file" id="importFile" accept=".json" style="display:none;" onchange="app.handleImport(event)" />
            </div>
        </div>

        <button class="btn" id="convertBtn" onclick="app.convertFile()" disabled>üöÄ Converti in XMLTV</button>

        <div id="status"></div>
        <div id="log" class="log" style="display:none;"></div>
        <div id="downloadSection" style="display:none;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
    // EPG Converter Application - Modular Architecture
    class EPGConverter {
        constructor() {
            this.SOFTWARE_VERSION = "2.5.3";
            this.LAST_UPDATE = "08/06/2025";
            this.fileData = null;
            this.xmltvContent = '';
            this.currentChannel = 'classcnbc';
            this.workbook = null;
            this.detectedFormats = new Set();
            
            this.config = {
                channels: {
                    classcnbc: {
                        id: 'ClassCNBC',
                        name: 'Class CNBC',
                        baseIconUrl: 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassCNBC_IT_samsung/Images/'
                    },
                    tvmoda: {
                        id: 'ClassTVModa',
                        name: 'Class TV Moda',
                        baseIconUrl: 'https://df4c28da231b4c30821e57d5f2111c23.msvdn.net/feeds/epg/ClassTVModa_IT_samsung/Images/'
                    }
                },
                formatIcons: {
                    tvmoda: this.getTVModaFormats(),
                    classcnbc: this.getClassCNBCFormats()
                },
                categoryMapping: this.getCategoryMapping(),
                ratingMapping: this.getRatingMapping()
            };
            
            this.init();
        }
        
        init() {
            this.setupEventListeners();
            this.addLog('üöÄ Convertitore EPG Multi-Canale pronto all\'uso');
            this.addLog('Seleziona il canale appropriato prima di caricare il file Excel');
        }
        
        setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    this.handleFile(e.target.files[0]);
                }
            });
        }
        
        getTVModaFormats() {
            return {
                "(UN)ACCESSING BACKSTAGE": "default.jpg",
                "CATWALKS": "default.jpg",
                "CLASS TV MODA STORIES": "default.jpg",
                "DESIGN MAP": "default.jpg",
                "DISTRICTS": "default.jpg",
                "FASHION NEWS": "default.jpg",
                "FASHION&BEYOND": "default.jpg",
                "FRONT ROW": "default.jpg",
                "GREEN REVOLUTION FORWARD": "default.jpg",
                "SOUND OF FASHION": "default.jpg",
                "SPOTLIGHT": "default.jpg",
                "VOICES": "default.jpg",
                "WHAT WOMEN WEAR": "default.jpg",
                "Programmazione notturna": "default.jpg",
                "Programmazione": "default.jpg"
            };
        }
        
        getClassCNBCFormats() {
            return {
                "Business Class": "default.jpg",
                "Mercati in 10 minuti": "default.jpg",
                "Class Meteo": "default.jpg",
                "Trading Room": "default.jpg",
                "Tradingroom": "default.jpg",
                "Borse Oggi": "default.jpg",
                "Apertura Mercati": "default.jpg",
                "Market Driver": "default.jpg",
                "Wall Street": "default.jpg",
                "Chiusura Mercati": "default.jpg",
                "Business Talk": "default.jpg",
                "Class Life": "default.jpg",
                "Report": "default.jpg",
                "Documentario": "default.jpg",
                "Gli speciali settimanali di Class Cnbc": "default.jpg",
                "4cLegal Academy Pt 5": "default.jpg",
                "Caffe' Affari": "default.jpg",
                "Analisi Tecnica": "default.jpg",
                "Linea Mercati": "default.jpg",
                "Growth Italia": "default.jpg",
                "Gli speciali di Class Cnbc": "default.jpg",
                "Trading Nation": "default.jpg",
                "Market Movers": "default.jpg",
                "Linea Mercati Wall Street": "default.jpg",
                "Linea Mercati Notte": "default.jpg",
                "La giornata di Class Cnbc": "default.jpg",
                "4cLegal Academy Pt 6": "default.jpg",
                "Fabi risponde": "default.jpg",
                "Speciale Mondi da scoprire Pt 4": "default.jpg",
                "BCE - annuncio tassi": "default.jpg",
                "BCE - conferenza stampa": "default.jpg",
                "The Floor": "default.jpg",
                "5 Giorni Sui Mercati": "default.jpg",
                "4cLegal Academy Pt 7": "default.jpg",
                "Gli speciali di ClassCnbc": "default.jpg",
                "4cLegal Academy Pt 8": "default.jpg",
                "Speciale FED": "default.jpg",
                "4cLegal Academy Pt 9": "default.jpg",
                "Programmazione notturna": "default.jpg",
                "Programmazione": "default.jpg"
            };
        }
        
        getCategoryMapping() {
            return {
                'Informazione': 'News',
                'Economia': 'Business',
                'Intrattenimento': 'Entertainment',
                'Sport': 'Sports',
                'Musica': 'Music',
                'Documentario': 'Documentary',
                'Cultura': 'Arts/Culture',
                'Cucina': 'Cooking',
                'Travel': 'Travel',
                'Talk': 'Talk Show',
                'Reality': 'Reality',
                'Film': 'Movie',
                'Fashion': 'Fashion',
                'Lifestyle': 'Lifestyle'
            };
        }
        
        getRatingMapping() {
            return {
                'U': '0',
                'T': '6',
                'VM14': '14',
                'VM18': '18',
                '6': '6',
                '12': '12',
                '14': '14',
                '16': '16',
                '18': '18'
            };
        }
        
        selectChannel(channel) {
            this.currentChannel = channel;
            
            document.querySelectorAll('.channel-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.channel-info').forEach(info => info.classList.remove('active'));
            
            if (channel === 'classcnbc') {
                document.getElementById('btnClassCNBC').classList.add('active');
                document.getElementById('infoClassCNBC').classList.add('active');
            } else {
                document.getElementById('btnTVModa').classList.add('active');
                document.getElementById('infoTVModa').classList.add('active');
            }
            
            const config = this.config.channels[channel];
            document.getElementById('channelId').value = config.id;
            document.getElementById('channelName').value = config.name;
            document.getElementById('iconUrl').value = config.baseIconUrl;
            
            const iconManager = document.getElementById('iconManager');
            if (iconManager.classList.contains('active')) {
                this.updateIconList();
            }
            
            this.addLog(`Canale selezionato: ${config.name}`);
        }
        
        showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        addLog(message) {
            const logDiv = document.getElementById('log');
            logDiv.style.display = 'block';
            logDiv.innerHTML += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        handleFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/i)) {
                this.showStatus('‚ö†Ô∏è Seleziona un file Excel (.xlsx o .xls)', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    this.workbook = XLSX.read(e.target.result, {
                        type: 'binary',
                        cellDates: true,
                        cellNF: false,
                        cellText: false
                    });
                    
                    this.detectedFormats.clear();
                    
                    if (this.currentChannel === 'tvmoda') {
                        this.handleTVModaFile(file);
                    } else {
                        this.handleClassCNBCFile(file);
                    }
                    
                    document.getElementById('convertBtn').disabled = false;
                    
                } catch (error) {
                    this.showStatus('‚ùå Errore nel leggere il file Excel', 'error');
                    this.addLog(`Errore: ${error.message}`);
                }
            };
            reader.readAsBinaryString(file);
        }
        
        handleTVModaFile(file) {
            const expectedSheets = ['SABATO', 'DOMENICA', 'LUNEDI', 'MARTEDI', 'MERCOLEDI', 'GIOVEDI', 'VENERDI'];
            const hasWeekdaySheets = expectedSheets.some(sheet => this.workbook.SheetNames.includes(sheet));
            
            if (!hasWeekdaySheets) {
                this.showStatus('‚ö†Ô∏è File non compatibile con TV Moda. Assicurati di aver selezionato il canale corretto.', 'error');
                return;
            }
            
            for (const sheetName of this.workbook.SheetNames) {
                if (expectedSheets.includes(sheetName)) {
                    const worksheet = this.workbook.Sheets[sheetName];
                    const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
                    
                    for (let i = 3; i < data.length; i++) {
                        const row = data[i];
                        if (row && row[1] && typeof row[1] === 'string') {
                            this.detectedFormats.add(row[1].trim());
                        }
                    }
                }
            }
            
            this.showStatus(`‚úÖ File TV Moda caricato: ${file.name} (${this.workbook.SheetNames.length} fogli, ${this.detectedFormats.size} format unici trovati)`, 'success');
            this.addLog(`File TV Moda caricato con fogli: ${this.workbook.SheetNames.join(', ')}`);
            this.addLog(`Format unici trovati: ${this.detectedFormats.size}`);
        }
        
        handleClassCNBCFile(file) {
            const sheetName = this.workbook.SheetNames[0];
            const worksheet = this.workbook.Sheets[sheetName];
            this.fileData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
            
            for (let i = 1; i < this.fileData.length; i++) {
                const row = this.fileData[i];
                if (row && row[1] && typeof row[1] === 'string' && row.length > 10) {
                    this.detectedFormats.add(row[1].trim());
                }
            }
            
            this.showStatus(`‚úÖ File Class CNBC caricato: ${file.name} (${this.fileData.length} righe, ${this.detectedFormats.size} format unici trovati)`, 'success');
            this.addLog(`File Class CNBC caricato: ${sheetName} con ${this.fileData.length} righe`);
            this.addLog(`Format unici trovati: ${this.detectedFormats.size}`);
        }
        
        convertFile() {
            if (!this.workbook && !this.fileData) {
                this.showStatus('‚ùå Carica prima un file Excel', 'error');
                return;
            }
            
            const channelId = document.getElementById('channelId').value.trim();
            const channelName = document.getElementById('channelName').value.trim();
            const timezoneOffset = parseInt(document.getElementById('timezone').value);
            const dateRange = document.getElementById('dateRange').value;
            const fillGaps = document.getElementById('fillGaps').checked;
            const iconUrl = document.getElementById('iconUrl').value.trim();
            
            this.addLog('\nüîß CONFIGURAZIONE:');
            this.addLog(`- Tipo canale: ${this.currentChannel}`);
            this.addLog(`- Canale ID: ${channelId}`);
            this.addLog(`- Nome Canale: ${channelName}`);
            this.addLog(`- Timezone input: UTC${timezoneOffset >= 0 ? '+' : ''}${timezoneOffset}`);
            this.addLog(`- Output: UTC (conversione automatica)`);
            this.addLog(`- Periodo: ${dateRange}`);
            this.addLog(`- Gap filling: ${fillGaps ? 'ATTIVO' : 'DISATTIVO'}`);
            this.addLog('\n‚ö†Ô∏è NOTA: Gli orari nel file XML saranno in UTC.');
            this.addLog(`  Un programma alle 01:00 italiane (UTC+${timezoneOffset}) apparir√† come 23:00 UTC del giorno precedente.`);
            this.addLog('\nInizio conversione...');
            
            try {
                const converter = new XMLTVGenerator(this);
                
                if (this.currentChannel === 'tvmoda') {
                    this.xmltvContent = converter.generateXMLTVForTVModa(
                        this.workbook,
                        channelId,
                        channelName,
                        timezoneOffset,
                        iconUrl,
                        dateRange,
                        fillGaps
                    );
                } else {
                    const today = new Date();
                    const baseDate = today.getFullYear() + '-' +
                        String(today.getMonth() + 1).padStart(2, '0') + '-' +
                        String(today.getDate()).padStart(2, '0');
                    
                    this.xmltvContent = converter.generateXMLTVForClassCNBC(
                        this.fileData,
                        channelId,
                        channelName,
                        baseDate,
                        timezoneOffset,
                        iconUrl,
                        dateRange,
                        fillGaps
                    );
                }
                
                this.showStatus('‚úÖ Conversione completata!', 'success');
                this.showDownload();
                
            } catch (error) {
                this.showStatus('‚ùå Errore durante la conversione', 'error');
                this.addLog(`Errore: ${error.message}`);
                console.error(error);
            }
        }
        
        showDownload() {
            if (!this.xmltvContent || this.xmltvContent.length < 100) {
                this.addLog('ERRORE: Contenuto XML troppo piccolo o vuoto');
                return;
            }
            
            try {
                const blob = new Blob([this.xmltvContent], { type: 'application/xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const filename = `${year}-${month}-${day}.xml`;
                
                const downloadSection = document.getElementById('downloadSection');
                downloadSection.innerHTML = `
                    <h3>üì• Download File</h3>
                    <a href="${url}" download="${filename}" class="download-link">üíæ Scarica XMLTV (${(blob.size / 1024).toFixed(1)} KB)</a>
                    <p style="color:#666;font-size:14px;">
                        File generato con successo<br>
                        Canale: ${document.getElementById('channelName').value}<br>
                        Periodo: ${document.getElementById('dateRange').selectedOptions[0].text}<br>
                        Nome file: ${filename}
                    </p>
                `;
                downloadSection.style.display = 'block';
                this.addLog(`File pronto: ${filename} (${blob.size} bytes)`);
            } catch (error) {
                this.addLog(`Errore creazione download: ${error.message}`);
                this.showStatus('‚ùå Errore nella creazione del file', 'error');
            }
        }
        
        toggleIconManager() {
            const manager = document.getElementById('iconManager');
            manager.classList.toggle('active');
            if (manager.classList.contains('active')) {
                this.updateIconList();
            }
        }
        
        updateIconList() {
            const iconList = document.getElementById('iconList');
            const formatIcons = this.config.formatIcons[this.currentChannel];
            
            iconList.innerHTML = '';
            
            Object.entries(formatIcons).forEach(([format, url]) => {
                const item = document.createElement('div');
                item.className = 'icon-item';
                item.innerHTML = `
                    <div>
                        <strong>${format}</strong>
                        <div class="icon-preview" style="background-image: url('${this.config.channels[this.currentChannel].baseIconUrl}${url}')"></div>
                    </div>
                    <input type="text" value="${url}" onchange="app.updateFormatIcon('${format}', this.value)" />
                    <div class="icon-actions">
                        <button class="btn btn-danger btn-small" onclick="app.removeFormat('${format}')">üóëÔ∏è</button>
                    </div>
                `;
                iconList.appendChild(item);
            });
        }
        
        updateFormatIcon(format, newUrl) {
            const formatIcons = this.config.formatIcons[this.currentChannel];
            formatIcons[format] = newUrl;
            this.addLog(`Icona aggiornata per format "${format}"`);
        }
        
        removeFormat(format) {
            if (confirm(`Rimuovere il format "${format}"?`)) {
                const formatIcons = this.config.formatIcons[this.currentChannel];
                delete formatIcons[format];
                this.updateIconList();
                this.addLog(`Format "${format}" rimosso`);
            }
        }
        
        addNewFormat() {
            const nameInput = document.getElementById('newFormatName');
            const iconInput = document.getElementById('newFormatIcon');
            
            const name = nameInput.value.trim();
            const icon = iconInput.value.trim() || 'default.jpg';
            
            if (!name) {
                alert('Inserisci il nome del format');
                return;
            }
            
            const formatIcons = this.config.formatIcons[this.currentChannel];
            formatIcons[name] = icon;
            
            nameInput.value = '';
            iconInput.value = '';
            
            this.updateIconList();
            this.addLog(`Nuovo format aggiunto: "${name}"`);
        }
        
        scanForMissingFormats() {
            if (this.detectedFormats.size === 0) {
                alert('Carica prima un file Excel per verificare i format mancanti');
                return;
            }
            
            const formatIcons = this.config.formatIcons[this.currentChannel];
            const missingFormats = [];
            
            for (const format of this.detectedFormats) {
                const normalizedFormat = format.trim().toUpperCase();
                let found = false;
                
                for (const key of Object.keys(formatIcons)) {
                    if (key.toUpperCase() === normalizedFormat) {
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    missingFormats.push(format);
                }
            }
            
            if (missingFormats.length === 0) {
                alert('‚úÖ Tutti i format trovati nel file hanno un\'icona associata!');
            } else {
                alert(`‚ö†Ô∏è Format mancanti: ${missingFormats.length}\n\n${missingFormats.join('\n')}`);
            }
        }
        
        exportIconMapping() {
            const formatIcons = this.config.formatIcons[this.currentChannel];
            const data = {
                channel: this.currentChannel,
                channelName: this.config.channels[this.currentChannel].name,
                formatIcons: formatIcons,
                defaultIcon: this.config.channels[this.currentChannel].baseIconUrl + 'default.jpg',
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `format-icons-${this.currentChannel}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            this.addLog(`Mappatura icone esportata per ${this.config.channels[this.currentChannel].name}`);
        }
        
        importIconMapping() {
            document.getElementById('importFile').click();
        }
        
        handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.formatIcons) {
                        const formatIcons = this.config.formatIcons[this.currentChannel];
                        
                        Object.keys(formatIcons).forEach(key => delete formatIcons[key]);
                        Object.assign(formatIcons, data.formatIcons);
                        
                        this.updateIconList();
                        this.addLog(`Mappatura icone importata con successo (${Object.keys(data.formatIcons).length} format)`);
                    } else {
                        alert('File non valido: manca la sezione formatIcons');
                    }
                } catch (error) {
                    alert('Errore nel leggere il file: ' + error.message);
                    this.addLog(`Errore importazione: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }
    }
    
    // XMLTV Generator Module
    class XMLTVGenerator {
        constructor(app) {
            this.app = app;
        }
        
        escapeXml(text) {
            if (!text) return '';
            return text.toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        formatXMLTVDate(date, timezoneOffset) {
            // Convert to UTC by subtracting the timezone offset
            const utcDate = new Date(date.getTime() - (timezoneOffset * 60 * 60 * 1000));
            
            const year = utcDate.getUTCFullYear();
            const month = String(utcDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(utcDate.getUTCDate()).padStart(2, '0');
            const hours = String(utcDate.getUTCHours()).padStart(2, '0');
            const minutes = String(utcDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(utcDate.getUTCSeconds()).padStart(2, '0');
            
            // Return ISO 8601 format with UTC timezone
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+0000`;
        }
        
        getIconForFormat(format, channel) {
            if (!format) return this.app.config.channels[channel].baseIconUrl + 'default.jpg';
            const formatIcons = this.app.config.formatIcons[channel];
            const normalizedFormat = format.trim().toUpperCase();
            
            for (const [key, value] of Object.entries(formatIcons)) {
                if (key.toUpperCase() === normalizedFormat) {
                    return this.app.config.channels[channel].baseIconUrl + value;
                }
            }
            
            return this.app.config.channels[channel].baseIconUrl + 'default.jpg';
        }
        
        generateXMLTVForTVModa(workbook, channelId, channelName, timezoneOffset, iconUrl, dateRange, fillGaps) {
            this.app.addLog('Generazione XMLTV per TV Moda...');
            this.app.addLog(`Conversione orari da UTC${timezoneOffset >= 0 ? '+' : ''}${timezoneOffset} a UTC`);
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<tv date="${new Date().toISOString().split('T')[0]}">\n`;
            xml += `  <channel id="${channelId}">\n`;
            xml += `    <display-name lang="it">${channelName}</display-name>\n`;
            xml += `  </channel>\n\n`;
            
            const programs = this.parseTVModaPrograms(workbook, dateRange);
            const processedPrograms = this.processProgramsForOutput(programs, dateRange, fillGaps, 'tvmoda');
            
            for (const program of processedPrograms) {
                xml += this.generateProgrammeXML(program, channelId, timezoneOffset, 'tvmoda');
            }
            
            xml += '</tv>';
            
            this.app.addLog(`\nGenerati ${processedPrograms.length} programmi XML`);
            this.app.addLog(`Lunghezza XML: ${xml.length} caratteri`);
            
            return xml;
        }
        
        generateXMLTVForClassCNBC(data, channelId, channelName, baseDate, timezoneOffset, iconUrl, dateRange, fillGaps) {
            this.app.addLog('Generazione XMLTV per Class CNBC...');
            this.app.addLog(`Conversione orari da UTC${timezoneOffset >= 0 ? '+' : ''}${timezoneOffset} a UTC`);
            
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += `<tv date="${new Date().toISOString().split('T')[0]}">\n`;
            xml += `  <channel id="${channelId}">\n`;
            xml += `    <display-name lang="it">${channelName}</display-name>\n`;
            xml += `  </channel>\n\n`;
            
            const programs = this.parseClassCNBCPrograms(data, baseDate, dateRange);
            const processedPrograms = this.processProgramsForOutput(programs, dateRange, fillGaps, 'classcnbc');
            
            for (const program of processedPrograms) {
                xml += this.generateProgrammeXML(program, channelId, timezoneOffset, 'classcnbc');
            }
            
            xml += '</tv>';
            
            this.app.addLog(`\nGenerati ${processedPrograms.length} programmi XML`);
            this.app.addLog(`Lunghezza XML: ${xml.length} caratteri`);
            
            return xml;
        }
        
        parseTVModaPrograms(workbook, dateRange) {
            const weekdayMap = {
                'DOMENICA': 0, 'LUNEDI': 1, 'MARTEDI': 2, 'MERCOLEDI': 3,
                'GIOVEDI': 4, 'VENERDI': 5, 'SABATO': 6
            };
            
            const targetDates = this.getTargetDates(dateRange, workbook, weekdayMap);
            const allPrograms = [];
            const processedProgramKeys = new Set(); // Per evitare duplicati
            
            // NON estendere le date per TV Moda - processa solo i giorni target
            for (const targetDate of targetDates) {
                const targetWeekday = targetDate.getDay();
                const sheetName = Object.keys(weekdayMap).find(key => weekdayMap[key] === targetWeekday);
                
                if (!sheetName || !workbook.Sheets[sheetName]) continue;
                
                this.app.addLog(`\nProcesso ${sheetName} per ${targetDate.toLocaleDateString('it-IT')}...`);
                
                const worksheet = workbook.Sheets[sheetName];
                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true });
                
                const dayPrograms = this.parseTVModaDayPrograms(data, targetDate);
                
                // Aggiungi solo programmi non ancora processati
                for (const program of dayPrograms) {
                    const key = `${program.startTime.getTime()}_${program.title}`;
                    if (!processedProgramKeys.has(key)) {
                        processedProgramKeys.add(key);
                        allPrograms.push(program);
                    }
                }
                
                this.app.addLog(`  Trovati ${dayPrograms.length} programmi in ${sheetName}`);
            }
            
            return allPrograms;
        }
        
        parseTVModaDayPrograms(data, currentDate) {
            const programs = [];
            
            for (let i = 3; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length < 4) continue;
                
                const startTime = row[0];
                const title = row[1];
                const duration = row[2];
                const description = row[3];
                
                if (!title || !startTime) continue;
                
                const programTime = this.parseTime(startTime, currentDate);
                if (!programTime) continue;
                
                const durationMinutes = this.parseDuration(duration);
                
                programs.push({
                    startTime: programTime,
                    endTime: new Date(programTime.getTime() + durationMinutes * 60 * 1000),
                    title: title,
                    description: description || '',
                    duration: durationMinutes * 60,
                    category: 'Fashion',
                    format: title
                });
            }
            
            return programs;
        }
        
        parseClassCNBCPrograms(data, baseDate, dateRange) {
            const allPrograms = [];
            let currentDate = new Date(baseDate);
            const extendedDates = this.getExtendedDatesForRange(dateRange);
            
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                
                if (!row || row.length === 0) continue;
                
                // Check for date change
                if (row.length === 1 && row[0]) {
                    const newDate = this.parseDate(row[0]);
                    if (newDate) {
                        currentDate = newDate;
                        this.app.addLog(`Cambio giorno: ${currentDate.toDateString()}`);
                    }
                    continue;
                }
                
                if (row.length < 10) continue;
                
                const program = this.parseClassCNBCProgram(row, currentDate);
                if (program && this.isProgramInDateRange(program, extendedDates)) {
                    allPrograms.push(program);
                }
            }
            
            return allPrograms;
        }
        
        parseClassCNBCProgram(row, currentDate) {
            const timeObj = row[0];
            const title = row[1];
            const programId = row[2];
            const category = row[6] || row[7];
            const rating = row[13];
            const shortDesc = row[15];
            const longDesc = row[16];
            
            if (!title || !programId) return null;
            
            const programTime = this.parseTime(timeObj, currentDate);
            if (!programTime) return null;
            
            return {
                startTime: programTime,
                title: title,
                programId: programId,
                category: category,
                rating: rating,
                shortDesc: shortDesc,
                longDesc: longDesc,
                format: title
            };
        }
        
        processProgramsForOutput(allPrograms, dateRange, fillGaps, channel) {
            // Sort programs by start time
            allPrograms.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
            
            // Calculate durations BEFORE splitting by day
            this.calculateDurations(allPrograms, fillGaps);
            
            // Get target dates for output
            const targetDates = this.getOutputTargetDates(dateRange);
            
            // Process each target date
            const finalPrograms = [];
            const processedKeys = new Set(); // Evita duplicati nell'output finale
            
            for (const targetDate of targetDates) {
                const dayPrograms = this.processDayPrograms(allPrograms, targetDate, channel);
                
                // Aggiungi solo programmi non duplicati
                for (const program of dayPrograms) {
                    const key = `${program.startTime.getTime()}_${program.title}`;
                    if (!processedKeys.has(key)) {
                        processedKeys.add(key);
                        finalPrograms.push(program);
                    }
                }
            }
            
            return finalPrograms;
        }
        
        processDayPrograms(allPrograms, targetDate, channel) {
            const targetStart = new Date(targetDate);
            targetStart.setHours(0, 0, 0, 0);
            const targetEnd = new Date(targetDate);
            targetEnd.setHours(23, 59, 59, 999);
            
            this.app.addLog(`\nProcesso programmi per ${targetDate.toLocaleDateString('it-IT')}...`);
            
            // Find programs that overlap with this day
            const dayPrograms = allPrograms.filter(program => {
                return (program.startTime >= targetStart && program.startTime <= targetEnd) ||
                       (program.endTime >= targetStart && program.endTime <= targetEnd) ||
                       (program.startTime < targetStart && program.endTime > targetEnd);
            });
            
            this.app.addLog(`  Trovati ${dayPrograms.length} programmi che toccano questa giornata`);
            
            // Remove duplicates based on start time and title
            const uniquePrograms = this.removeDuplicatePrograms(dayPrograms);
            this.app.addLog(`  Dopo rimozione duplicati: ${uniquePrograms.length} programmi`);
            
            // Check for overlaps before processing
            this.checkForOverlaps(uniquePrograms);
            
            // Adjust programs to fit within the day
            const adjustedPrograms = this.adjustProgramsForDay(uniquePrograms, targetStart, targetEnd);
            
            // Fill gaps with filler content
            const filledPrograms = this.fillGapsInDay(adjustedPrograms, targetStart, targetEnd, channel);
            
            const totalMinutes = filledPrograms.reduce((sum, p) => sum + (p.duration / 60), 0);
            this.app.addLog(`  ‚úÖ Copertura totale: ${totalMinutes.toFixed(0)} minuti (su 1440 attesi)`);
            
            return filledPrograms;
        }
        
        adjustProgramsForDay(programs, targetStart, targetEnd) {
            const adjusted = [];
            
            for (const program of programs) {
                const adjustedProgram = { ...program };
                
                if (program.startTime < targetStart) {
                    adjustedProgram.startTime = new Date(targetStart);
                    adjustedProgram.wasAdjustedStart = true;
                    this.app.addLog(`  Adattato inizio di "${program.title}" da ${program.startTime.toLocaleTimeString('it-IT')} a 00:00:00`);
                }
                
                if (program.endTime > targetEnd) {
                    adjustedProgram.endTime = new Date(targetEnd);
                    adjustedProgram.endTime.setSeconds(59);
                    adjustedProgram.wasAdjustedEnd = true;
                    this.app.addLog(`  Adattato fine di "${program.title}" da ${program.endTime.toLocaleTimeString('it-IT')} a 23:59:59`);
                }
                
                adjustedProgram.duration = Math.floor((adjustedProgram.endTime - adjustedProgram.startTime) / 1000);
                
                if (adjustedProgram.duration > 0) {
                    adjusted.push(adjustedProgram);
                }
            }
            
            return adjusted.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
        }
        
        fillGapsInDay(programs, targetStart, targetEnd, channel) {
            if (programs.length === 0) {
                this.app.addLog(`  ‚ö†Ô∏è Nessun programma trovato - creo filler per l'intera giornata`);
                return [this.createFillerProgram(targetStart, targetEnd, channel, true)];
            }
            
            const filled = [];
            let currentTime = new Date(targetStart);
            
            for (const program of programs) {
                // Fill gap before program
                if (program.startTime > currentTime) {
                    const gapMinutes = (program.startTime - currentTime) / (1000 * 60);
                    this.app.addLog(`  ‚ö†Ô∏è Buco di ${gapMinutes.toFixed(0)} minuti prima di "${program.title}"`);
                    filled.push(this.createFillerProgram(currentTime, program.startTime, channel, false));
                }
                
                filled.push(program);
                currentTime = new Date(program.endTime);
            }
            
            // Fill gap at end of day
            if (currentTime < targetEnd) {
                const gapMinutes = (targetEnd - currentTime) / (1000 * 60);
                this.app.addLog(`  ‚ö†Ô∏è Buco di ${gapMinutes.toFixed(0)} minuti alla fine della giornata`);
                
                const fillerEnd = new Date(targetEnd);
                fillerEnd.setSeconds(59);
                filled.push(this.createFillerProgram(currentTime, fillerEnd, channel, false));
            }
            
            return filled;
        }
        
        createFillerProgram(startTime, endTime, channel, isFullDay) {
            const title = isFullDay ? "Programmazione" : "Programmazione notturna";
            return {
                startTime: new Date(startTime),
                endTime: new Date(endTime),
                title: title,
                programId: channel === 'classcnbc' ? (isFullDay ? "FILLER_DAY" : "FILLER_NIGHT") : undefined,
                description: title,
                duration: (endTime - startTime) / 1000,
                category: channel === 'tvmoda' ? 'Fashion' : 'Informazione',
                format: title,
                isFiller: true
            };
        }
        
        generateProgrammeXML(program, channelId, timezoneOffset, channel) {
            let xml = `  <programme start="${this.formatXMLTVDate(program.startTime, timezoneOffset)}" stop="${this.formatXMLTVDate(program.endTime, timezoneOffset)}" channel="${channelId}">\n`;
            
            if (program.programId) {
                xml += `    <episode-num system="assetID">${this.escapeXml(program.programId)}</episode-num>\n`;
            }
            
            xml += `    <title lang="it">${this.escapeXml(program.title)}</title>\n`;
            
            // Add description
            const description = this.getDescription(program);
            if (description) {
                xml += `    <desc lang="it">${this.escapeXml(description)}</desc>\n`;
            }
            
            xml += `    <length units="seconds">${program.duration}</length>\n`;
            
            // Add rating
            const rating = this.getRating(program);
            xml += `    <rating system="Italy Parental Rating">\n`;
            xml += `      <value>${rating}</value>\n`;
            xml += `    </rating>\n`;
            
            // Add category
            if (program.category) {
                const mappedCategory = this.app.config.categoryMapping[program.category] || program.category;
                xml += `    <category lang="it">${this.escapeXml(mappedCategory)}</category>\n`;
            }
            
            // Add icon
            const formatIcon = this.getIconForFormat(program.format, channel);
            xml += `    <icon src="${this.escapeXml(formatIcon)}" width="1920" height="1080"></icon>\n`;
            xml += `  </programme>\n\n`;
            
            return xml;
        }
        
        // Utility methods
        parseTime(timeObj, baseDate) {
            let programTime;
            
            try {
                if (timeObj instanceof Date || Object.prototype.toString.call(timeObj) === '[object Date]') {
                    programTime = new Date(baseDate);
                    programTime.setHours(timeObj.getHours(), timeObj.getMinutes(), timeObj.getSeconds() || 0, 0);
                } else if (typeof timeObj === 'string') {
                    const tempDate = new Date(timeObj);
                    if (!isNaN(tempDate.getTime())) {
                        programTime = new Date(baseDate);
                        programTime.setHours(tempDate.getHours(), tempDate.getMinutes(), 0, 0);
                    }
                }
            } catch (e) {
                return null;
            }
            
            return programTime;
        }
        
        removeDuplicatePrograms(programs) {
            const seen = new Map();
            const unique = [];
            
            for (const program of programs) {
                // Create a unique key based on start time and title
                const key = `${program.startTime.getTime()}_${program.title}`;
                
                if (!seen.has(key)) {
                    seen.set(key, true);
                    unique.push(program);
                } else {
                    this.app.addLog(`  ‚ö†Ô∏è Duplicato rimosso: "${program.title}" alle ${program.startTime.toLocaleTimeString('it-IT')}`);
                }
            }
            
            return unique.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
        }
        
        checkForOverlaps(programs) {
            for (let i = 0; i < programs.length - 1; i++) {
                const current = programs[i];
                const next = programs[i + 1];
                
                if (current.endTime > next.startTime) {
                    const overlapMinutes = (current.endTime - next.startTime) / (1000 * 60);
                    this.app.addLog(`  ‚ö†Ô∏è SOVRAPPOSIZIONE: "${current.title}" finisce alle ${current.endTime.toLocaleTimeString('it-IT')} ma "${next.title}" inizia alle ${next.startTime.toLocaleTimeString('it-IT')} (${overlapMinutes.toFixed(1)} minuti di sovrapposizione)`);
                    
                    // Auto-fix: adjust the end time of current program
                    current.endTime = new Date(next.startTime);
                    current.duration = Math.floor((current.endTime - current.startTime) / 1000);
                    this.app.addLog(`  ‚úÖ Auto-fix: aggiustata fine di "${current.title}" alle ${current.endTime.toLocaleTimeString('it-IT')}`);
                }
            }
        }
        
        parseDate(dateObj) {
            try {
                let date = dateObj;
                if (typeof dateObj === 'string') {
                    date = new Date(dateObj);
                }
                
                if (date instanceof Date && !isNaN(date.getTime())) {
                    return date;
                }
            } catch (e) {
                return null;
            }
            return null;
        }
        
        parseDuration(duration) {
            let durationMinutes = 30; // default
            
            if (duration) {
                if (duration instanceof Date || Object.prototype.toString.call(duration) === '[object Date]') {
                    durationMinutes = duration.getHours() * 60 + duration.getMinutes();
                } else if (typeof duration === 'string') {
                    const colonMatch = duration.match(/(\d+):(\d+)(?::(\d+))?/);
                    if (colonMatch) {
                        const hours = parseInt(colonMatch[1]) || 0;
                        const minutes = parseInt(colonMatch[2]) || 0;
                        durationMinutes = hours * 60 + minutes;
                    } else if (/^\d+$/.test(duration)) {
                        durationMinutes = parseInt(duration);
                    }
                }
            }
            
            return durationMinutes;
        }
        
        calculateDurations(programs, fillGaps) {
            if (!fillGaps || programs.length < 2) {
                // Default 30 minute duration
                programs.forEach(program => {
                    if (!program.endTime) {
                        program.endTime = new Date(program.startTime.getTime() + 30 * 60 * 1000);
                        program.duration = 30 * 60;
                    }
                });
                return;
            }
            
            this.app.addLog('\nApplico gap filling...');
            
            for (let i = 0; i < programs.length; i++) {
                const currentProgram = programs[i];
                let endTime;
                
                if (i + 1 < programs.length) {
                    const nextProgram = programs[i + 1];
                    const currentDay = currentProgram.startTime.toDateString();
                    const nextDay = nextProgram.startTime.toDateString();
                    
                    if (currentDay === nextDay) {
                        endTime = new Date(nextProgram.startTime);
                    } else {
                        endTime = new Date(currentProgram.startTime);
                        endTime.setMinutes(endTime.getMinutes() + 30);
                    }
                } else {
                    endTime = new Date(currentProgram.startTime);
                    endTime.setMinutes(endTime.getMinutes() + 30);
                }
                
                currentProgram.endTime = endTime;
                currentProgram.duration = Math.max(60, Math.floor((endTime - currentProgram.startTime) / 1000));
            }
        }
        
        getTargetDates(dateRange, workbook, weekdayMap) {
            const today = new Date();
            const targetDates = [];
            
            if (dateRange === 'today') {
                targetDates.push(today);
            } else if (dateRange === 'tomorrow') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                targetDates.push(tomorrow);
            } else if (dateRange === 'week') {
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() + i);
                    targetDates.push(date);
                }
            } else {
                // 'all' - process all available sheets
                for (let weekOffset = 0; weekOffset < 4; weekOffset++) {
                    for (const sheetName of Object.keys(weekdayMap)) {
                        if (workbook && workbook.Sheets[sheetName]) {
                            const targetWeekday = weekdayMap[sheetName];
                            const date = new Date(today);
                            const daysUntilTarget = (targetWeekday - today.getDay() + 7) % 7;
                            date.setDate(today.getDate() + daysUntilTarget + (weekOffset * 7));
                            targetDates.push(date);
                        }
                    }
                }
            }
            
            return targetDates;
        }
        
        getExtendedDates(targetDates) {
            const extendedDates = new Set();
            
            for (const targetDate of targetDates) {
                const dayBefore = new Date(targetDate);
                dayBefore.setDate(targetDate.getDate() - 1);
                extendedDates.add(dayBefore.toDateString());
                extendedDates.add(targetDate.toDateString());
                const dayAfter = new Date(targetDate);
                dayAfter.setDate(targetDate.getDate() + 1);
                extendedDates.add(dayAfter.toDateString());
            }
            
            return extendedDates;
        }
        
        getExtendedDatesForRange(dateRange) {
            const today = new Date();
            const dates = new Set();
            
            if (dateRange === 'today' || dateRange === 'tomorrow' || dateRange === 'week') {
                const targetDates = this.getOutputTargetDates(dateRange);
                for (const date of targetDates) {
                    const dayBefore = new Date(date);
                    dayBefore.setDate(date.getDate() - 1);
                    dates.add(this.formatDateString(dayBefore));
                    dates.add(this.formatDateString(date));
                    const dayAfter = new Date(date);
                    dayAfter.setDate(date.getDate() + 1);
                    dates.add(this.formatDateString(dayAfter));
                }
            }
            
            return dates;
        }
        
        getOutputTargetDates(dateRange) {
            const today = new Date();
            const dates = [];
            
            if (dateRange === 'today') {
                dates.push(today);
            } else if (dateRange === 'tomorrow') {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                dates.push(tomorrow);
            } else if (dateRange === 'week') {
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() + i);
                    dates.push(date);
                }
            } else {
                // For 'all', return the next 7 days as default
                for (let i = 0; i < 7; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() + i);
                    dates.push(date);
                }
            }
            
            return dates;
        }
        
        formatDateString(date) {
            return date.getFullYear() + '-' +
                String(date.getMonth() + 1).padStart(2, '0') + '-' +
                String(date.getDate()).padStart(2, '0');
        }
        
        isProgramInDateRange(program, extendedDates) {
            if (extendedDates.size === 0) return true;
            
            const programDateStr = this.formatDateString(program.startTime);
            return extendedDates.has(programDateStr);
        }
        
        getDescription(program) {
            if (program.longDesc && program.longDesc !== program.title && program.longDesc.trim() !== '') {
                return program.longDesc;
            } else if (program.shortDesc && program.shortDesc !== program.title && program.shortDesc.trim() !== '') {
                return program.shortDesc;
            } else if (program.description && program.description.trim() !== '') {
                return program.description;
            } else if (program.isFiller) {
                return program.description || program.title;
            }
            return null;
        }
        
        getRating(program) {
            if (program.rating && program.rating !== 'U' && program.rating.trim() !== '') {
                return this.app.config.ratingMapping[program.rating] || '0';
            }
            return '0';
        }
    }
    
    // Initialize the application
    const app = new EPGConverter();
    
    </script>
</body>
</html>
